import HelperAsset from './HelperAsset.js';
import HelperTags from './HelperTags.js';
import * as EditorAsset from './EditorAsset.js';
import * as EditorCondition from './EditorCondition.js';
import * as EditorGameAction from './EditorGameAction.js';
import { Effect, Wrapper } from '../../classes/EffectSys.js';
import Dungeon, { DungeonRoom, DungeonRoomAsset } from '../../classes/Dungeon.js';
import {default as WebGL, Stage} from '../../classes/WebGL.js';
import {default as libMeshes, LibMesh, getNonDoorMeshes} from '../../libraries/meshes.js';
import TransformControls from '../../ext/TransformControls.js';
import * as THREE from '../../ext/THREE.js'; 
import Window from '../WindowManager.js';
import GameAction from '../../classes/GameAction.js';

const DB = 'dungeonRooms',
	CONSTRUCTOR = DungeonRoom,
	ASSET_HISTORY_STATES = 50	
;
	


// Single asset editor
export function asset(){

	const 
		modtools = window.mod,
		id = this.id,
		asset = modtools.mod.getAssetById(DB, id),
		dummy = CONSTRUCTOR.loadThis(asset)
	;

	if( !asset )
		return this.close();

	//this.assets = [];			// First asset is always the room. These are DungeonRoomAssets

	let html = '';

	// Todo: Put the 3d editor here
	html += '<div class="webglRenderer">'+
		'<div class="pusher"></div>'+
		'<div class="content"></div>'+
	'</div>';


	// Todo: Add the asset inserter
	html += '<div class="assetInserter">';
		html += '<select id="meshToTest" multiple>';
		for( let i in libMeshes )
			html += '<option value="'+i+'">'+i+'</option>';
		html += '</select>';
	html += '</div>';

	html += '<div class="labelFlex">';
		html += '<label>Name: <input type="text" name="name" class="saveable" value="'+esc(dummy.name)+'" /></label>';
		html += '<label>Outdoors <input type="checkbox" class="saveable" name="outdoors" '+(dummy.outdoors ? 'checked' : '')+' /></label><br />';
		html += '<label title="Lets you change the loading zoom, 0 for auto">Zoom: <input type="number" min=0 step=1 name="zoom" class="saveable" value="'+esc(dummy.zoom)+'" /></label>';
		html += '<label>Ambiance: <input type="text" name="ambiance" class="saveable" value="'+esc(dummy.ambiance)+'" /></label>';
		html += '<label>Ambiance volume: <input type="range" name="ambiance_volume" min=0 max=1 step=0.1 class="saveable" value="'+esc(dummy.ambiance_volume)+'" /></label>';

		html += '<label>Asset: <select class="roomBaseAsset">';
		LibMesh.iterate((mesh, path) => {
			if( mesh.isRoom )
				html += '<option value="'+esc(path)+'">'+esc(path)+'</option>';
		});	
		html += '</select></label>';
		
	html += '</div>';

	

	

	html += 'Tags: <br /><div name="tags">'+HelperTags.build(dummy.tags)+'</div>';
	html += '<span title="Picks the first viable one when you enter, stays with it until respawn is triggered">Encounters:</span> <div class="encounters"></div>';
	

	this.setDom(html);
	// Bind linked objects
	this.dom.querySelector("div.encounters").appendChild(EditorAsset.assetTable(this, asset, "encounters"));	
	// Tags
	HelperTags.bind(this.dom.querySelector("div[name=tags]"), tags => {
		HelperTags.autoHandleAsset('tags', tags, asset);
	});

	HelperAsset.autoBind( this, asset, DB);


	new Editor(this, asset);


};


// Creates a table for this asset in another asset
export function assetTable( win, modAsset, name, single, parented, ignoreAsset ){
	return HelperAsset.linkedTable( win, modAsset, name, CONSTRUCTOR, DB, ['label', 'name'], single, parented, ignoreAsset);
}


class Editor{

	// Asset is the room
	constructor( win, asset ){

		const modtools = window.mod,
			gl = modtools.webgl;
		this.gl = gl;
		this.win = win;
		this.assetWindow = null;

		// Add transform controls
		const control = new TransformControls( gl.camera, gl.renderer.domElement, () => {});
		this.control = control;
		control.setTranslationSnap(1);
		control.setRotationSnap(THREE.Math.degToRad(1));
		control.addEventListener( 'dragging-changed', function( event ){
			gl.controls.enabled = !event.value;
		});

		// Handle dragging the tool
		this.saveTimer;
		this.dragging = false;
		this.changed = false;
		

		control.addEventListener( 'mouseUp', evt => {
			if( this.changed ){

				this.changed = false;
				const mesh = evt.target.object,
					entry = mesh.userData.dungeonAsset
				;

				entry.absolute = true;	// Tiles are generated by procedural, but in the editor we set absolute positions
				entry.x = mesh.position.x;
				entry.y = mesh.position.y;
				entry.z = mesh.position.z;
				entry.rotX = mesh.rotation.x;
				entry.rotY = mesh.rotation.y;
				entry.rotZ = mesh.rotation.z;
				entry.scaleX = mesh.scale.x;
				entry.scaleY = mesh.scale.y;
				entry.scaleZ = mesh.scale.z;

				this.save();

				this.addHistory(entry);

			}
		});
		control.addEventListener( 'objectChange', evt => {
			this.changed = true;
		});

		gl.scene.add(control);
		gl.onRender = function(){
			control.update();
		};
		


		const 
			renderDiv = win.dom.querySelector('div.webglRenderer'),
			contentDiv = win.dom.querySelector('div.webglRenderer > div.content');

		this.renderDiv = renderDiv;
		this.contentDiv = contentDiv;
		this.room_raw = asset;
		this.room = DungeonRoom.loadThis(asset);
		this.rebase();

		modtools.webgl.renderer.domElement.tabIndex = 0;
		modtools.webgl.renderer.domElement.onkeydown = event => {
			
			if( event.key === "w" )
				control.setMode( "translate" );
			else if( event.key === "e" )
				control.setMode( "rotate" );
			else if( event.key === "r" )
				control.setMode( "scale" );
			else if( event.key === "q" )
				control.setSpace( control.space === "local" ? "world" : "local" );
			else if( event.key === 'Control' ){
				control.setTranslationSnap( 100 );
				control.setRotationSnap( THREE.Math.degToRad( 15 ) );
			}
			else if( event.key === "Delete" ){
				this.removeMesh(control.object);
				this.buildAssetEditor();
			}
			else if( event.key === "z" && event.ctrlKey )
				this.traverseHistory(control.object.userData.dungeonAsset, -1);
			else if( event.key === "y" && event.ctrlKey )
				this.traverseHistory(control.object.userData.dungeonAsset, 1);
			
		};

		modtools.webgl.renderer.domElement.onkeyup = event => {
			if( event.key === 'Control' ){

				control.setTranslationSnap( null );
				control.setRotationSnap( null );
			}
		};

		const baseAssetSelect = win.dom.querySelector('select.roomBaseAsset');
		const roomAsset = this.room.getRoomAsset();
		if( roomAsset )
			baseAssetSelect.value = roomAsset.model;
		baseAssetSelect.onchange = () => {
			this.room.getRoomAsset().model = baseAssetSelect.value;
			this.save();
			this.draw();
		};
		const outdoorToggle = win.dom.querySelector('input[name=outdoors]');
		outdoorToggle.addEventListener('change', () => {
			this.room.outdoors = Boolean(outdoorToggle.checked);
			this.draw();
		});

		contentDiv.appendChild(modtools.webgl.renderer.domElement);

		const onResize = () => {

			const rect = renderDiv.getBoundingClientRect();
			const width = rect.width, height = rect.height;

			gl.renderer.domElement.style.width = 'auto';
			gl.renderer.domElement.style.height = 'auto';
			gl.renderer.domElement.width  = width;
			gl.renderer.domElement.height = height;

			gl.renderer.setSize(width, height);
			gl.renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
			gl.composer.setSize(width, height);
			
			gl.camera.aspect = width / height;
			gl.camera.updateProjectionMatrix();

			gl.fxRenderer.setSize(width, height);
			gl.fxCam.aspect = width/height;
			gl.fxCam.updateProjectionMatrix();


		};

		// Attach the 3d editor
		// The DOM will be inaccurate without the delay because HTML
		setTimeout(onResize, 1);
		
		gl.updateSize = onResize;
		win.onResize = onResize;

		this.draw();


		// Mesh add selector
		win.dom.querySelector('div.assetInserter > select').onchange = () => {
			this.updateMeshSelects(0);
		};


		win.onChange = () => {
			this.save();
		};

	}
	

	// Takes a mesh object, finds it, and removes it
	removeMesh( mesh ){

		const dungeonAsset = mesh.userData.dungeonAsset;

		for( let i in this.room.assets ){
			
			const asset = this.room.assets[i];
			if( dungeonAsset === asset ){

				this.room.assets.splice(i, 1);
				this.gl.stage.remove(mesh);
				if( mesh === this.control.object )
					this.control.detach();
				this.save();

				return;
			}

		}


	}

	// Adds a new mesh and returns a dungeonRoomAsset
	async addMesh( path ){

		const mesh = LibMesh.getByString(path);
		if( !mesh )
			throw 'Unable to find mesh with path: '+path;
		
		let asset = new DungeonRoomAsset({
			model : path,
		}, this.room);

		asset.__history = [asset.save('mod')];
		asset.__historyMarker = 0;
		this.room.addAsset(asset);
		await this.gl.stage.addDungeonAsset(asset);
		this.save();
		this.bindMeshes();
		this.buildAssetEditor();
		return asset;

	}

	updateMeshSelects( index ){

		let path = [];
		const selects = this.win.dom.querySelectorAll('div.assetInserter > select');
		selects.forEach((el, i) => {
			if( i > index )
				el.remove();
			else if( el.value )
				path.push(el.value);
		});

		let meshes = getNonDoorMeshes();

		if( !path.length )
			return;

		let i = "";
		for( i of path )
			meshes = meshes[i];

		// Set this as mesh to add
		if( meshes.constructor === LibMesh ){

			selects[selects.length-1].querySelector('option[value=\''+i+'\']').ondblclick = () => {
				this.addMesh(path.join('.'));
			};

		}
		// Draw a selector
		else{

			let select = document.createElement('select');
			select.multiple = true;
			select.name = path.length;
			for( let m in meshes ){
				let obj = meshes[m];
				select.innerHTML += '<option value="'+m+'">'+(obj.constructor === LibMesh ? '[M] ' : '') + m+'</option>';
			}
			this.win.dom.querySelector('div.assetInserter').append(select);


			select.onchange = () => {
				this.updateMeshSelects(path.length);
			};

		}
		

	}

	traverseHistory( asset, direction = -1 ){

		asset.__historyMarker = Math.min(Math.max(asset.__historyMarker+direction, 0), asset.__history.length-1);
		asset.load(asset.__history[asset.__historyMarker]);
		this.gl.stage.updatePositionByAsset(asset);
		this.save();

	}


	addHistory( asset ){

		// Start by splicing anything ahead of us
		if( asset.__historyMarker < asset.__history.length-1 ){
			console.log("Splicing from index", asset.__historyMarker+1);
			asset.__history.splice(asset.__historyMarker+1);
		}

		asset.__history.push(asset.save("mod"));
		++asset.__historyMarker;

		if( asset.__history.length > ASSET_HISTORY_STATES ){
			asset.__history.shift();
			--asset.__historyMarker;
		}
		console.log("After adding: ", asset.__history);

	}

	// Try to rebase on start. If you rebase any time later, you'll fuck up history states
	rebase(){
		
		// Encounters can be a single encounter once one has started, but is always an array in the editor
		if( !Array.isArray(this.room.encounters) )
			this.room.encounters = [];

		// Make sure there's a room asset
		if( !this.room.assets.length ){

			const roomAsset = new DungeonRoomAsset({
				model : 'Dungeon.Room.R10x10',
				room : true
			}, this.room);
			this.room.addAsset(roomAsset);
			this.save();

		}
		
		this.room.rebase();
		this.room.parent = new Dungeon(window.mod.mod.getAssetById(this.room_raw._mParent.type, this.room_raw._mParent.label ));

		// Build initial history state
		for( let asset of this.room.assets ){
			asset.rebase();
			asset.__history = [asset.save("mod")];
			asset.__historyMarker = 0;
		}

	}

	// Tries to save the room dummy onto room_raw
	save(){

		console.trace("Saving", this.room.assets);
		const data = this.room.save("mod");
		this.room_raw.assets = data.assets;
		window.mod.setDirty(true);


	}

	bindMeshes(){

		for( let asset of this.room.assets ){
			
			if( asset.room )
				continue;

			const mesh = asset._stage_mesh;

			mesh.userData.click = () => {
				this.control.detach();
				this.control.attach(mesh);
			};

			mesh.userData.dblclick = () => {
				this.buildAssetEditor();
			};

			Stage.bindGenericHover(mesh);

			
		}

	}

	async draw(){

		if( this.gl.stage )
			this.gl.stage.destructor();

		let stage = new Stage(this.room, this.gl, true);
		this.gl.resetStage( stage );
		await stage.draw();
		stage.toggle( true );

		this.bindMeshes();

	}
	

	// Build the asset editor co-screen
	buildAssetEditor(){

		// Asset window already exists, rebuild it
		if( this.assetWindow ){
			this.assetWindow.rebuild.call(this.assetWindow);
			return;
		}
		const th = this;

		const build = function(){

			const asset = th.control.object.userData.dungeonAsset;
			if( !asset ){
				this.close();
				return;
			}

			this.asset.asset = asset;	// Needs to be set because dungeonAsset doesn't have a library

			if( this.isHidden() )
				this.bringToFront();
			this.dom.classList.toggle("hidden", false);
			

			let html = '';
			html += '<div class="labelFlex">';
				html += '<label>Name: <input name="name" value="'+esc(asset.name)+'" type="text" class="saveable" /></label>';
				html += '<label title="Time in seconds, 0 = no respawn">Respawn: <input name="respawn" value="'+esc(asset.respawn)+'" type="text" class="saveable" /></label>';
				html += '<label>Hide if non-interactive: <input name="hide_no_interact" '+(asset.hide_no_interact ? 'checked' : '')+' type="checkbox" class="saveable" /></label>';
			html += '</div>';

			html += 'Tags: <div class="tags">'+HelperTags.build(asset.tags)+'</div>';
			html += 'Game Actions: <div class="interactions"></div>';
			html += 'Conditions: <div class="conditions"></div>';

			this.setDom(html);


			HelperTags.bind(this.dom.querySelector("div.tags"), tags => {
				HelperTags.autoHandleAsset('tags', tags, asset);
				th.save();
			});

			
			this.dom.querySelector("div.interactions").appendChild(EditorGameAction.assetTable(this, asset, "interactions", false, 2));

			this.dom.querySelector("div.conditions").appendChild(EditorCondition.assetTable(this, asset, "conditions", false, false, false));	


			HelperAsset.autoBind( this, asset, DB, (field, value) => {
				th.save();
			});

			const table = this.dom.querySelector('div.interactions table');


			// Searches our interactions by id
			const openGameActionEditor = id => {
				
				// Find it in our list
				for( let a of asset.interactions ){

					// This was a string, open editor
					if( a === id ){

						const asset = window.mod.mod.getAssetById('gameActions', a);
						if( !asset ){
							alert("Asset missing or not from this mod");
							return;
						}
						window.mod.buildAssetEditor( 'gameActions', id, undefined, this );
						return;

					}
					else if( a && a.id === id || a.label === id ){

						window.mod.buildAssetEditor( 'gameActions', a, undefined, this );

					}

				}
				
			}


			// Bind each table row
			table.querySelectorAll("tr.asset").forEach(el => el.onclick = event => {
				
				const id = el.dataset.id;

				// Delete from linked array
				if( event.ctrlKey ){

					for( let i in asset.interactions ){
						const e = asset.interactions[i];
						if( e === id || e.id === id || e.label === id ){

							asset.interactions.splice(i, 1);
							this.rebuild();
							return;
						}
						
					}

					return;
				}
				openGameActionEditor(id);

			});
			
			// Bind the add new button
			table.querySelector("input.addNew").onclick = () => {

				const linker = window.mod.buildAssetLinker( this, asset, 'interactions', 'gameActions', false );

				linker.dom.querySelector('input.new').onclick = event => {
			
					const obj = new GameAction();
					if( !asset.interactions )
						asset.interactions = [];
					asset.interactions.push(obj);
					linker.remove();
					this.rebuild();	
					
					openGameActionEditor(obj.id);

				};
	
			};


		};

		this.assetWindow = Window.create('REPLACE_ID', 'dungeonAssets', '', 'crafting', build, {}, this.win);
		this.assetWindow.hideOnClose = true;
		this.assetWindow.rebuild();	// Needed in case the window already exists
		this.assetWindow.onChange = () => build.call(this.assetWindow);

	}


}



