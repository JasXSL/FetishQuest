import Generic from './helpers/Generic.js';
import Action from "./Action.js";
import Asset from "./Asset.js";
import stdTag from "../libraries/stdTag.js";

import { Wrapper, Effect } from './EffectSys.js';
import Bot from './Bot.js';
import PlayerClass from './PlayerClass.js';
import Calculator from './Calculator.js';
import GameEvent from './GameEvent.js';
import Dungeon from './Dungeon.js';
import Roleplay from './Roleplay.js';
import Condition from './Condition.js';

const BASE_HP = 40;
const BASE_MP = 10;
const BASE_AP = 10;
const BASE_AROUSAL = 10;


export default class Player extends Generic{

	constructor(data){

		super(data);

		this.label = '';					// Unique editor label
		this.netgame_owner_name = '';		// This is a custom thing that should only be relied on when adding a new player
		this.netgame_owner = '';			// ID corresponding to one from game.net.players
		this.afk = false;					// Treats this as a bot if true. Can be toggled by the netgame owner
		this.name = "Adventurer";			// Name
		this.species = "";
		this.description = "";
		this.icon = "";						// URL - Has to be HTTPS
		this.icon_upperBody = "";			// == || ==
		this.icon_lowerBody = "";			// == || ==
		this.icon_nude = "";				// == || ==
		this.auto_learn = true;			// if true, this player always knows all their spells
		this.leader = false;				// Party leader
		this.generated = false;				// This was generated by an encounter, and should be purged when leaving the cell

		this.actions = [];			// Unlocked actions. Action objects, use getActions since assets can also add actions
		this.assets = [];			// Asset objects, use getAssets
		this.inventory = [];		// NPC only. This is an array of numbers specifying which items above are equipped when entering the game.
		this.tmp_actions = [];		// Actions applied this battle
		this.active_actions = [0,0,0,0,0,0];	// IDs of actions or 0 if empty

		this.tags = [];				// Player tags, these are automatically prefixed with PL_, use getTags
		this.wrappers = [];			// Wrappers, use getWrappers
		this.auto_wrappers = [];	// Automatic wrappers such as encumbered
		this.passives = [];			// Passive effects that should not be cleared when a battle starts or ends
		this.hp = BASE_HP;				// 
		this.ap = 0;				// Action points, stacking up to 10 max, 3 awarded each turn
		this.team = 0;				// 0 = player
		this.size = 5;				// 0-10
		this.level = 1;				// 
		this.experience = 0;
		this.mp = 10;				// Secondary stat used for spells. Mana points.
		this.arousal = 0;
		this.leveled = false;		// Level is an offset of the player average level
		this.powered = false;		// Boost stats based on nr of players in the player team
		this.disabled = false;		// Disable a player, ignoring drawing it and ignoring it in game methods

		// Primary stats
		this.stamina = 0;			// Adds 2 HP per point
		this.agility = 0;				// Adds 1 AP per point
		this.intellect = 0;			// Adds 1 MP per point

		this.svPhysical = 0;
		this.svElemental = 0;
		this.svHoly = 0;
		this.svCorruption = 0;

		this.bonPhysical = 0;
		this.bonElemental = 0;
		this.bonHoly = 0;
		this.bonCorruption = 0;
		this.bot = null;
		this.used_punish = false;				// We have punished a target since the last battle ended or we left the room

		this.remOnDeath = false;				// Delete this player if it dies

		// Personality types
		this.talkative = 0.1;					// How often they output combat chats. Multiplied by nr turns. So after 1 turn, 0.5 = 50% chance, 2 turns = 100% etc. Setting this to one overrides the limit of one chat per turn.
		this.sadistic = 0.5;					// Normal vs Sadistic
		this.dominant = 0.8;					// Dominant vs submissive
		this.hetero = 0.5;						// 0 = gay, 0.5 = bi, 1 = straight
		this.intelligence = 0.6;				// 0 = No intelligence, .1 = Mollusk, .2 = Animal, .4 = Child, .6 = Average human, .9 = Mastermind, 1 = Godlike
												/* Notes on intelligence:
													<= 0 = It has no intelligence and always attacks a random player, even friendly players
													< 0.2 = No longer attacks friends, but doesn't use the aggro system.
													>= 0.2 = Now able to use the aggro system, but only short term, wiping aggro at the end of their turn
													>= 0.4 = Can speak, now affected by the full aggro system
													>= 0.6 + Judging = Able to set traps, triggering at the start of a battle
													>= 0.8 = Now too smart for aggro, always picks targets carefully
												*/
		this.class = null;
		this._stun_diminishing_returns = 0;		// Rounds you can't be stunned

		this._turns = 0;						// Total turns played in combat
		this._turn_ap_spent = 0;				// AP spent on actions this turn
		this._threat = {};						// playerID : threatAmount

		// These are incoming damage
		this._damaging_since_last = {};			// playerID : {(str)dmageType:(int)nrDamagingAttacks} - nr damaging actions received since last turn. Not the actual damage.
		this._damage_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total damage points player received since last turn.
		// Same as above, but DONE by this player
		this._d_damaging_since_last = {};			// playerID : {(str)dmageType:(int)nrDamagingAttacks} - nr damaging actions received since last turn. Not the actual damage.
		this._d_damage_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total damage points player received since last turn.
		this._targeted_by_since_last = {};			// playerID : (int)num_actions - Total actions directly targeted at you since last turn. (AoE doesn't count)
		
		this._used_chats = {};					// id : true - Chats used. Not saved or sent to netgame. Only exists in the local session to prevent NPCs from repeating themselves.
		this._last_chat = 0;					// Turn we last spoke on. 

		this._turn_tags = [];					// {tag:(str)tag, s:(Player)sender}... These are wiped whenever an action text is used
		
		this.color = '';						// Assigned by the game

		// Prevents recursion for encumbrance
		this._ignore_effects = null;			// Internal helper that prevents recursion
		this._difficulty = 1;					// Added from monster template, used in determining exp rewards
		this._bound_wrappers = [];
		this._cache_tags = null;					// Holds all active tags in a cache for quicker validation
		this._cache_stamina = false;
		this.load(data);
		
	}

	load(data){

		this.g_autoload(data);

	}

	// Automatically invoked after g_autoload
	rebase(){

		this.actions = Action.loadThese(this.actions, this);
		this.assets = Asset.loadThese(this.assets, this);
		this.wrappers = Wrapper.loadThese(this.wrappers, this);
		this.passives = Wrapper.loadThese(this.passives, this);
		this.tmp_actions = Action.loadThese(this.tmp_actions, this);

		if( window.game ){
			this.class = PlayerClass.loadThis(this.class, this);
			this.updatePassives();
			if( !game.is_host )
				this.auto_wrappers = Wrapper.loadThese(this.auto_wrappers, this);
		}
		
		if( this.class === null )
			this.class = new PlayerClass();


	}

	// Data that should be saved to drive
	save( full ){

		if( window.game && game.is_host )
			this.updateAutoWrappers();

		const out = {
			auto_learn : this.auto_learn,
			disabled : this.disabled,
			name : this.name,
			icon : this.icon,
			actions : Action.saveThese(this.actions, full),
			tags : this.tags,
			team : this.team,
			species : this.species,
			description : this.description,
			size : this.size,
			level : this.level,
			class : this.class.save(full),
			stamina : this.stamina,
			agility : this.agility,
			intellect : this.intellect,
			svPhysical : this.svPhysical,
			svElemental : this.svElemental,
			svHoly : this.svHoly,
			svCorruption : this.svCorruption,
			bonPhysical : this.bonPhysical,
			bonElemental : this.bonElemental,
			bonHoly : this.bonHoly,
			bonCorruption : this.bonCorruption,
			used_punish : this.used_punish,
			leader : this.leader,
			talkative : this.talkative,
			tmp_actions : Action.saveThese(this.tmp_actions, full),
			label : this.label,
			icon_lowerBody : this.icon_lowerBody,
			icon_nude : this.icon_nude,
			icon_upperBody : this.icon_upperBody,
			powered : this.powered,
			passives : Wrapper.saveThese(this.passives, full),
			active_actions : this.active_actions.slice(),
		};

		if( this.rp )
			out.rp = this.rp.save(full);

		if( full !== "mod" )
			out.experience = this.experience;

		// Assets are only sent if equipped, PC, or full
		out.assets = Asset.saveThese(this.assets.filter(el => full || el.equipped || !this.isNPC() || this.isDead()), full);

		if( full ){
			out.generated = this.generated;
			out.remOnDeath = this.remOnDeath;
			out.leveled = this.leveled;
			out.inventory = this.inventory;
			out.talkative = this.talkative;
			out.sadistic = this.sadistic;					// Normal vs Sadistic
			out.dominant = this.dominant;					// Dominant vs submissive
			out.hetero = this.hetero;						// 0 = gay, 0.5 = bi, 1 = straight
			out.intelligence = this.intelligence;
			if( full !== "mod" ){
				out._stun_diminishing_returns = this._stun_diminishing_returns;
				out._difficulty = this._difficulty;
				out._threat = this._threat;
				out._turn_ap_spent = this._turn_ap_spent;
				out._damaging_since_last = this._damaging_since_last;
				out._damage_since_last = this._damage_since_last;
				out._d_damaging_since_last = this._d_damaging_since_last;
				out._d_damage_since_last = this._d_damage_since_last;
				out._targeted_by_since_last = this._targeted_by_since_last;
				out._turns = this._turns;
			}

		}


		// Everything except mod
		if( full !== "mod" ){
			out.id = this.id;
			out.ap = this.ap;
			out.hp = this.hp;
			out.mp = this.mp;
			out.wrappers = this.wrappers.map(el => el.save(full));
			out.netgame_owner = this.netgame_owner;
			out.netgame_owner_name = this.netgame_owner_name;
			out.color = this.color;
			out.arousal = this.arousal;
		}
		else
			this.g_sanitizeDefaults(out);

		return out;
	}

	// Code that's run after the game has finished loading
	initialize(){
		// Apply constraints
		this.addHP(0);
		this.addMP(0);
		this.addAP(0);
		this.updateAutoWrappers();
		this.addDefaultActions();
		
		if( game.is_host ){
			this.rebindWrappers();
		}
	}

	rebindWrappers(){
		this.unbindWrappers();
		let w = this.getWrappers();
		w.map(wrapper => {
			wrapper.bindEvents();
		});
		this._bound_wrappers = w;
	}

	unbindWrappers(){
		for( let wrapper of this._bound_wrappers )
			wrapper.unbindEvents();
	}

	cacheTags(){
		let tags = this.getTags(undefined, true);
		this._cache_tags = {};
		for( let tag of tags ){
			this._cache_tags[tag] = true;
		}
		this._cache_tags = Object.keys(this._cache_tags);
	}

	uncacheTags(){
		this._cache_tags = null;
	}


	/* Metadata */

	// For these functions, type is an Action.Types value, if undefined, it counts ALL types
	// Returns how many damaging actions a player has used since this one's last turn
	damagingSinceLastByPlayer( player, type ){
		if( player && player.constructor === Player )
			player = player.id;
		if( !this._damaging_since_last[player] )
			return 0;
		let out = 0;
		for( let i in this._damaging_since_last[player] ){
			if( i === type || type === undefined )
				out += this._damaging_since_last[player][i];
		}
		return out;
	}
	damageSinceLastByPlayer( player, type ){
		if( player && player.constructor === Player )
			player = player.id;
		if( !this._damage_since_last[player] )
			return 0;
		let out = 0;
		for( let i in this._damage_since_last[player] )
			if( i === undefined || i === type )
			out += this._damage_since_last[player][i];
		return out;
	}
	damagingDoneSinceLastToPlayer( player, type ){
		if( player && player.constructor === Player )
			player = player.id;
		if( !this._d_damaging_since_last[player] )
			return 0;
		let out = 0;
		for( let i in this._d_damaging_since_last[player] ){
			if( i === type || type === undefined )
				out += this._d_damaging_since_last[player][i];
		}
		return out;
	}
	damageDoneSinceLastToPlayer( player, type ){
		if( player && player.constructor === Player )
			player = player.id;
		if( !this._d_damage_since_last[player] )
			return 0;
		let out = 0;
		for( let i in this._d_damage_since_last[player] )
			if( i === undefined || i === type )
			out += this._d_damage_since_last[player][i];
		return out;
	}
	// Calculates a total number for any of the above, allowing you to filter by type 
	// Use the object property as input, and it returns the sum
	datTotal( input, type ){
		let out = 0;
		for( let i in input ){
			for( let t in input[i] ){
				if( t === type || type === undefined )
					out += input[i][t];
			}
		}
		return out;
	}

	

	// When run from an effect, the effect needs to be present to prevent recursion 
	// prefix is usually se_ or ta_
	appendMathVars(prefix, vars, event){

		let isRoot = this._ignore_effects === null;
		if( isRoot )
			this._ignore_effects = [];

		if( event && event.effect )
			this._ignore_effects.push(event.effect);
		// Theres a recursion here when math is used in SV/Bon and to get SV/Bon you need math
		vars[prefix+'SvPhysical'] = this.getSV(Action.Types.physical);
		vars[prefix+'SvElemental'] = this.getSV(Action.Types.elemental);
		vars[prefix+'SvHoly'] = this.getSV(Action.Types.holy);
		vars[prefix+'SvCorruption'] = this.getSV(Action.Types.corruption);
		
		vars[prefix+'BonPhysical'] = this.getBon(Action.Types.physical);
		vars[prefix+'BonElemental'] = this.getBon(Action.Types.elemental);
		vars[prefix+'BonHoly'] = this.getBon(Action.Types.holy);
		vars[prefix+'BonCorruption'] = this.getBon(Action.Types.corruption);
		vars[prefix+'Lv'] = this.level;
		vars[prefix+'HP'] = this.hp;
		vars[prefix+'AP'] = this.ap;
		vars[prefix+'Arousal'] = this.arousal;
		vars[prefix+'Team'] = this.team;
		vars[prefix+'Size'] = this.size;
		vars[prefix+'MaxHP'] = this.getMaxHP();
		vars[prefix+'MaxAP'] = this.getMaxAP();
		vars[prefix+'MaxMP'] = this.getMaxMP();
		vars[prefix+'MaxArousal'] = this.getMaxArousal();
		vars[prefix+'Money'] = this.getMoney();
		vars[prefix+'apSpentThisTurn'] = this._turn_ap_spent;

		vars[prefix+'ButtSize'] = this.getGenitalSizeValue(stdTag.butt);
		vars[prefix+'BreastSize'] = this.getGenitalSizeValue(stdTag.breasts);
		vars[prefix+'PenisSize'] = this.getGenitalSizeValue(stdTag.penis);

		let tags = this.getTags();
		for( let tag of tags )
			vars[prefix+'Tag_'+tag] = 1;

		// Get a total value
		vars[prefix+'damagingReceivedSinceLast'] = this.datTotal( this._damaging_since_last );
		vars[prefix+'damageReceivedSinceLast'] = this.datTotal( this._damage_since_last );
		vars[prefix+'damagingDoneSinceLast'] = this.datTotal( this._d_damaging_since_last );
		vars[prefix+'damageDoneSinceLast'] = this.datTotal( this._d_damage_since_last );
		vars[prefix+'targetedSinceLast'] = objectSum(this._targeted_by_since_last);
		for( let i in Action.Types ){
			let type = Action.Types[i];
			vars[prefix+'damagingReceivedSinceLast'+type] = this.datTotal( this._damage_since_last, type );
			vars[prefix+'damageReceivedSinceLast'+type] = this.datTotal( this._damage_since_last, type );
			vars[prefix+'damagingDoneSinceLast'+type] = this.datTotal( this._d_damaging_since_last, type );
			vars[prefix+'damageDoneSinceLast'+type] = this.datTotal( this._d_damage_since_last, type );
		}

		// We're the recipient, if a sender exists we can add how much damage the sender has done to us
		if( event && this === event.target && event.sender ){
			vars.se_TaDamagingReceivedSinceLast = this.damagingSinceLastByPlayer(event.sender);
			vars.se_TaDamageReceivedSinceLast = this.damageSinceLastByPlayer(event.sender);
		}

		for( let i in Asset.Slots ){
			let slot = Asset.Slots[i];
			vars[prefix+slot] = this.getEquippedAssetsBySlots(slot).length ? 1 : 0;
		}

		let wrappers = this.getWrappers();
		for(let wrapper of wrappers){
			if( wrapper.label )
				vars[prefix+'Wrapper_'+wrapper.label] = wrapper.stacks;
		}
		

		if( isRoot )
			this._ignore_effects = null;

		return vars;
	}

	getName(){
		let out = this.name;
		return out;
	}

	getColoredName(){
		return '|c'+this.color+'|'+this.getName()+'|/c|';
	}

	// Statuses
	isDead(){
		return this.hp <= 0;
	}

	isAFK(){
		return game.net.isPlayerAFK(this.netgame_owner);
	}

	isNPC(){
		return !this.netgame_owner || this.isAFK();
	}

	isLootableBy( player ){
		return Boolean(player) && !game.battle_active && this.isDead() && this.getLootableAssets().length && this.team !== player.team;
	}

	isArousalDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableArousal);
	}
	isAPDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableAP);
	}
	isMPDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableMP);
	}
	isNonRequiredForVictory(){
		return this.hasTag('pl_'+stdTag.gpDisableVictoryCondition);
	}
	isHPDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableHP);
	}
	isInvisible(){
		return this.hasTag(stdTag.gpInvisible);
	}
	isSkipAllTurns(){
		return this.hasTag(['pl_'+stdTag.gpSkipTurns, stdTag.gpSkipTurns]);
	}
	isLeader(){
		return this.leader || !game.net.isConnected();
	}

	canRiposte(){
		return !this.hasTag(stdTag.wrNoRiposte);
	}

	// Can't accept their turn
	isIncapacitated(){
		let stun = this.getActiveEffectsByType(Effect.Types.stun);
		return stun.length > 0 || this.isSkipAllTurns();
	}

	// Returns taunting players unless there's a grappling player, in which case that's returned instead
	getTauntedOrGrappledBy( debug ){
		
		let players = this.getGrappledBy();
		if( debug )
			console.debug("Grappled by ", players);
		if( players.length )
			return players;
		return this.getTauntedBy(debug);

	}

	getGrappledBy(){

		let grapples = this.getActiveEffectsByType(Effect.Types.grapple);
		let out = [];
		for( let effect of grapples ){
			let sender = effect.parent.getCaster();
			if( sender && out.indexOf(sender) === -1 )
				out.push(sender);
		}
		return out;

	}

	getTauntedBy( debug ){

		let tauntEffects = this.getActiveEffectsByType(Effect.Types.taunt);
		if( debug )
			console.debug("Taunt effects", tauntEffects);
		if( !tauntEffects.length )
			return game.getEnabledPlayers();

		let out = [];
		for( let effect of tauntEffects ){
			let sender = effect.parent.getCaster();
			if( effect.data && effect.data.victim )
				sender = effect.parent.parent;
			if( sender && out.indexOf(sender) === -1 )
				out.push(sender);
		}
		return out;

	}

	isBeast(){
		return this.hasTag(stdTag.plBeast);
	}





	// ICONS
	getActiveIcon(){
		
		const ub = this.hasTag(stdTag.asUpperBody),
			lb = this.hasTag(stdTag.asLowerBody)
		;
		if( !ub && !lb && this.icon_nude )
			return this.icon_nude;
		if( ub && !lb && this.icon_upperBody )
			return this.icon_upperBody;
		if( !ub && lb && this.icon_lowerBody )
			return this.icon_lowerBody;

		if( !this.icon )
			return 'media/characters/missing_art.jpg';
		return this.icon;

	}




	// RP Tags

	// Searches tags for pl_<prefix>_huge/big/small and returns a synonym
	getSizeTag( prefix ){

		prefix = prefix.substr(3);
		let texts = [""];
		if( this.hasTag('pl_big_'+prefix) )
			texts = ["big", "large", "sizable"];
		else if( this.hasTag('pl_huge_'+prefix) )
			texts = ["huge", "enormous", "gigantic", "massive"];
		else if( this.hasTag('pl_small_'+prefix) )
			texts = ['small'];

		return texts[Math.floor(Math.random()*texts.length)];

	}
	getBreastSizeTag(){
		return this.getSizeTag(stdTag.breasts);
	}
	getPenisSizeTag(){
		return this.getSizeTag(stdTag.penis);
	}
	getButtSizeTag(){
		return this.getSizeTag(stdTag.butt);
	}

	// Returns a value where 0 = none, 1 = small, 2 = average, 3 = large, 4 = huge
	// Prefix should be either stdTag.breasts, stdTag.penis or stdTag.butt
	getGenitalSizeValue( prefix ){

		prefix = prefix.split('_');
		prefix.shift();
		prefix = prefix.join('_');

		if( this.hasTag('pl_huge_'+prefix) )
			return 4;
		if( this.hasTag('pl_big_'+prefix) )
			return 3;
		if( this.hasTag('pl_small_'+prefix) )
			return 1;
		if( this.hasTag('pl_'+prefix) )
			return 2;
		return 0;
	}

	// Overrides the generic definition for this
	getTags(wrapperReturn, force = false){

		if( this._cache_tags && !force )
			return this._cache_tags;

		let out = {};
		if( this.hp <= 0 )
			out[stdTag.dead] = true;

		for( let tag of this.tags ){
			if( !tag.startsWith('pl_') )
				tag = 'pl_'+tag;
			out[tag.toLowerCase()] = true;
		}

		// adds a tag to the name map
		const addTag = tag => out[tag.toLowerCase()] = true;

		let assets = this.getAssetsEquipped();
		if( wrapperReturn && wrapperReturn.armor_strips[this.id] ){
			for( let slot in wrapperReturn.armor_strips[this.id]){
				const a = wrapperReturn.armor_strips[this.id][slot];
				if( assets.indexOf(a) === -1 ){
					assets.push(a);
				}
			}
		}

		for( let asset of assets )
			asset.getTags().map(addTag);

		let fx = this.getWrappers();
		for( let f of fx )
			f.getTags().map(addTag);

		fx = this.getEffects();
		for( let f of fx ){

			f.getTags().map(addTag);
			// Bondage device mapping
			if( f.type === Effect.Types.tieToRandomBondageDevice && f.data._device ){

				const device = game.dungeon.getActiveRoom().getAssetById(f.data._device);
				if( device ){
					
					const dTags = device.getTags();
					for( let tag of dTags )
						out['bo_'+tag.toLowerCase()] = true;

				}
			}

		}
		this._turn_tags.map(t => out[t.tag.toLowerCase()] = true);

		if( this.species )
			out['p_'+this.species.toLowerCase()] = true;

		if( window.game && game.dungeon instanceof Dungeon )
			game.dungeon.getTags().map(t => out[t.toLowerCase()] = true);

		return Object.keys(out);

	}

	// overrides generic class
	hasTagBy( tags, sender ){

		if( !Array.isArray(tags) )
			tags = [tags];

		// Start by checking turn tags
		for( let tt of this._turn_tags ){
			if( sender.id === tt.s.id && ~tags.indexOf(tt.tag) )
				return true;
		}

		
		// Check wrapper tags
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){
			if( wrapper.caster === sender.id && wrapper.hasTag(tags) )
				return true;
		}
		

		// Next check the effects
		const effects = this.getEffects();
		for( let effect of effects ){
			if( effect.parent.caster === sender.id && (effect.hasTag(tags)) )
				return true;
		}

		
		return false;

	}

	getPronoun(pronoun){
		let out = 
			(this.hasTag('pl_penis') ? 1 : 0) |
			(this.hasTag('pl_vagina') ? 2 : 0) |
			(this.hasTag('pl_breasts') ? 4 : 0)
		;
		let pronouns = ['it', 'it', 'its'];
		if( out && out < 3 )
			pronouns = ['he', 'him', 'his'];
		else if( out === 6 )
			pronouns = ['she', 'her', 'her'];
		else if( out )
			pronouns = ['shi', 'hir', 'hir'];
		
		if( pronoun === 'he' )
			return pronouns[0];
		if( pronoun === 'him' )
			return pronouns[1];
		return pronouns[2];

	}

	// Sets tags and strips pl_ prefix
	// Chainable
	setTags( tags ){
		this.tags = [];
		for( let tag of tags ){
			tag = tag.split('_');
			if( tag[0] === 'pl' )
				tag.shift();
			this.tags.push(tag.join('_'));
		}
		return this;
	}


	

	


	/* Events */
	// happens to NPCs the first time they're placed in world from an encounter
	onPlacedInWorld(){

		this.netgame_owner = '';
		if( this.leveled ){
			this.level += game.getHighestLevelPlayer();
			this.leveled = false;
		}

		this.assets = this.assets.map(el => Asset.convertDummy(el, this));
		for( let index of this.inventory ){
			if( this.assets[index] && this.assets[index].equippable() ){
				this.equipAsset(this.assets[index].id);
			}
		}
		this.inventory = [];

		for( let inv of this.assets )
			inv.onPlacedInWorld();

		for( let passive of this.passives ){
			passive.g_resetID();
		}

		this.addHP(Infinity);
		this.addMP(Infinity);
		this.arousal = 0;
		
	}
	onRemoved(){
		this.unbindWrappers();
	}
	onTurnEnd(){

		const wrappers = this.getWrappers();
		for(let wrapper of wrappers)
			wrapper.onTurnEnd();

		for(let action of this.actions)
			action.onTurnEnd();
		if( this._stun_diminishing_returns > 0 )
			--this._stun_diminishing_returns;
		this._damaging_since_last = {};
		this._damage_since_last = {};
		this._targeted_by_since_last = {};
		++this._turns;

	}
	onTurnStart(){

		this._d_damaging_since_last = {};
		this._d_damage_since_last = {};
		

		// Wipe turnTags on start
		this._turn_tags = [];

		if( this.bot )
			this.bot.onTurnStart();

		
		const wrappers = this.getWrappers();
		for(let wrapper of wrappers)
			wrapper.onTurnStart();

		const actions = this.getActions();
		for(let action of actions)
			action.onTurnStart();
		
		if( this.arousal > 0 && this._turns%3 === 0 ){
			let sub = -this.getMaxArousal()/10;	// You lose 10% every 3 turns
			let rem = Math.floor(sub);
			if( Math.random() < sub-rem )
				--rem;
			this.addArousal(rem);
		}

		this._turn_ap_spent = 0;
		let ap = (3+Math.floor((this.getMaxAP()-10)/10))*this.getPoweredMultiplier();
		// Add a chance to gain an extra AP based on 10% per point of AP above 10
		let agility = this.getMaxAP()%10*10;
		if(Math.random()<=(agility%100)/100)
			++ap;
		this.addAP(ap);
		
		// Do the same for MP
		let mp = (1+Math.floor((this.getMaxMP()-10)/10))*this.getPoweredMultiplier();
		let intelligence = this.getMaxMP()%10*10;
		if(Math.random()<=(intelligence%100)/100)
			++mp;
		this.addMP(mp);
		
	}
	onBattleStart(){
		this._used_chats = {};
		this._turn_tags = [];
		this.ap = 0;
		this._threat = {};
		this._stun_diminishing_returns = 0;
		this._damaging_since_last = {};
		this._damage_since_last = {};
		this._last_chat = 0;

		let actions = this.getActions();
		for(let action of actions)
			action.onBattleStart();

	}
	onBattleEnd(){
		this.ap = 0;
		let actions = this.getActions();
		for(let action of actions)
			action.onBattleEnd();
		for( let wrapper of this.wrappers )
			wrapper.unbindEvents();
		this.wrappers = [];
		let wrappers = this.getWrappers();
		for(let wrapper of wrappers)
			wrapper.onBattleEnd();
		this._stun_diminishing_returns = 0;
		this._turns = 0;
		this.used_punish = false;
	}
	// Item broken, repaired, equipped, or removed
	onItemChange(){
		this.addHP(0);
		this.addAP(0);
	}

	onCellChange(){
		this.used_punish = true;
	}

	

	onDamagingAttackReceived( sender, type ){
		if(!this._damaging_since_last[sender.id])
			this._damaging_since_last[sender.id] = {};
		if(!this._damaging_since_last[sender.id][type])
			this._damaging_since_last[sender.id][type] = 0;
		
		++this._damaging_since_last[sender.id][type];
	}
	onDamagingAttackDone(target, type){
		if(!this._d_damaging_since_last[target.id])
			this._d_damaging_since_last[target.id] = {};
		if(!this._d_damaging_since_last[target.id][type])
			this._d_damaging_since_last[target.id][type] = 0;
		
		++this._d_damaging_since_last[target.id][type];
	}
	onDamageTaken( sender, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._damage_since_last[sender.id])
			this._damage_since_last[sender.id] = {};
		if(!this._damage_since_last[sender.id][type])
			this._damage_since_last[sender.id][type] = 0;
		
		this._damage_since_last[sender.id][type] += amount;
	}
	onDamageDone( target, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._d_damage_since_last[target.id])
			this._d_damage_since_last[target.id] = {};
		if(!this._d_damage_since_last[target.id][type])
			this._d_damage_since_last[target.id][type] = 0;
		this._d_damage_since_last[target.id][type] += amount;
	}
	onTargetedActionUsed( target ){
	}
	onTargetedActionReceived( sender ){
		if( !this._targeted_by_since_last[sender.id] )
			this._targeted_by_since_last[sender.id] = 0;
		++this._targeted_by_since_last[sender.id];
	}

	onDeath( attacker, effect ){
		
		// Damage durability
		const assets = this.getAssetsEquipped(false);
		for( let asset of assets )
			asset.damageDurability( attacker, effect, Math.ceil(asset.getMaxDurability()*0.2) );

		if( this.remOnDeath ){
			game.removePlayer(this);
		}

	}

	onIdChanged(){
		this.updatePassives();
		this.getAssetsEquipped().map(el => el.onEquip());
	}



	/* TurnTags */
	addTurnTags( tags, sender ){
		for( let tag of tags ){
			this.removeTurnTag(tag);
			this._turn_tags.push({tag:tag, s:sender});
		}
	}

	// returns a turnTag object if it exists
	getTurnTag( tag ){
		for( let ttObj of this._turn_tags ){
			if( ttObj.tag === tag )
				return ttObj;
		}
		return false;
	}

	removeTurnTag( tag ){
		for( let i in this._turn_tags ){
			if( this._turn_tags[i].tag === tag ){
				this._turn_tags.splice(i,1);
				return;
			}
		}
	}


	/* Assets */
	// if fromStacks is true, it only iterates once and adds amount to stacks instead of asset._stacks
	addAsset( asset, amount = 1, fromStacks = false, no_equip = false, resetid = false ){
		if( !(asset instanceof Asset) ){
			console.error("Trying to add non-asset. Did you mean to use addLibraryAsset?");
			return false;
		}
		asset.equipped = false;

		asset.onPlacedInWorld();
		for( let i = 0; i<amount && (!fromStacks || i<1); ++i ){
			// Needs to be its own object
			const a = asset.clone(this);

			if( resetid )
				a.g_resetID();	// Buying stacks will bork everything otherwise

			const exists = this.getAssetByLabel(a.label);
			let n = a._stacks;
			if( fromStacks )
				n = amount;
			if( a.stacking && exists )
				exists._stacks += n;
			else{
				a._stacks = n;
				this.assets.push(a);
			}
			if( a.category === Asset.Categories.consumable ){
				
				if( this.getEquippedAssetsBySlots(Asset.Slots.action).length < 3 ){
					this.equipAsset(a.id);
				}

			}
			else if( this.isNPC() ){

				if( !no_equip && !game.battle_active && !this.getEquippedAssetsBySlots(a.slots).length && a.equippable() )
					this.equipAsset(a.id);

			}
		}
		this.raiseInvChange();
		return true;
	}
	raiseInvChange(){
		new GameEvent({type:GameEvent.Types.inventoryChanged, sender:this, target:this}).raise();
	}
	addLibraryAsset( label, amount = 1 ){

		let asset = glib.getFull('Asset')[label];
		if( !asset ){
			console.error("Invalid library asset", label);
			return false;
		}
		asset.g_resetID();
		asset.repair();
		asset.resetCharges();
		return this.addAsset(asset, amount);

	}
	getAssetById(id){
		for(let asset of this.assets){
			if(asset.id === id)
				return asset;
		}
		return false;
	}
	// useful for stackable items like currency
	getAssetByLabel( label ){
		for(let asset of this.assets){
			if( asset.label === label )
				return asset;
		}
		return false;
	}
	isAssetEquipped(id){
		let asset = this.getAssetById(id);
		if(!asset)
			return false;
		return asset.equipped;
	}
	getEquippedAssetsBySlots( slots, includeBroken ){
		if( !Array.isArray(slots) )
			slots = [slots];
		let assets = this.getAssetsEquipped(includeBroken);
		let out = [];
		for(let asset of assets){
			for( let slot of slots ){
				if( ~asset.slots.indexOf(slot) ){
					out.push(asset);
					break;
				}
			}
		}
		return out;
	}
	equipAsset( id, byPlayer ){
		let assets = this.getAssetsInventory();
		for(let asset of assets){
			if(asset.id === id){
				if( !asset.equippable() ){
					console.error("Item can not be equipped");
					return false;
				}

				// Special case for action slot
				const isActionAsset = ~asset.slots.indexOf(Asset.Slots.action);
				if( isActionAsset && !this.unequipActionAssetIfFull() )
					return false;
				if( !isActionAsset && !this.unequipAssetsBySlots(asset.slots) )
					return false;

				asset.equipped = true;
				asset.onEquip();
				this.onItemChange();
				if( game.battle_active && byPlayer )
					game.ui.addText( this.getColoredName()+" equips "+asset.name+".", undefined, this.id, this.id, 'statMessage important' );
				this.rebindWrappers();
				return true;
			}
		}
		return false;
	}
	unequipAsset( id, byPlayer ){

		let assets = this.getAssetsEquipped(true);
		for(let asset of assets){
			if(asset.id === id){
				asset.equipped = false;
				this.onItemChange();
				if( game.battle_active && byPlayer )
					game.ui.addText( this.getColoredName()+" unequips "+asset.name+".", undefined, this.id, this.id, 'statMessage important' );
				this.rebindWrappers();
				return asset;
			}
		}
		return true;

	}
	unequipAssetsBySlots( slots ){
		let equipped = this.getEquippedAssetsBySlots(slots, true);
		if(!equipped.length)
			return true;
		for( let e of equipped ){
			if(!this.unequipAsset(e.id))
				return false;
		}
		return true;
	}

	// returns nr of assets of label, including stacks
	numAssets( label ){
		let out = 0;
		for(let asset of this.assets){
			if( asset.label === label ){
				out += asset.stacking ? asset._stacks : 1;
			}
		}
		return out;
	}

	// Returns nr of assets by label, including stacks and charges
	numAssetUses( label, equipped_only = false ){

		let assets = this.assets;
		if( equipped_only )
			assets = this.getAssetsEquipped();
		let out = 0;
		for(let asset of assets){
			if( asset.label === label ){
				let n = asset.stacking ? asset._stacks : 1;
				if( asset.charges > 1 ){
					n = (n-1)*asset.charges+asset._charges;
				}
				else if( asset.charges === -1 )
					return -1;
				out += n;
			}
		}
		return out;
	}

	// Unequips the leftmost one if toolbelt is full
	unequipActionAssetIfFull(){
		let assets = this.getEquippedAssetsBySlots(Asset.Slots.action, true);
		if( assets.length < 3 )
			return true;
		return this.unequipAsset(assets[0].id);
	}

	// Returns equipped assets
	getAssetsEquipped( includeBroken ){
		const out = [], assets = this.getAssets();
		for(let asset of assets){
			if( asset === undefined )
				console.error("Undefined asset in", this);
			if( asset.equipped && (includeBroken || asset.durability > 0) )
				out.push(asset);
		}
		return out;
	}
	destroyAsset(id, amount){
		if( id instanceof Asset )
			id = id.id;
		for(let i in this.assets){
			let asset = this.assets[i];
			if(asset.id === id){
				if( Math.floor(amount) && asset.stacking )
					asset._stacks -= amount;
				if( !amount || !this.assets[i].stacking || asset._stacks <= 0 )
					this.assets.splice(i, 1);
				this.raiseInvChange();
				this.rebindWrappers();
				return true;
			}
		}
		return false;
	}

	destroyAssetsByLabel( label, amount = 1 ){
		for( let asset of this.assets ){
			if( asset.label === label ){			
				let nrToRemove = !asset.stacking ? 1 : asset._stacks;
				if( nrToRemove > amount )
					nrToRemove = amount;
				this.destroyAsset(asset.id, amount);
				amount -= nrToRemove;
				if( amount < 1 )
					return;
			}
		}
	}

	// Transfers an asset to a player. Player is a player object
	transferAsset( id, player ){
		let asset = this.getAssetById(id);
		if( !asset )
			return false;
		this.unequipAsset(id);
		player.addAsset(asset);
		this.destroyAsset(id);
		if( Math.random() < 0.25 && asset.durability )
			player.equipAsset(id);
		return true;
	}

	// Returns a list of assets that have their durability damaged
	getRepairableAssets(){
		return this.assets.filter(asset => {
			return asset.durability < asset.getMaxDurability() && asset.isDamageable();
		});
	}

	getAssets(){
		return this.assets;
	}

	// Returns non-equipped assets
	getAssetsInventory(){
		const out = [], assets = this.getAssets();
		for(let asset of assets){
			if(!asset.equipped)
				out.push(asset);
		}
		return out;
	}
	// Overwrite inventory items with defaults from database
	refetchInventory(){

		let lib = glib.getFull('Asset');
		for(let i in this.assets){

			let asset = this.assets[i];
			if( lib[asset.label] ){
				const stacks = this.assets[i]._stacks,
					equipped = this.assets[i].equipped;
				console.debug("Overwriting ", asset.label);
				this.assets[i] = lib[asset.label].clone(this);
				this.assets[i]._stacks = stacks;
				this.assets[i].equipped = equipped;

			}

		}

	}

	getLootableAssets(){
		return this.assets;
	}

	lootToPlayer( id, player ){

		let asset = this.getAssetById(id);
		if( !asset ){
			console.error("Asset not found", id, "in", this);
			return;
		}
		
		if( game.is_host && asset.loot_sound )
			game.playFxAudioKitById(asset.loot_sound, player, player, undefined, true );
		
		if( !game.is_host ){
			game.net.playerLootPlayer( player, this, asset );
			return;
		}

		asset.equipped = false;		// Make sure it's not equipped
		if( player.addAsset(asset) )
			this.destroyAsset(id);

		game.ui.addText( player.getColoredName()+" looted "+asset.name+" from "+this.getColoredName()+".", undefined, player.id,  player.id, 'statMessage important' );
		game.save();
		game.ui.draw();

	}

	// By default it damages all worn items
	// Returns an array of {armor_damage:{slot:damage}, armor_strips:{slot:true}}
	damageDurability( sender, effect, amount, slots, fText = false ){

		const out = {
			armor_damage : {},
			armor_strips : {}
		};
		let assets = [];
		// Pick a slot at random
		if( slots === 'RANDOM' ){
			let viableAssets = this.getEquippedAssetsBySlots([Asset.Slots.lowerBody, Asset.Slots.upperBody]);
			if( !viableAssets.length )
				return;
			assets = [viableAssets[Math.floor(Math.random()*viableAssets.length)]];
		}
		else{
			if( !Array.isArray(slots) )
				slots = [Asset.Slots.lowerBody, Asset.Slots.upperBody];
			assets = this.getEquippedAssetsBySlots(slots);
		}
		
		amount = Math.round(amount);
		for( let asset of assets ){
			let destroyed = asset.damageDurability( sender, effect, amount, fText );
			for( let slot of asset.slots ){
				out.armor_damage[slot] = amount;
				if( destroyed )
					out.armor_strips[slot] = asset;
			}
		}
		this.rebindWrappers();

		return out;

	}


	// returns between 0 and 1
	getAssetDurabilityPercentageBySlot( slot ){

		let asset = this.getEquippedAssetsBySlots(slot);
		if( !asset.length )
			return 0;
		asset = asset.shift();
		return asset.durability / asset.getMaxDurability();

	}

	// Encumbrance
	getCarryingCapacity(){
		return 35000+this.getPrimaryStats()[Player.primaryStats.stamina]*3000;
	}
	getCarriedWeight(){
		let out = 0;
		for(let asset of this.assets){
			let weight = asset.weight;
			out+= weight;
		}
		return out;
	}
	isEncumbered(){
		return !this.isBeast() && this.getCarriedWeight() > this.getCarryingCapacity();
	}

	// Currency
	// Returns currency value in copper
	getMoney(){
		let out = 0;
		for( let asset of this.assets ){
			if( asset.label === 'platinum' )
				out += asset._stacks*1000;
			else if( asset.label === 'gold' )
				out += asset._stacks*100;
			else if( asset.label === 'silver' )
				out += asset._stacks*10;
			else if( asset.label === 'copper' )
				out += asset._stacks;
		}
		return out;
	}

	consumeMoney( copper = 0 ){

		let total = this.getMoney();
		if( total < copper )
			return false;

		let costRemaining = copper;		// Remaining cost in copper we need to pay
		let consumeCopper = 0,			// Copper assets we need to remove
			consumeSilver = 0,			// Silver assets we need to remove
			consumeGold = 0,			// Gold assets we need to remove
			consumePlatinum = 0			// Plat assets we need to remove
		;
		let copperAsset = this.getAssetByLabel('copper'),
			silverAsset = this.getAssetByLabel('silver'),
			goldAsset = this.getAssetByLabel('gold')
		;
		// First see if we can handle it with just copper
		if( copperAsset && copperAsset._stacks >= copper ){
			consumeCopper = costRemaining;
			costRemaining = 0;
		}else{
			// Start by spending all copper
			if( copperAsset ){
				consumeCopper = copperAsset._stacks;
				costRemaining -= consumeCopper;
			}
			while( costRemaining > 0 ){
				// See if we still have any silver
				if( silverAsset && silverAsset._stacks > consumeSilver ){
					// Split a silver
					++consumeSilver;
					costRemaining -= 10;
				}else if( goldAsset && goldAsset._stacks > consumeGold ){
					// Split a gold
					++consumeGold;
					costRemaining -= 100;
				}
				else{
					// Split a platinum
					++consumePlatinum;
					costRemaining -= 1000;
				}
			}
		}

		const change = this.calculateMoneyExhange(Math.abs(costRemaining));
		consumeCopper -= change[3];
		consumeSilver -= change[2];
		consumeGold -= change[1];
		consumePlatinum -= change[0];

		//console.log("Consume: ", consumeCopper, "copper", consumeSilver, "silver", consumeGold, "gold", consumePlatinum, "plat." "Change in copper", Math.abs(costRemaining));
		
		if( consumeCopper < 0 ){
			const asset = glib.get('copper', 'Asset');
			asset._stacks = Math.abs(consumeCopper);
			this.addAsset(asset);
		}
		else if( consumeCopper > 0 )
			this.destroyAsset(copperAsset.id, consumeCopper);

		if( consumeSilver < 0 ){
			const asset = glib.get('silver', 'Asset');
			asset._stacks = Math.abs(consumeSilver);
			this.addAsset(asset);
		}
		else if( consumeSilver > 0 )
			this.destroyAsset(silverAsset.id, consumeSilver);
		
		if( consumeGold < 0 ){
			const asset = glib.get('gold', 'Asset');
			asset._stacks = Math.abs(consumeGold);
			this.addAsset(asset);
		}
		else if( consumeGold > 0 )
			this.destroyAsset(goldAsset.id, consumeGold);

		if( consumePlatinum < 0 ){
			const asset = glib.get('platinum', 'Asset');
			asset._stacks = Math.abs(consumePlatinum);
			this.addAsset(asset);
		}
		else if( consumePlatinum > 0 ){
			this.destroyAsset(this.getAssetByLabel('platinum').id, consumePlatinum);
		}
		return true;

	}

	// See Player.calculateMoneyExchange
	calculateMoneyExhange( input = 0 ){
		return Player.calculateMoneyExhange(input);
	}

	// Auto exchanges money assets to the fewest amounts of coins
	exchangeMoney(){
		const exchanged = this.calculateMoneyExhange(this.getMoney());
		let asset;
		if( asset = this.getAssetByLabel('platinum') )
			this.destroyAsset(asset);
		if( asset = this.getAssetByLabel('gold') )
			this.destroyAsset(asset);
		if( asset = this.getAssetByLabel('silver') )
			this.destroyAsset(asset);
		if( asset = this.getAssetByLabel('copper') )
			this.destroyAsset(asset);
		
		const labels = ['platinum', 'gold','silver','copper'];
		for( let i in exchanged ){
			const amt = exchanged[i];
			if( amt ){
				const label = labels[i];
				const a = glib.get(label, 'Asset');
				a._stacks = amt;
				this.addAsset(a);
			}
		}
		return true;
		
	}

	// Exchanges a copper amount into plat, gold etc and adds
	addCopperAsMoney( copper = 0 ){
		copper = parseInt(copper);
		if( copper < 1 )
			return;

		const exch = Player.calculateMoneyExhange(copper);
		for( let i in exch ){
			if( !exch[i] )
				continue;
			const asset = glib.get(Player.currencyWeights[i], 'Asset');
			asset._stacks = exch[i];
			this.addAsset(asset);
		}

	}

	canExchange(){
		const labels = Player.currencyWeights;
		for( let asset of this.assets ){
			if( ~labels.indexOf(asset.label) && asset._stacks >= 10 )
				return true;
		}
	}



	/* Leveling & Experience */
	getExperienceUntilNextLevel(){
		if( this.level === 1 )
			return 4;
		
		return Math.ceil(1+this.level*2+Math.pow(this.level,2.5));
	}

	// NPC kills
	getExperienceWorth(){
		return Math.ceil(this._difficulty*this.level/4);
	}

	// adds experience and returns levels gained
	addExperience( points ){
		points = Math.round(points);
		if( isNaN(points) ){
			console.error("Trying to add NaN experience");
			return false;
		}

		this.experience += Math.floor(points);
		if( this.level === Player.MAX_LEVEL )
			this.experience = 0;
		
		let startLevel = this.level;
		while( this.experience >= this.getExperienceUntilNextLevel() ){
			this.experience -= this.getExperienceUntilNextLevel();
			++this.level;
			if( this.level === Player.MAX_LEVEL ){
				this.experience = 0;
				break;
			}
		}
		game.ui.addText( this.getColoredName()+" gained "+points+" experience!", undefined, this.id, this.id, 'important statMessage' );

		

		let levelsGained = this.level-startLevel;
		if( levelsGained ){
			this.addActionsForClass();
			game.onPlayerLevelup(this, levelsGained);
		}

		if( !this.actionSlotsFull() ){
			const n = this.getNrFreeActionSlots();
			game.ui.addText( this.getColoredName()+" has "+n+" free action slot"+(n === 1 ? '' : 's')+"! Visit a gym to learn new actions!", undefined, this.id, this.id, 'important statMessage' );
		}

		return levelsGained;
	}







	/* RESOURCES */
	addAP( amount, fText = false ){
		if( this.isAPDisabled() )
			return false;
		if( isNaN(amount) ){
			console.error("AP amount is NaN", amount);
			return false;
		}
		const pre = this.ap;
		this.ap += amount;
		this.ap = Math.floor(Math.max(0, Math.min(this.getMaxAP(), this.ap)));
		if( fText && this.ap-pre !== 0 )
			game.ui.floatingCombatText(this.ap-pre, this, "ap");
		
	}

	addMP( amount, fText = false ){
		if( this.isMPDisabled() )
			return false;
		if( isNaN(amount) ){
			console.error("MP amount is NaN", amount);
			return false;
		}
		const pre = this.mp;
		this.mp += amount;
		this.mp = Math.floor( Math.max(0, Math.min(this.getMaxMP(), this.mp)) );

		if( fText && this.mp-pre !== 0 )
			game.ui.floatingCombatText(this.mp-pre, this, "mp");

	}

	addThreat( playerID, amount ){
		if( typeof playerID !== "string" ){
			console.error("Can't add non-string player threat, received:", playerID);
			return;
		}
		if( !this._threat.hasOwnProperty(playerID) )
			this._threat[playerID] = 0;
		this._threat[playerID] += amount;		
	}

	// min amount of 1
	getPlayerThreat( player ){
		let thr = 1;
		if( this._threat[player.id] > 0 )
			thr = this._threat[player.id];
		return thr;
	}

	// Returns true if the player died
	addHP( amount, sender, effect, fText = false ){

		if( this.isHPDisabled() )
			return false;

		if( isNaN(amount) ){
			console.error("HP amount is NaN", amount);
			return false;
		}
		const pre = this.hp;
		let wasDead = this.hasTag(stdTag.dead);
		this.hp += amount;
		this.hp = Math.floor( Math.max(0, Math.min(this.getMaxHP(), this.hp)) );

		if( fText && this.hp-pre !== 0 )
			game.ui.floatingCombatText(this.hp-pre, this, "hp");

		if( this.hp === 0 && !wasDead ){
			this.onDeath( sender, effect );
			if( this.hp === 0 )
				return true;
		}

		return false;

	}

	addArousal( amount, fText = false ){

		if( this.isArousalDisabled() )
			return false;
		if( this.isOrgasming() )
			return;
		if( isNaN(amount) )
			return console.error("Invalid amount of arousal", amount);
			
		const pre = this.arousal, max = this.getMaxArousal();
		this.arousal += amount;
		this.arousal = Math.floor( Math.min(max, Math.max(0, this.arousal)) );

		if( this.arousal >= max && pre < max ){

			glib.get("overWhelmingOrgasm", "Wrapper").useAgainst(this, this, false);
			game.save();
			game.ui.draw();

		}

		if( fText && this.arousal-pre !== 0 )
			game.ui.floatingCombatText(this.arousal-pre, this, "arousal");

	}


	fullRegen(){
		this.hp = this.getMaxHP();
	}

	getMaxHP(){

		const calculateHP = stamina => {
			return Math.max((BASE_HP+stamina*Player.STAMINA_MULTI)*this.getPoweredMultiplier(), 1);
		}

		const stamina = this.statPointsToNumber(Player.primaryStats.stamina);
		let c_stamina = this._cache_stamina;
		this._cache_stamina = stamina;

		let out = calculateHP(stamina);

		// Stamina has changed, recalculate HP based on percentage
		if( window.game && game.is_host && c_stamina !== false && c_stamina !== stamina ){

			const was_perc = this.hp / calculateHP(c_stamina);
			this.hp = Math.floor(out*was_perc);

		}

		return out;

	}
	getMaxAP(){
		return Math.round(Math.max((BASE_AP+this.statPointsToNumber(Player.primaryStats.agility))+(this.getPoweredMultiplier()*2-2), 1));
	}
	getMaxMP(){
		return Math.max((BASE_MP+this.statPointsToNumber(Player.primaryStats.intellect)), 1);
	}
	getMaxArousal(){
		return BASE_AROUSAL;
	}


	


	/* STATS */
	getPrimaryStats(){

		if( !this.class )
			this.class = new PlayerClass();

		return {
			stamina : Math.floor(
				(this.getGenericAmountStatPoints(Effect.Types.staminaModifier)+this.stamina+this.class[Player.primaryStats.stamina])*
				this.getGenericAmountStatMultiplier(Effect.Types.staminaModifier)),
			agility : Math.floor(
				(this.getGenericAmountStatPoints(Effect.Types.agilityModifier)+this.agility)+this.class[Player.primaryStats.agility]*
				this.getGenericAmountStatMultiplier(Effect.Types.agilityModifier)),
			intellect : Math.floor(
				(this.getGenericAmountStatPoints(Effect.Types.intellectModifier)+this.intellect)+this.class[Player.primaryStats.intellect]*
				this.getGenericAmountStatMultiplier(Effect.Types.intellectModifier)),
		};
	}

	// Takes a Player.primaryStats value and converts it to a number to add to HP/MP etc for this character
	statPointsToNumber( stat ){
		return this.getPrimaryStats()[stat];
	}

	getPoweredMultiplier(){
		if( this.powered ){
			return game.dungeon.getDifficulty();
		}
		return 1;
	}

	// Effect in these methods are only included to prevent recursion
	// SV Types
	getSV( type ){

		let grappled = 0;
		if( type === Action.Types.physical )
			grappled = this.getGrappledBy().length ? -4 : 0;

		return Math.floor(
			(
				this.getGenericAmountStatPoints('sv'+type)+
				this.level+
				this.class['sv'+type]+
				(!isNaN(this['sv'+type]) ? this['sv'+type] : 0)+
				grappled
			)*this.getGenericAmountStatMultiplier('sv'+type)
		);
	}

	// SV Bon types
	getBon( type ){

		let grappled = 0;
		if( type === Action.Types.physical )
			grappled = this.getGrappledBy().length ? -4 : 0;

		return Math.floor(
			(
				this.getGenericAmountStatPoints('bon'+type)+
				this.level+
				this.class['bon'+type]+
				(!isNaN(this['bon'+type]) ? this['bon'+type] : 0)+
				grappled
			)*this.getGenericAmountStatMultiplier('bon'+type)
		);

	}

	// Returns the sum of effect.data.amount of an effect with type, and that aren't multiplicative
	getGenericAmountStatPoints( type, player ){

		let w = this.getActiveEffectsByType(type),
			out = 0
		;
		for(let effect of w){
			if( effect.data.multiplier )
				continue;

			if( player && effect.data.casterOnly && player.id !== effect.parent.caster )
				continue;

			let n = Math.round(Calculator.run(
				effect.data.amount, 
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			));
			out+= n*(effect.no_stack_multi ? 1 : effect.parent.stacks);
		}
		return out;
		
	}

	getGenericAmountStatMultiplier( type, player ){
		let w = this.getActiveEffectsByType(type),
			out = 1
		;
		
		for( let effect of w ){
			if( !effect.data.multiplier )
				continue;
			if( player && effect.data.casterOnly && player.id !== effect.parent.caster )
				continue;
			let n = Calculator.run(
				effect.data.amount, 
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out *= Math.pow(n, (effect.no_stack_multi ? 1 : effect.parent.stacks));
		}
		return out;
	}

	// Returns a multiplier against damage based on slots missing
	getNudityDamageMultiplier(){

		// Beasts are never nude
		if( this.isBeast() )
			return 1;

		let out = 1;
		let slots = [Asset.Slots.lowerBody, Asset.Slots.upperBody];
		for( let slot of slots ){
			let gear = this.getEquippedAssetsBySlots(slot);
			if( !gear.length )
				out += Asset.protVal;
			else
				out += gear[0].getDmgTakenAdd();
		}
		return out;

	}
	
	// Takes an attack type and returns a proc chance multiplier
	getStatProcMultiplier( stat, recipient = false){

		let out = 1;
		recipient = Boolean(recipient);
		const effects = this.getActiveEffectsByType(stat.toLowerCase()+'ProcMultiplier');
		for( let effect of effects ){
			if( typeof effect.data.receive === "boolean" && effect.data.receive !== recipient )
				continue;
			const n = Calculator.run(
				effect.data.amount,
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out *= (n*(effect.no_stack_multi ? 1 : effect.parent.stacks));
		};
		return out;

	}

	getHealAggroMultiplier( recipient = false){

		let out = 1;
		const effects = this.getActiveEffectsByType(Effect.Types.healAggroMultiplier);
		for( let effect of effects ){
			if( typeof effect.data.receive === "boolean" && effect.data.receive !== recipient )
				continue;
			const n = Calculator.run(
				effect.data.amount,
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out *= (n*(effect.no_stack_multi ? 1 : effect.parent.stacks));
		};
		return out;

	}




	/* Actions */
	addDefaultActions(){

		// Don't add default actions in the editor
		if( !window.game )
			return;

		let lib = Object.values(glib.getFull('Action')).filter(el => el.std);
		for( let action of lib ){

			if(!this.getActionByLabel(action.label))
				this.actions.unshift(action.clone(this));

		}

	}
	addActionFromLibrary( label ){

		let asset = glib.getFull('Action')[label];
		if( !asset ){
			console.error("Invalid library asset", label);
			return false;
		}
		return this.addAction(asset);

	}

	addAction( action, silent = false ){

		if( !action ){
			console.error("Invalid action add", action);
			return false;
		}
		if( this.getLearnedActionByLabel(action.label) ){
			console.error("Action already learned");
			return false;
		}
		let ac = action.clone(this);
		this.actions.push(ac);
		if( !ac.hidden && !silent )
			game.ui.addText( this.getColoredName()+" learned "+ac.name+"!", undefined, this.id, this.id, 'actionLearned' );
		
		if( !this.actionSlotsFull() && !action.std ){
			for( let i in this.active_actions ){
				
				const slot = this.active_actions[i];
				if( slot === 0 ){
					this.activateAction(action.id, i);
					break;
				}

			}
		}
		return true;
	}

	getNrFreeActionSlots(){

		const total = this.getNrActionSlots();
		let n = 0;
		for( let i=0; i<this.active_actions.length; ++i ){
			if( this.active_actions[i] ){
				++n
			}
		}
		return total-n;

	}

	actionSlotsFull(){
		return this.getNrFreeActionSlots() <= 0;
	}

	activateAction( id, slot ){
		
		if( id instanceof Action )
			id = id.id;

		if( this.actionSlotsFull() )
			throw "Action slots are full. Disable one first.";

		slot = parseInt(slot);
		if( isNaN(slot) ){

			for( let i=0; i<this.getNrActionSlots(); ++i ){
				if( !this.active_actions[i] ){
					slot = i;
					break;
				}
			}

		}


		this.deactivateAction(id);
		const action = this.getLearnedAction(id);
		if( !action )
			throw "Trying to activate nonfound action";
		
		if( slot > this.active_actions.length-1 || slot < 0 || isNaN(slot) )
			throw "Out of bounds error on action activation";

		this.active_actions[slot] = id;
		return true;

	}

	deactivateAction( id ){

		for( let i in this.active_actions ){

			if( this.active_actions[i] === id ){
				
				this.active_actions[i] = 0;
				return true;

			}

		}

	}

	toggleAction( id ){
		
		if( !this.getLearnedAction(id) )
			throw 'Action not found: '+id;
		if( this.isActionActive(id) )
			this.deactivateAction(id);
		else
			this.activateAction(id);

		return true;

	}

	getActiveActionByIndex( index ){

		if( this.active_actions[index] )
			return this.getLearnedAction(this.active_actions[index]);

	}

	

	// Gets an action from the action array by id, regardless of if it's active or not
	getLearnedAction( id ){
		for( let action of this.actions ){
			if( action === id || action.id === id )
				return action;
		}
		return false;
	}

	// Same as above but checks label
	getLearnedActionByLabel( label ){
		for( let action of this.actions ){
			if( action.label === label )
				return action;
		}
	}

	

	isActionActive( id ){

		return ~this.active_actions.indexOf(id);

	}

	getInactiveActions(){

		const out = [];
		for( let action of this.actions ){
			if( !action.std && !this.isActionActive(action.id) )
				out.push(action);
		}
		return out;

	}


	// Checks effects whether an action is enabled
	isActionEnabled( action ){
		
		const a = action;
		if( typeof action === "string" ){
			action = this.getActionByLabel(a);
			if( !action )
				action = this.getActionById(a);
		}
		if( !action ){
			console.error("Action not found", a);
			return false;
		}
		return true;

	}

	// Returns disable EFFECTs that cause the supplied action not to be enabled to this player
	getDisableActionEffects(){
		return this.getActiveEffectsByType(Effect.Types.disableActions);
	}

	removeActionById( id ){
		for( let i in this.actions ){
			let action = this.actions[i];
			if( action.id === id ){
				this.actions.splice(i, 1);
				return true;
			}
		}
		return false;
	}

	// Tries to update actions from database, you should not do this if you've modified actions via the console or spell editor
	refetchActions( std_only = false ){

		let lib = glib.getFull('Action');

		const add = [];
		const actions = this.actions.slice();
		for(let i in actions ){

			const action = actions[i];
			if( !action.std && std_only )
				continue;
			
			if( lib[action.label] ){

				console.debug("Rebasing action", action.label, "with", lib[action.label]);
				this.removeActionById(action.id);
				add.push(lib[action.label]);
				//this.actions[i] = lib[action.label].clone(this);

			}

		}

		for( let a of add ){
			this.addAction(a, true);
		}


	}

	getActionByLabel(label){

		let actions = this.getActions();
		for( let action of actions ){

			if(action.label === label)
				return action;

		}
		return false;

	}

	getActions( include_items = true, include_non_learned = false, include_temp = true ){
		
		let out = this.actions.slice();
		
		if( include_items ){

			for( let asset of this.assets ){
				let action = asset.use_action;
				if( asset.isConsumable() && (asset.equipped || !game.battle_active) )
					out.push(action);
			}

		}
		
		if( !this.auto_learn && !include_non_learned ){

			out = out.filter(el => {

				if( 
					Boolean(el.parent.use_action) ||		// It's an item
					el.std ||								// It's a standard action
					~this.active_actions.indexOf(el.id)		// It's an active action
				)return true;

				return false;

			});

		}

		// Temp actions shouldn't be filtered
		if( include_temp )
			out = out.concat(this.getTempActions());

		out.sort((a,b) => {

			const aConsumable = Boolean(a.parent.use_action);
			const bConsumable = Boolean(b.parent.use_action);
			const aName = aConsumable ? a.parent.name : a.name;
			const bName = bConsumable ? b.parent.name : b.name;
			
			// nonconsumable first
			if( aConsumable !== bConsumable )
				return bConsumable ? -1 : 1;

			const acd = a.getCooldown(), bcd = b.getCooldown();
			// Lower cooldown second
			if( acd !== bcd )
				return acd < bcd ? -1 : 1;
			// Finally name
			return aName < bName ? -1 : 1;

		});
		
		return out;

	}

	getTempActions(){
		
		const ids = {};
		const scanned = {};
		for( let a of this.tmp_actions )
			ids[a.label] = true;

		const effects = this.getActiveEffectsByType(Effect.Types.addActions);
		for( let effect of effects ){
			const actions = Action.loadThese(effect.data.actions, this);
			for( let action of actions ){
				scanned[action.label] = true;
				if( !ids[action.label] ){
					ids[action.label] = true;
					action.g_resetID();
					this.tmp_actions.push(action);
				}
			}
		}
		// Remove missing ones
		for( let i =0; i<this.tmp_actions.length && this.tmp_actions.length; ++i ){
			const action = this.tmp_actions[i];
			if( !scanned[action.label] ){
				this.tmp_actions.splice(i, 1);
				--i;
			}
		}

		return this.tmp_actions;

	}

	getActionById( id ){

		let actions = this.getActions();
		for( let action of actions ){

			if( action.id === id )
				return action;

		}
		return false;

	}

	useActionId( id, targets, netPlayer ){

		let action = this.getActionById(id);
		if( action ){
			const out = action.useOn(targets, false, netPlayer);
			return out;
		}
		console.error("Action missing", id, "in", this);
		return false;

	}

	useActionLabel( label, targets ){
		
		let action = this.getActionByLabel(label);
		if( action )
			return action.useOn(targets);
		return false;
		
	}

	// Adds auto unlock actions for your class
	addActionsForClass(){
		
		let lib = Object.values(glib.getFull("ActionLearnable"));
		for( let a of lib ){

			if( !a.auto_learn || this.getActionByLabel(a.action) || !a.validate(this) )
				continue;

			const action = a.getAction();
			if( !action )
				continue;
			this.addAction(action);
		

		}


	}

	// Returns ActionLearnable objects that can be unlocked by this player
	getUnlockableActions(){

		let out = [];
		let lib = Object.values(glib.getFull("ActionLearnable"));
		const evt = new GameEvent({sender:this, target:this});
		for( let a of lib ){
			if( a.auto_learn || this.getLearnedActionByLabel(a.action) )
				continue;
			if( Condition.all(a.conditions, evt) )
				out.push(a);
		}

		return out;

	}
	
	getNrActionSlots(){
		if( this.level < 3 )
			return this.level;
		return Math.min(6, Math.floor((this.level-4)/3)+4);
	}

	getNrPassiveSlots(){
		if( this.level < 5 )
			return 0;
		if( this.level >= 10 )
			return 4;
		return Math.min(4, Math.ceil((this.level-2)/3));
	}

	// Checks encumberance
	updateAutoWrappers(){

		this.auto_wrappers = [];
		if( this.isEncumbered() )
			this.auto_wrappers.push(new Wrapper({
				label : '_encumbered_',
				name : 'Encumbered',
				icon : 'encumbered.svg',
				description : 'You are carrying too much. All hit chance reduced by 50%',
				duration : -1,
				victim : this.id,
				caster : this.id,
				tags : [stdTag.wrEncumbered],
				effects : [
					new Effect({
						type : Effect.Types.globalHitChanceMod,
						data : {amount : -0.5}
					})
				]
			}, this));

	}

	// Activates cooldowns by labels
	consumeActionCharges( labels, charges = 1 ){
		if( !Array.isArray(labels) )
			labels = [labels];

		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action ){
				action.consumeCharges(charges);
			}
		}
	}

	// Adds action charges by labels
	addActionCharges( labels, charges = 1 ){
		if( !Array.isArray(labels) )
			labels = [labels];
		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action )
				action.consumeCharges(-charges);
		}
	}

	// Adds action cooldowns by labels
	addActionCooldowns( labels, amount ){
		if( !Array.isArray(labels) )
			labels = [labels];
		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action )
				action.addCooldown(amount);
		}
	}

	// returns an array of charged actions or false if none 
	isCasting(){
		let actions = this.getActions();
		let spells = [];
		for( let action of actions ){
			if( action._cast_time > 0 )
				spells.push(action);
		}
		if( spells.length )
			return spells;
		return false;
	}

	// Returns nr actions interrupted successfully
	interrupt( sender ){
		let actions = this.isCasting();
		if( !actions )
			return 0;
		let out = 0;
		for( let action of actions ){
			if( action.interrupt(sender) )
				++out;
		}
		return out;
	}

	// Checks the allowReceiveSpells effect
	checkActionFilter( sender, action ){
		if( !(action instanceof Action) ){
			console.error("Action", action, "is not an action");
			return false;
		}
		const effects = this.getActiveEffectsByType(Effect.Types.allowReceiveSpells);
		const evt = new GameEvent({action:action, sender:sender, target:this});
		for( let effect of effects ){
			evt.effect = effect;
			if( !Condition.all(effect.data.conditions, evt) )
				return false;
		}
		return true;
	}


	/* Wrappers */
	getWrappers(){

		if( !window.game )
			return [];

		let out = this.wrappers.concat(this.passives, game.encounter.passives.map(el => { 
			/*
			el = el.clone();
			el.caster = '';
			el.victim = this.id;
			*/
			el.victim = this.id;
			return el;

		}));
		for( let asset of this.assets ){
			if( asset.equipped && asset.durability > 0 )
				out = out.concat(asset.wrappers);
		}


		return out.concat(this.auto_wrappers);

	}

	getActiveEffectsByType( type ){
		
		return this.getEffects().filter(fx => {
			return (fx.type === type && (!this._ignore_effects || this._ignore_effects.indexOf(fx) === -1));
		});

	}

	removeWrapper(wrapper){
		for(let i in this.wrappers){
			if( this.wrappers[i] === wrapper ){
				this.wrappers.splice(i, 1);
				return true;
			}
		}
		return false;
	}

	addWrapper( wrapper ){

		wrapper.parent = this;
		this.wrappers.push(wrapper);
		let isStun = wrapper.getEffects({ type:Effect.Types.stun });
		if( isStun.length && wrapper.duration > 0 && (!isStun[0].data || !isStun[0].data.ignoreDiminishing) ){
			this._stun_diminishing_returns += wrapper._duration*2;

		}
		
		if( isStun.length )
			this.interrupt( wrapper.getCaster(), true );

	}

	getActiveWrappersWithTag(...tags){
		return this.getWrappers().filter(wrapper => {
			return wrapper.hasTag(tags);
		});
	}

	// overWhelmingOrgasm triggered from max arousal
	isOrgasming(){
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){
			if( wrapper.label === "overWhelmingOrgasm" ){
				return true;
			}
		}
	}

	// Makes sure passives have the right ID
	updatePassives(){
		for( let passive of this.passives )
			passive.caster = passive.victim = this.id;
	}

	
	/* Effects */
	// Gets all effects (effects on other players may affect you if the target is you or AoE)
	getEffects(){

		if( !window.game )
			return [];

		let out = new Map();
		for( let player of game.getEnabledPlayers() ){
			const wrappers = player.getWrappers();
			for( let wrapper of wrappers ){
				const effects = wrapper.getEffectsForPlayer(this);
				for( let effect of effects )
					out.set(effect, true);
			}
		}
		return Array.from(out.keys());

	}	
	getDisabledLevel(){
		let level = 0;
		const effects = this.getActiveEffectsByType(Effect.Types.disable);
		for( let effect of effects ){
			let lv = effect.level;
			if( isNaN(lv) )
				lv = 1;
			if( lv > level )
				level = lv;
		}
		return level;
	}
	// Returns true if any of the disabled effects triggers it
	getDisabledHidden(){
		const effects = this.getActiveEffectsByType(Effect.Types.disable);
		for( let effect of effects ){
			if( effect.data.hide )
				return true;
		}
	}

	isHealInverted(){
		return this.getActiveEffectsByType(Effect.Types.healInversion).length;
	}

	isInterruptProtected(){
		return this.getActiveEffectsByType(Effect.Types.blockInterrupt).length;
	}



	/* CHATS */
	onChatUsed( id ){
		this._used_chats[id] = true;
		this._last_chat = this._turns;
	}

	hasUsedChat( id ){
		return this._used_chats[id];
	}
	// Checks if this NPC has chatted too recently
	canOptionalChat(){
		
		if( this.talkative >= 1 )
			return true;
		let turnsSinceLastSpoke = this._turns-this._last_chat;
		return Math.random() < turnsSinceLastSpoke*this.talkative;

	}


	// Bot
	autoPlay( force ){

		if( !this.isNPC() && !force )
			return;
		if( !this.bot ){
			this.bot = new Bot(this);
		}
		
		this.bot.play( force );

	}

	usePunishment( players, force ){
		if( !this.isNPC() && !force )
			return;
		if( !this.bot )
			this.bot = new Bot(this);
		this.bot.punish(players);
	}
	

}

Player.MAX_LEVEL = 14;
Player.STAMINA_MULTI = 4;

Player.TEAM_PLAYER = 0;
Player.TEAM_ENEMY = 1;

Player.primaryStats = {
	intellect : 'intellect',
	stamina : 'stamina',
	agility : 'agility'
};

Player.primaryStatsNames = {
	[Player.primaryStats.intellect] : 'magic',
	[Player.primaryStats.stamina] : 'stamina',
	[Player.primaryStats.agility] : 'agility',
};



// Returns a value where <= 0 = always miss, and >= 100 = always hit
Player.getHitChance = function( attacker, victim, action ){

	if( attacker.id === victim.id )
		return 100;
	if( !action.detrimental )
		return 100;
	if( action.hit_chance > 100 )
		return 100;

	let out = action.hit_chance;
	let modifier = 1
		+((attacker.getBon(action.type)-victim.getSV(action.type))*0.05)
		*attacker.getGenericAmountStatMultiplier(Effect.Types.globalHitChanceMod);
	if( modifier < 0.1 )
		modifier = 0.1;

	// Hit chance above 100 is set as "always hit"
	return Math.max(10, Math.round(out*modifier+attacker.getGenericAmountStatPoints(Effect.Types.globalHitChanceMod)));

};


Player.getAdvantage = function( attacker, victim, stat, detrimental ){

	let tot = attacker.getBon(stat);
	if( detrimental )
		tot -= victim.getSV(stat);
	return tot;

};

// Returns a multiplier of 4% if you go over 100% hit chance
Player.getBonusDamageMultiplier = function( attacker, victim, stat, detrimental ){

	let tot = this.getAdvantage(attacker, victim, stat, detrimental);
	if( tot < 0 )
		tot = 0;

	// Add 25% bonus damage per additional player
	let add = 1;
	if( attacker.team !== 0 ){
		const tp = game.getTeamPlayers().filter(pl => !pl.isNPC());
		add = 1+(tp.length-1)*0.25;
		// level 1 has -50%, level 2 has -25%
		if( attacker.level < 3 )
			add -= 0.25*(3-attacker.level);
	}
	const out = (1+tot*0.1)*add;
	return out;

};


// Exchanges copper into the fewest coins possible
// returns an array of [platinum, gold, silver, copper] after exchange. You can use Player.currencyWeights to map this to assets
Player.calculateMoneyExhange = function( input = 0 ){
	return [
		Math.floor(input/1000),
		Math.floor((input%1000)/100),
		Math.floor((input%100)/10),
		input%10
	];
};

Player.copperToReadable = function( copper = 0 ){
	const coins = this.calculateMoneyExhange(copper);
	let out = [];
	for( let i in coins ){
		if( coins[i] )
			out.push(coins[i]+' '+Player.currencyWeights[i]);
	}
	if( !out.length )
		return '0 copper';
	return out.join(', ');
};
Player.currencyWeights = [
	'platinum',
	'gold',
	'silver',
	'copper'
];
Player.currencyColors = [
	'#FFF',
	'#FF8',
	'#AAA',
	'#FA8'
];


