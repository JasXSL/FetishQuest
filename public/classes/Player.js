import Generic from './helpers/Generic.js';
import Action from "./Action.js";
import Asset from "./Asset.js";
import stdTag from "../libraries/stdTag.js";

import { Wrapper, Effect } from './EffectSys.js';
import Bot from './Bot.js';
import PlayerClass from './PlayerClass.js';
import Calculator from './Calculator.js';
import GameEvent from './GameEvent.js';
import Dungeon from './Dungeon.js';
import Condition from './Condition.js';
import Collection from './helpers/Collection.js';
import Encounter from './Encounter.js';
import Game from './Game.js';

const BASE_HP = 30;
const BASE_MP = 10;
const BASE_AP = 10;
const BASE_AROUSAL = 7;
const MAX_KINKS = 2;


export default class Player extends Generic{

	static getRelations(){ 
		return {
			actions : Action,
			assets : Asset,
			wrappers : Wrapper,
			passives : Wrapper,
			class : PlayerClass,
		};
	}

	constructor(data){

		super(data);

		this.label = '';					// Unique editor label
		this.netgame_owner_name = '';		// This is a custom thing that should only be relied on when adding a new player
		this.netgame_owner = '';			// ID corresponding to one from Game.net.players
		this.afk = false;					// Treats this as a bot if true. Can be toggled by the netgame owner
		this.name = "Adventurer";			// Name
		this.species = "";
		this.spre = "";						// A/AN for species
		this.description = "";
		this.icon = "";						// URL - Has to be HTTPS
		this.icon_upperBody = "";			// == || ==
		this.icon_lowerBody = "";			// == || ==
		this.icon_nude = "";				// == || ==
		this.auto_learn = true;			// if true, this player always knows all their spells
		this.leader = false;				// Party leader
		this.generated = false;				// This was generated by an encounter, and should be purged when leaving the cell

		this.actions = [];			// Unlocked actions. Action objects, use getActions since assets can also add actions
		this.assets = [];			// Asset objects, use getAssets
		this.inventory = [];		// NPC only. This is an array of numbers specifying which items above are equipped when entering the game.

		this.tags = [];				// Player tags, these are automatically prefixed with PL_, use getTags
		this.wrappers = [];			// Wrappers, use getWrappers
		this.auto_wrappers = [];	// Automatic wrappers such as encumbered
		this.passives = [];			// Passive wrappers that should not be cleared when a battle starts or ends
		this.hp = BASE_HP;				// 
		this.ap = 0;				// Action points, stacking up to 10 max, 3 awarded each turn
		this.pMP = 0;				// Pending MP that will be added at the start of your turn.
		this.pAP = 0;				// Pending AP that will be added at the start of your turn. Can be negative and locks those slots in regen.
		this.team = 0;				// 0 = player
		this.size = 5;				// 0-10
		this.level = 1;				// 
		this.experience = 0;
		this.mp = 10;				// Secondary stat used for spells. Mana points.
		this.arousal = 0;
		this.armor = 0;				// 0-100. Given primarily to NPCs that can't wear armor.
		this.leveled = false;		// Level is an offset of the player average level
		this.power = 1;				// This is used in NPCs when calculating how difficult they should be. 1 = power of 1 player, can be higher or lower. -1 will automatically set it to nr players
		this.hpMulti = 1;			// Quick way to build NPCs with different HP instead of having to add a bunch of wrappers.
		this.disabled = false;		// Disable a player, ignoring drawing it and ignoring it in game methods

		// Use getBlock(type)
		this.blPhysical = 0;		// Blocking points of physical damage this turn
		this.blCorruption = 0;		// Blocking points of corruption damage this turn
		this.blArcane = 0;			// Blocking points of arcane this turn
		this.iblPhysical = 0;		// Block applied while it wasn't my turn
		this.iblCorruption = 0;		
		this.iblArcane = 0;			
		this._untappedBlock = 0;		// Set on turn start and contains the value of any block wasted. Not saved.

		this.svPhysical = 0;
		this.svArcane = 0;
		this.svCorruption = 0;

		this.bonPhysical = 0;
		this.bonArcane = 0;
		this.bonCorruption = 0;
		this.bot = new Bot(this);
		this.used_punish = false;				// We have punished a target since the last battle ended or we left the room

		this.remOnDeath = false;				// Delete this player if it dies

		// Personality types
		this.talkative = 0.3;					// How often they output combat chats. Multiplied by nr turns. So after 1 turn, 0.5 = 50% chance, 2 turns = 100% etc. Setting this to one overrides the limit of one chat per turn.
		this.sadistic = 0.5;					// Normal vs Sadistic.
		this.dominant = 0.8;					// Dominant vs submissive
		this.hetero = 0.5;						// 0 = gay, 0.5 = bi, 1 = straight
		this.intelligence = 0.6;				// 0 = No intelligence, .1 = Mollusk, .2 = Animal, .4 = Child, .6 = Average human, .9 = Mastermind, 1 = Godlike
												/* Notes on intelligence:
													<= 0 = It has no intelligence and always attacks a random player, even friendly players
													< 0.2 = No longer attacks friends, but doesn't use the aggro system.
													>= 0.2 = Now able to use the aggro system, but only short term, wiping aggro at the end of their turn
													>= 0.4 = Can speak, now affected by the full aggro system
													>= 0.6 + Judging = Able to set traps, triggering at the start of a battle
													>= 0.8 = Now too smart for aggro, always picks targets carefully
												*/
		// Pronouns
		this.he = '';
		this.him = '';
		this.his = '';


		this.actionGroups = [];					// Contains PlayerActionGroup objects. Built on the fly
		
		
		this.class = null;
		this._stun_diminishing_returns = 0;		// Rounds you can't be stunned

		this._turns = 0;						// Total turns played in combat
		this._turn_ap_spent = 0;				// AP spent on actions this turn
		this._turn_action_used = 0;				// Actions used this turn
		this._threat = {};						// playerID : threatAmount

		// These are incoming damage
		this._damaging_since_last = {};			// playerID : {(str)dmageType:(int)nrDamagingAttacks} - nr damaging actions received since last turn. Not the actual damage.
		this._damage_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total damage points player received since last turn.
		// Same as above, but DONE by this player
		this._d_damaging_since_last = {};			// playerID : {(str)dmageType:(int)nrDamagingAttacks} - nr damaging actions received since last turn. Not the actual damage.
		this._d_damage_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total damage points player received since last turn.
		this._riposted_since_last = {};			// playerID : num_times_this_player_riposted_use
		this._riposting_since_last = {};		// playerID : num_times_we_riposted_them
		// If an object should be netcoded, it needs to be a collection, otherwise it's passed by reference
		this._targeted_by_since_last = new Collection();			// playerID : (int)num_actions - Total actions directly targeted at you since last turn. (AoE doesn't count)
		this._used_chats = {};					// id : true - Chats used. Not saved or sent to netgame. Only exists in the local session to prevent NPCs from repeating themselves.
		this._last_chat = 0;					// Turn we last spoke on. 

		this._turn_tags = [];					// {tag:(str)tag, s:(Player)sender}... These are wiped whenever an action text is used
		
		this.color = '';						// Assigned by the game

		// Prevents recursion for encumbrance
		this._ignore_effects = null;			// Internal helper that prevents recursion
		this._difficulty = 1;					// Added from monster template, used in determining exp rewards
		this._bound_wrappers = [];
		this._cache_tags = null;					// Holds all active tags in a cache for quicker validation
		this._cache_effects = null;					// Holds all active effects in a cache for quicker validation
		this._cache_wrappers = null;				// == || ==

		this._ignore_check_effect = new Map();	// effect : true - Another recursion preventor
		this._tmp_actions = [];					// Actions from effects and such bound to a battle
		
		this._debug_chat = false;				// Only stored in the session, can be used to test player chat while they're controlled by a player. Since PC controlled characters can't auto speak.

		this.load(data);
		
	}

	load(data){

		if( data && data.class === null )
			data.class = '';

		/*
		Not sure if this will break something
		if( window.game && game.is_host && data )
			delete data._tmp_actions;
		*/
		this.g_autoload(data);

	}

	// Automatically invoked after g_autoload
	rebase(){
		this.g_rebase();	// Super

		this._ignore_check_effect = new Map();	// Needed when cloning since clone brings all things along
		// only load tmp actions in a netgame (for ID mostly)
		//if( game && game !== true && !game.is_host && Game.net.isConnected() )
			this._tmp_actions = Action.loadThese(this._tmp_actions, this);
		
		this._targeted_by_since_last = new Collection(this._targeted_by_since_last);
		this.actionGroups = PlayerActionGroup.loadThese(this.actionGroups);

		if( window.game ){
			
			this.updatePassives();
			if( !game.is_host )
				this.auto_wrappers = Wrapper.loadThese(this.auto_wrappers, this);

		}
		
		if( this.class === null )
			this.class = new PlayerClass({}, this);
		

		this.tags = this.tags.map(tag => tag.toLowerCase());


	}

	// Data that should be saved to drive
	save( full ){

		if( window.game && game.is_host )
			this.updateAutoWrappers();

		const out = {
			auto_learn : this.auto_learn,
			disabled : this.disabled,
			name : this.name,
			icon : this.icon,
			actions : Action.saveThese(this.actions, full),
			tags : this.tags,
			team : this.team,
			species : this.species,
			spre : this.spre,
			description : this.description,
			size : this.size,
			level : this.level,
			class : this.class instanceof PlayerClass ? PlayerClass.saveThis(this.class, full) : this.class,
			svPhysical : this.svPhysical,
			svArcane : this.svArcane,
			svCorruption : this.svCorruption,
			bonPhysical : this.bonPhysical,
			bonArcane : this.bonArcane,
			bonCorruption : this.bonCorruption,
			used_punish : this.used_punish,
			leader : this.leader,
			talkative : this.talkative,
			label : this.label,
			icon_lowerBody : this.icon_lowerBody,
			icon_nude : this.icon_nude,
			icon_upperBody : this.icon_upperBody,
			power : this.power,
			hpMulti : this.hpMulti,
			passives : Wrapper.saveThese(this.passives, full),
			sadistic : this.sadistic,					// Normal vs Sadistic
			dominant : this.dominant,					// Dominant vs submissive
			hetero : this.hetero,						// 0 = gay, 0.5 = bi, 1 = straight
			intelligence : this.intelligence,
			he : this.he,
			him : this.him,
			his : this.his,
			generated : this.generated,	// Needed for playerMarkers in webgl
			armor : this.armor,
			actionGroups : PlayerActionGroup.saveThese(this.actionGroups)
		};

		if( full !== "mod" )
			out.experience = this.experience;

		// Should only be sent while we're hosting a netgame
		//if( window.game && Game.net.isInNetgameHost() && !full )
		out._tmp_actions = Action.saveThese(this._tmp_actions, full);

		// Assets are only sent if equipped, PC, or full
		out.assets = Asset.saveThese(this.assets.filter(el => full || el.equipped || !this.isNPC() || this.isDead()), full);

		if( full ){

			out.remOnDeath = this.remOnDeath;
			out.leveled = this.leveled;
			out.inventory = this.inventory;
			out.talkative = this.talkative;
			if( full !== "mod" ){
				out._stun_diminishing_returns = this._stun_diminishing_returns;
				out._difficulty = this._difficulty;
				out._threat = this._threat;
				out._turn_ap_spent = this._turn_ap_spent;
				out._damaging_since_last = this._damaging_since_last;
				out._damage_since_last = this._damage_since_last;
				out._d_damaging_since_last = this._d_damaging_since_last;
				out._d_damage_since_last = this._d_damage_since_last;
				out._turns = this._turns;
				out._turn_action_used = this._turn_action_used;
				out._riposted_since_last = this._riposted_since_last;
				out._riposting_since_last = this._riposting_since_last;
			}

		}


		// Everything except mod
		if( full !== "mod" ){
			
			out.id = this.id;
			out.ap = this.ap;
			out.hp = this.hp;
			out.mp = this.mp;
			out.pAP = this.pAP;
			out.pMP = this.pMP;
			out.blArcane = this.blArcane;
			out.blCorruption = this.blCorruption;
			out.blPhysical = this.blPhysical;
			out.iblArcane = this.iblArcane;
			out.iblCorruption = this.iblCorruption;
			out.iblPhysical = this.iblPhysical;
			out.wrappers = Wrapper.saveThese(this.wrappers, full);
			out.netgame_owner = this.netgame_owner;
			out.netgame_owner_name = this.netgame_owner_name;
			out.color = this.color;
			out.arousal = this.arousal;
			out._targeted_by_since_last = this._targeted_by_since_last.save(full);		// Needed by netcode

		}
		else
			this.g_sanitizeDefaults(out);

		return out;
	}

	// Code that's run after the game has finished loading
	initialize(){

		// Apply constraints
		this.addHP(0);
		this.addMP(0);
		this.addAP(0);
		this.updateAutoWrappers();
		this.addTagSynonyms();
		
		if( game.is_host ){
			this.rebindWrappers(true);
		}
	}

	rebindWrappers( ignoreStayCheck = false ){

		this.unbindWrappers();
		let w = this.getWrappers();	// Otherwise items not equipped might cause procs
		w.map(wrapper => {
			wrapper.bindEvents();
		});
		this._bound_wrappers = w;
		
		// Ignored when adding wrappers because wrappers may need to apply required tags before checking the conditions
		if( !ignoreStayCheck )
			Wrapper.checkAllStayConditions();

	}

	unbindWrappers(){

		for( let wrapper of this._bound_wrappers ){

			// These are bound on an encounter by encounter basis, and all players share these
			if( wrapper.parent && wrapper.parent instanceof Encounter )
				continue;
				
			wrapper.unbindEvents();

		}

	}


	uncache(){
		this._cache_tags = null;
		this._cache_effects = null;
		this._cache_wrappers = null;
	}


	/* Metadata */

	// For these functions, type is an Action.Types value, if undefined, it counts ALL types
	// Returns how many damaging actions a player has used since this one's last turn
	damagingSinceLastByPlayer( player, type ){

		if( player && player.constructor === Player )
			player = player.id;

		if( !this._damaging_since_last[player] )
			return 0;

		let out = 0;
		for( let i in this._damaging_since_last[player] ){

			if( i === type || type === undefined )
				out += this._damaging_since_last[player][i];

		}

		return out;
	}
	// Damge taken since last turn from player to this
	damageSinceLastByPlayer( player, type ){

		if( player && player.constructor === Player )
			player = player.id;
		if( !this._damage_since_last[player] )
			return 0;

		let out = 0;
		for( let i in this._damage_since_last[player] ){

			if( type === undefined || i === type )
				out += this._damage_since_last[player][i];

		}

		return out;

	}
	damagingDoneSinceLastToPlayer( player, type ){

		if( player && player.constructor === Player )
			player = player.id;
		if( !this._d_damaging_since_last[player] )
			return 0;
		let out = 0;
		for( let i in this._d_damaging_since_last[player] ){
			if( i === type || type === undefined )
				out += this._d_damaging_since_last[player][i];
		}
		return out;

	}
	// Damage this has done to player since last round
	damageDoneSinceLastToPlayer( player, type ){

		if( player && player.constructor === Player )
			player = player.id;

		if( !this._d_damage_since_last[player] )
			return 0;

		let out = 0;
		for( let i in this._d_damage_since_last[player] ){

			if( type === undefined || i === type )
				out += this._d_damage_since_last[player][i];

		}
		return out;
	}
	// How many times this player has riposted me
	ripostedSinceLastByPlayer( player ){

		if( player && player.constructor === Player )
			player = player.id;
		if( !this._riposted_since_last[player] )
			return 0;
		return this._riposted_since_last[player][i];

	}
	// How many times we riposted that player
	ripostingSinceLastByPlayer( player ){

		if( player && player.constructor === Player )
			player = player.id;
		if( !this._riposting_since_last[player] )
			return 0;
		return this._riposting_since_last[player][i];

	}
	// Calculates a total number for any of the above, allowing you to filter by type 
	// Use the object property as input, and it returns the sum
	datTotal( input, type ){
		let out = 0;
		for( let i in input ){
			for( let t in input[i] ){
				if( t === type || type === undefined )
					out += input[i][t];
			}
		}
		return out;
	}

	// Used for riposte that only has one level
	datTotalShort( input ){

		let out = 0;
		for( let i in input )
			out += input[i];
		return out;

	}

	// Returns an array of enabled actions belonging to a group
	getActionGroup( group ){

		let out = [];
		const actions = this.getActions();
		for( let action of actions ){
			if( action.group === group )
				out.push(action);
		}
		return out;

	}
	// Finds the group position in the game.actions by action label. Used when setting group index 
	getActualGroupPos( group, label ){

		const actions = this.getActionGroup(group);
		for( let i = 0; i < actions.length; ++i ){

			let action = actions[i];
			if( action.label === label )
				return i;

		}
		return 0;

	}

	// Action groups
	getActiveActionGroupIndex( group ){

		for( let g of this.actionGroups ){

			if( g.id === group )
				return g.active;

		}

		return 0;

	}
	
	setActiveActionGroupIndex( group, index, additive = false ){

		for( let g of this.actionGroups ){

			if( g.id === group ){

				if( additive ){

					g.active += parseInt(index) || 1;
					const length = this.getActionGroup(group).length;
					if( g.active >= length )
						g.active = 0;
					else if( g.active < 0 )
						g.active = length-1;

				}
				else
					g.active = parseInt(index) || 0;
				return;

			}

		}
		this.actionGroups.push(new PlayerActionGroup({
			id : group,
			index : index
		}));

	}

	// When run from an effect, the effect needs to be present to prevent recursion 
	// prefix is usually se_ or ta_
	appendMathVars( prefix, vars, event ){

		let isRoot = this._ignore_effects === null;
		if( isRoot )
			this._ignore_effects = [];

		if( event && event.effect )
			this._ignore_effects.push(event.effect);
		// Theres a recursion here when math is used in SV/Bon and to get SV/Bon you need math
		vars[prefix+'SvPhysical'] = this.getSV(Action.Types.physical);
		vars[prefix+'SvArcane'] = this.getSV(Action.Types.arcane);
		vars[prefix+'SvCorruption'] = this.getSV(Action.Types.corruption);
		
		vars[prefix+'BonPhysical'] = this.getBon(Action.Types.physical);
		vars[prefix+'BonArcane'] = this.getBon(Action.Types.arcane);
		vars[prefix+'BonCorruption'] = this.getBon(Action.Types.corruption);
		vars[prefix+'Lv'] = this.level;
		vars[prefix+'HP'] = this.hp;
		vars[prefix+'AP'] = this.ap;
		vars[prefix+'Arousal'] = this.arousal;
		vars[prefix+'Team'] = this.team;
		vars[prefix+'Size'] = this.size;
		vars[prefix+'TeamPlayers'] = game.getTeamPlayers(this.team).length;
		vars[prefix+'MaxHP'] = this.getMaxHP();
		vars[prefix+'MaxAP'] = this.getMaxAP();
		vars[prefix+'MaxMP'] = this.getMaxMP();
		vars[prefix+'MaxArousal'] = this.getMaxArousal();
		vars[prefix+'Money'] = this.getMoney();
		vars[prefix+'apSpentThisTurn'] = this._turn_ap_spent;
		vars[prefix+'actionsUsedThisTurn'] = this._turn_action_used;

		vars[prefix+'ButtSize'] = this.getGenitalSizeValue(stdTag.butt);
		vars[prefix+'BreastSize'] = this.getGenitalSizeValue(stdTag.breasts);
		vars[prefix+'PenisSize'] = this.getGenitalSizeValue(stdTag.penis);

		vars[prefix+'UntappedBlock'] = this._untappedBlock;

		let tags = this.getTags();
		for( let tag of tags )
			vars[prefix+'Tag_'+tag] = 1;

		// Get a total value
		vars[prefix+'damagingReceivedSinceLast'] = this.datTotal( this._damaging_since_last );
		vars[prefix+'damageReceivedSinceLast'] = this.datTotal( this._damage_since_last );
		vars[prefix+'damagingDoneSinceLast'] = this.datTotal( this._d_damaging_since_last );
		vars[prefix+'damageDoneSinceLast'] = this.datTotal( this._d_damage_since_last );
		vars[prefix+'ripostedSinceLast'] = this.datTotalShort(this._riposted_since_last);
		vars[prefix+'ripostingSinceLast'] = this.datTotalShort(this._riposting_since_last);

		vars[prefix+'targetedSinceLast'] = objectSum(this._targeted_by_since_last.save());
		for( let i in Action.Types ){
			let type = Action.Types[i];
			vars[prefix+'damagingReceivedSinceLast'+type] = this.datTotal( this._damage_since_last, type );
			vars[prefix+'damageReceivedSinceLast'+type] = this.datTotal( this._damage_since_last, type );
			vars[prefix+'damagingDoneSinceLast'+type] = this.datTotal( this._d_damaging_since_last, type );
			vars[prefix+'damageDoneSinceLast'+type] = this.datTotal( this._d_damage_since_last, type );
		}

		// The mathvars event has a sender and target, and this player is the victim
		const weAreVictim = ( event && this === event.target && event.sender instanceof Player );
		const weAreSender = ( event && this === event.sender && event.target instanceof Player );
		// If we're the target of the event, append these
		if( weAreVictim ){

			// Add how much damage the sender has done to us
			vars.se_TaDamagingReceivedSinceLast = this.damagingSinceLastByPlayer(event.sender);
			vars.se_TaDamageReceivedSinceLast = this.damageSinceLastByPlayer(event.sender);

			// Target's crit chance on sender ta_Crit_se
			vars[prefix+'Crit_se'] = this.getCritDoneChance(event.sender);

		}
	
		if( weAreSender ){

			// Sender's crit chance on target se_Crit_ta
			vars[prefix+'Crit_ta'] = this.getCritDoneChance();

			vars.ta_SeDamagingReceivedSinceLast = this.damagingSinceLastByPlayer(event.target);
			vars.ta_SeDamageReceivedSinceLast = this.damageSinceLastByPlayer(event.target);

		}

		for( let i in Asset.Slots ){
			let slot = Asset.Slots[i];
			vars[prefix+slot] = this.getEquippedAssetsBySlots(slot).length ? 1 : 0;
		}

		let wrappers = this.getWrappers();
		for(let wrapper of wrappers){

			if( !wrapper.label )
				continue;

			vars[prefix+'Wrapper_'+wrapper.label] = wrapper.stacks;
			// This wrapper was added by the sender. Then we add it again and append _se to indicate the wrapper was added by the sender of the event.
			// Used in damage effects where you want to do something with the nr of stacks the caster has put on a target
			// ex ta_Wrapper_corruptingOoze_se
			if( weAreVictim && wrapper.getCaster() === event.sender )
				vars[prefix+'Wrapper_'+wrapper.label+'_se'] = wrapper.stacks;

			// Gets effects the target has put on the sender
			// ex se_Wrapper_corruptingOoze_ta
			if( weAreSender && wrapper.getCaster() === event.target )
				vars[prefix+'Wrapper_'+wrapper.label+'_ta'] = wrapper.stacks;

		}

		

		if( isRoot )
			this._ignore_effects = null;

		return vars;
	}

	getArticle(){
		
		if( this.spre )
			return this.spre;
		return 'aeiou'.includes(this.species.charAt(0).toLowerCase()) ? 'an' : 'a';

	}

	getName(){
		let out = this.name;
		return out;
	}

	getColoredName(){
		return '|c'+this.color+'|'+this.getName()+'|/c|';
	}

	// Statuses
	isDead(){
		return this.hp <= 0;
	}

	isAFK(){
		return Game.net.isPlayerAFK(this.netgame_owner);
	}

	isNPC(){
		return !this.netgame_owner || this.isAFK();
	}

	isLootableBy( player ){
		return Boolean(player) && !game.battle_active && this.isDead() && this.getLootableAssets().length && this.team !== player.team;
	}

	isArousalDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableArousal);
	}
	isAPDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableAP);
	}
	isMPDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableMP);
	}
	isNonRequiredForVictory(){
		return this.hasTag('pl_'+stdTag.gpDisableVictoryCondition);
	}
	isHPDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableHP);
	}
	isInvisible(){
		return this.hasTag(stdTag.gpInvisible);
	}
	isSkipAllTurns(){
		return this.hasTag(['pl_'+stdTag.gpSkipTurns, stdTag.gpSkipTurns]);
	}
	isLeader(){
		return this.leader || !Game.net.isConnected();
	}

	canRiposte(){
		return !this.hasTag(stdTag.wrNoRiposte);
	}

	// Can't accept their turn
	isIncapacitated(){
		let stun = this.getActiveEffectsByType(Effect.Types.stun);
		return stun.length > 0 || this.isSkipAllTurns();
	}

	// Returns taunting players unless there's a grappling player, in which case that's returned instead
	getTauntedOrGrappledBy( actionRange, returnAllIfNone = true, debug ){
		
		let players = this.getGrappledBy();
		if( debug )
			console.debug("Grappled by ", players);
		if( players.length )
			return players;
		return this.getTauntedBy(actionRange, returnAllIfNone, debug);

	}

	getGrappledBy(){

		let grapples = this.getActiveEffectsByType(Effect.Types.grapple);
		let out = [];
		for( let effect of grapples ){
			let sender = effect.parent.getCaster();
			if( sender && out.indexOf(sender) === -1 )
				out.push(sender);
		}
		return out;

	}

	// ActionRange is from Action.Range
	getTauntedBy( actionRange, returnAllIfNone = true, debug ){

		let tauntEffects = this.getActiveEffectsByType(Effect.Types.taunt);

		// Filter by range
		tauntEffects = tauntEffects.filter(effect => {

			// Either works
			if( effect.data.melee === undefined || actionRange === undefined )
				return true;

			if( effect.data.melee && actionRange !== Action.Range.Melee )
				return false;

			if( !effect.data.melee && actionRange !== Action.Range.Ranged )
				return false;
			
			return true;

		});

		if( debug )
			console.debug("Taunt effects", tauntEffects);
		if( !tauntEffects.length )
			return returnAllIfNone ? game.getEnabledPlayers() : [];

		let out = [];
		for( let effect of tauntEffects ){
			// Pick the sender
			let sender = effect.parent.getCaster();
			if( effect.data && effect.data.victim )
				sender = effect.parent.parent;

			if( sender && out.indexOf(sender) === -1 )
				out.push(sender);

		}
		return out;

	}

	isBeast(){
		return this.hasTag(stdTag.plBeast);
	}
	isTargetBeast(){
		return this.hasTag([stdTag.plBeast, stdTag.plTargetBeast]);
	}

	// Gets level including difficulty adjust. Used only in rolls.
	getLevel(){
		return this.level + (this.team !== Player.TEAM_PLAYER ? game.difficulty : 0);
	}


	// ICONS
	getActiveIcon(){
		
		const ub = this.hasTag(stdTag.asUpperBody),
			lb = this.hasTag(stdTag.asLowerBody)
		;
		if( !ub && !lb && this.icon_nude )
			return this.icon_nude;
		if( ub && !lb && this.icon_upperBody )
			return this.icon_upperBody;
		if( !ub && lb && this.icon_lowerBody )
			return this.icon_lowerBody;

		if( !this.icon )
			return 'media/characters/missing_art.jpg';
		return this.icon;

	}




	// RP Tags

	// Auto adds base tags like pl_penis if the player only has pl_big_penis etc
	addTagSynonyms(){

		
		const tags = this.getTags();
		const hasSynonymTag = ending => {
			
			for( let tag of tags ){
				
				if( tag.startsWith('pl_') && tag.endsWith('_'+ending) )
					return true;

			}

		};
		let synonyms = [
			'penis',
			'breasts'
		];
		for( let synonym of synonyms ){

			if( hasSynonymTag(synonym) ){

				const tn = 'pl_'+synonym;
				if( !this.tags.includes(tn) )
					this.tags.push(tn);

			}
		}

	}

	// Searches tags for pl_<prefix>_huge/big/small and returns a synonym
	getSizeTag( prefix ){

		prefix = prefix.substr(3);
		let texts = [""];
		if( this.hasTag('pl_big_'+prefix) )
			texts = ["big", "large", "sizable"];
		else if( this.hasTag('pl_huge_'+prefix) )
			texts = ["huge", "enormous", "gigantic", "massive"];
		else if( this.hasTag('pl_small_'+prefix) )
			texts = ['small'];

		return texts[Math.floor(Math.random()*texts.length)];

	}
	getBreastSizeTag(){
		return this.getSizeTag(stdTag.breasts);
	}
	getPenisSizeTag(){
		return this.getSizeTag(stdTag.penis);
	}
	getButtSizeTag(){
		return this.getSizeTag(stdTag.butt);
	}

	// Returns a value where 0 = none, 1 = small, 2 = average, 3 = large, 4 = huge
	// Prefix should be either stdTag.breasts, stdTag.penis or stdTag.butt
	getGenitalSizeValue( prefix ){

		prefix = prefix.split('_');
		prefix.shift();
		prefix = prefix.join('_');

		if( this.hasTag('pl_huge_'+prefix) )
			return 4;
		if( this.hasTag('pl_big_'+prefix) )
			return 3;
		if( this.hasTag('pl_small_'+prefix) )
			return 1;
		if( this.hasTag('pl_'+prefix) )
			return 2;
		return 0;
	}

	// Overrides the generic definition for this
	getTags( wrapperReturn, force = false ){

		if( window.game && game._caches && this._cache_tags && !force )
			return this._cache_tags;

		let out = {};
		if( this.hp <= 0 )
			out[stdTag.dead] = true;

		for( let tag of this.tags ){

			if( !tag.startsWith('pl_') )
				tag = 'pl_'+tag;
			out[tag] = true;

		}

		// adds a tag to the name map
		const addTag = tag => out[tag] = true;

		let assets = this.getAssetsEquipped();
		if( wrapperReturn && wrapperReturn.armor_strips[this.id] ){

			for( let slot in wrapperReturn.armor_strips[this.id] ){

				const a = wrapperReturn.armor_strips[this.id][slot];
				if( assets.indexOf(a) === -1 ){
					assets.push(a);
				}
				
			}

		}

		for( let asset of assets )
			asset.getTags().map(addTag);

		let fx = this.getWrappers();
		for( let f of fx ){
			f.getTags().map(addTag);
		}

		fx = this.getEffects();
		for( let f of fx ){

			f.getTags().map(addTag);
			// Bondage device mapping
			if( f.type === Effect.Types.tieToRandomBondageDevice && f.data._device ){

				const device = game.dungeon.getActiveRoom().getAssetById(f.data._device);
				if( device ){
					
					const dTags = device.getTags();
					for( let tag of dTags )
						out['bo_'+tag] = true;

				}
			}

		}
		this._turn_tags.map(t => out[t.tag] = true);

		if( this.species )
			out['p_'+this.species.toLowerCase()] = true;

		if( window.game && game.dungeon instanceof Dungeon )
			game.dungeon.getTags().map(t => out[t] = true);

		const ret = Object.keys(out);
		if( window.game && game._caches )
			this._cache_tags = ret;

		return ret;

	}

	// overrides generic class
	hasTagBy( tags, sender ){

		if( !Array.isArray(tags) )
			tags = [tags];

		// Start by checking turn tags
		for( let tt of this._turn_tags ){
			if( sender.id === tt.s.id && ~tags.indexOf(tt.tag) )
				return true;
		}

		
		// Check wrapper tags
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){
			if( wrapper.caster === sender.id && wrapper.hasTag(tags) )
				return true;
		}
		

		// Next check the effects
		const effects = this.getEffects();
		for( let effect of effects ){
			if( effect.parent.caster === sender.id && (effect.hasTag(tags)) )
				return true;
		}

		
		return false;

	}

	getPronoun(pronoun){

		if( pronoun === 'he' && this.he )
			return this.he;
		if( pronoun === 'him' && this.him )
			return this.him;
		if( pronoun === 'his' && this.his )
			return this.his;

		let out = 
			(this.hasTag('pl_penis') ? 1 : 0) |
			(this.hasTag('pl_vagina') ? 2 : 0) |
			(this.hasTag('pl_breasts') ? 4 : 0)
		;
		let pronouns = ['it', 'it', 'its'];
		if( out && out < 3 )
			pronouns = ['he', 'him', 'his'];
		else if( out === 6 )
			pronouns = ['she', 'her', 'her'];
		else if( out )
			pronouns = ['shi', 'hir', 'hir'];
		
		if( pronoun === 'he' )
			return pronouns[0];
		if( pronoun === 'him' )
			return pronouns[1];
		return pronouns[2];

	}
	// Get gender according to Game.Genders
	getGameGender(){

		let out = 
			(this.hasTag('pl_penis') ? 1 : 0) |
			(this.hasTag('pl_vagina') ? 2 : 0) |
			(this.hasTag('pl_breasts') ? 4 : 0)
		;
		
		if( out === 1 )
			return Game.Genders.Male;
		else if( out === 6 )
			return Game.Genders.Female;
		return Game.Genders.Other;

	}

	// Sets tags and strips pl_ prefix
	// Chainable
	setTags( tags ){
		this.tags = [];
		for( let tag of tags ){
			tag = tag.split('_');
			if( tag[0] === 'pl' )
				tag.shift();
			this.tags.push(tag.join('_'));
		}
		return this;
	}


	

	


	/* Events */
	// happens to NPCs the first time they're placed in world from an encounter
	onPlacedInWorld(){

		this.netgame_owner = '';
		if( this.leveled ){
			
			this.level += game.getHighestLevelPlayer();
			this.leveled = false;

		}

		this.addDefaultActions();

		this.assets = this.assets.map(el => Asset.convertDummy(el, this));
		for( let index of this.inventory ){
			if( this.assets[index] && this.assets[index].equippable() ){
				this.equipAsset(this.assets[index].id);
			}
		}
		this.inventory = [];

		for( let inv of this.assets )
			inv.onPlacedInWorld();

		for( let passive of this.passives )
			passive.g_resetID();
		
		this.addHP(Infinity);
		this.addMP(Infinity);
		this.arousal = 0;

		if( !this.getKinks().length && !this.hasTag([stdTag.plBeast, stdTag.plTargetBeast]) )
			this.shuffleKinks();
		
	}
	onRemoved(){
		this.unbindWrappers();
	}
	onTurnEnd(){

		const wrappers = this.getWrappers(undefined, true);
		for(let wrapper of wrappers)
			wrapper.onTurnEnd();

		for(let action of this.actions)
			action.onTurnEnd();
		if( this._stun_diminishing_returns > 0 )
			--this._stun_diminishing_returns;
		this._damaging_since_last = {};
		this._damage_since_last = {};
		this._targeted_by_since_last = new Collection();
		++this._turns;

	}

	// Raised after effects
	onTurnStart(){

		this._d_damaging_since_last = {};
		this._d_damage_since_last = {};
		this._riposted_since_last = {};
		this._riposting_since_last = {};
		
		// Convert incoming block (block added while it's not your turn) into block that vanishes the next turn
		this._untappedBlock = this.blPhysical+this.blArcane+this.blCorruption;
		this.blPhysical = this.iblPhysical;
		this.blArcane = this.iblArcane;
		this.blCorruption = this.iblCorruption;
		this.iblArcane = this.iblCorruption = this.iblPhysical = 0;
		
		if( this._untappedBlock )
			new GameEvent({sender:this, target:this, type:GameEvent.Types.blockExpired}).raise();

		// Wipe turnTags on start
		this.resetTurnTags();

		if( this.bot )
			this.bot.onTurnStart();

		
		const wrappers = this.getWrappers(undefined, true);
		for(let wrapper of wrappers)
			wrapper.onTurnStart();

		const actions = this.getActions();
		for(let action of actions)
			action.onTurnStart();
		
		if( this.arousal > 0 && this._turns%2 === 0 ){
			/*
			let sub = -this.getMaxArousal()/10;	// You lose 10% every 3 turns
			let rem = Math.floor(sub);
			if( Math.random() < sub-rem )
				--rem;
			*/
			this.addArousal(-1);	// Lose 1 every 2 turns
			
		}

		this._turn_action_used = 0;
		this._turn_ap_spent = 0;
		// Restore 3/10ths each turn
		const map = this.getMaxAP();
		let ap = map*0.4*this.getGenericAmountStatMultiplier(Effect.Types.regenAP, this); // base AP to add

		// Add pending AP
		if( this.pAP < 0 )
			ap += this.pAP;
		if( ap < 0 )
			ap = 0;
		

		// Shuffle the fractions
		if( Math.random() < ap-Math.floor(ap) )
			++ap;

		this.addAP(Math.max(Math.floor(ap), 1));	// You have a guaranteed 1 AP
		
		// Gain 1 MP every 3 turns
		let mp = Math.max(this.pMP, 0);
		if( this.mp < this.getMaxMP() && !(this._turns%3) )
			++mp;
		if( mp )
			this.addMP(1);

		this.pMP = this.pAP = 0;	// Reset the initial thing
		

	}
	onBattleStart(){
		this._used_chats = {};
		this._turn_tags = [];
		this.ap = 0;			// Start with 0 AP
		this._threat = {};
		this._stun_diminishing_returns = 0;
		this._damaging_since_last = {};
		this._damage_since_last = {};
		this._last_chat = -1;
		this._turn_action_used = 0;
		this.blCorruption = this.blPhysical = this.blArcane = this.iblPhysical = this.iblArcane = this.iblCorruption = 0;
		if( this.arousal >= this.getMaxArousal() )
			this.arousal = this.getMaxArousal()-1;

		this.resetTempActions();

		let actions = this.getActions();
		for(let action of actions)
			action.onBattleStart();

	}
	onBattleEnd(){

		this.blCorruption = this.blPhysical = this.blArcane = this.iblPhysical = this.iblArcane = this.iblCorruption = 0;
		this._last_chat = 0;	// Needed for out of combat chat
		this.ap = 0;
		let actions = this.getActions();
		for(let action of actions)
			action.onBattleEnd();

		this.wrappers = this.wrappers.filter(wrapper => {

			if( wrapper.ext )	// Use external timer (game time)
				return true;

			// Purge the wrapper
			wrapper.unbindEvents();

		});

		for( let asset of this.assets )
			asset.onBattleEnd();

		let wrappers = this.getWrappers(undefined, true);
		for(let wrapper of wrappers)
			wrapper.onBattleEnd();
			
		this._stun_diminishing_returns = 0;
		this._turns = 0;
		this.used_punish = false;

		// Prevent PCs from ending a battle at max arousal
		if( this.arousal >= this.getMaxArousal() && this.team === Player.TEAM_PLAYER )
			this.arousal = this.getMaxArousal()-1;

		this.resetTempActions();
		
	}
	// only triggers on PC for now
	onBattleWon(){
		
		if( this.generated )
			return;

		this.addHP(Math.ceil(this.getMaxHP()*0.3));		// Regen 30% of your HP
		this.addMP(Math.round(this.getMaxMP()*0.3));	// Regen 30% of MP
		this.addArousal(-Math.ceil(this.getMaxArousal()*0.15), undefined, true);

	}

	// Item broken, repaired, equipped, or removed
	onItemChange(){
		this.addHP(0);
		this.addAP(0);
	}

	onCellChange(){
		this.used_punish = true;
	}

	onTimePassed( delta ){
		
		// May need getWrappers()? But it's important that wrappers attached to assets also tick
		this.getWrappers(undefined, true).map(wrapper => wrapper.onTimePassed());
		this.getAssets().map(asset => asset.onTimePassed());

		// Out of combat regen
		if( !game.battle_active && this.team === Player.TEAM_PLAYER ){
			
			const 
				startTime = game._combat_changed,
				curTime = game.time
			;

			const 
				preMinutes = Math.floor((curTime-startTime-delta)/60),
				postMinutes = Math.floor((curTime-startTime)/60)
			;
			
			// Newly added minutes
			if( postMinutes > preMinutes ){

				this.addMP(postMinutes-preMinutes);
				this.addHP(postMinutes-preMinutes);
				this.addArousal(-(postMinutes-preMinutes));
				this.addAP((postMinutes-preMinutes)*3);	// 3 AP per minute
				
				const actions = this.getActions(true, false, true, false);
				for( let action of actions )	// Subtract 1 cooldown per minute
					action.addCooldown(-(postMinutes-preMinutes));

			}

		}

	}

	

	onDamagingAttackReceived( sender, type ){
		if(!this._damaging_since_last[sender.id])
			this._damaging_since_last[sender.id] = {};
		if(!this._damaging_since_last[sender.id][type])
			this._damaging_since_last[sender.id][type] = 0;
		
		++this._damaging_since_last[sender.id][type];
	}
	onDamagingAttackDone(target, type){

		if(!this._d_damaging_since_last[target.id])
			this._d_damaging_since_last[target.id] = {};
		if(!this._d_damaging_since_last[target.id][type])
			this._d_damaging_since_last[target.id][type] = 0;
		
		++this._d_damaging_since_last[target.id][type];

	}
	onDamageTaken( sender, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._damage_since_last[sender.id])
			this._damage_since_last[sender.id] = {};
		if(!this._damage_since_last[sender.id][type])
			this._damage_since_last[sender.id][type] = 0;
		
		this._damage_since_last[sender.id][type] += amount;
	}
	onDamageDone( target, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._d_damage_since_last[target.id])
			this._d_damage_since_last[target.id] = {};
		if(!this._d_damage_since_last[target.id][type])
			this._d_damage_since_last[target.id][type] = 0;
		this._d_damage_since_last[target.id][type] += amount;
	}
	onTargetedActionUsed( target ){
	}
	onTargetedActionReceived( sender ){
		let amount = this._targeted_by_since_last.get(sender.id) || 0;
		++amount;
		this._targeted_by_since_last.set(sender.id, amount);
	}
	onRiposteDone( target ){
		if( !this._riposting_since_last[target.id] )
			this._riposting_since_last[target.id] = 0;
		++this._riposting_since_last[target.id];
	}
	onRiposteReceived( target ){
		if( !this._riposted_since_last[target.id] )
			this._riposted_since_last[target.id] = 0;
		++this._riposted_since_last[target.id];
	}
	

	onDeath( attacker, effect ){
		
		// Damage durability
		const assets = this.getAssetsEquipped(false);
		for( let asset of assets )
			asset.damageDurability( attacker, effect, Math.ceil(asset.getMaxDurability()*0.2) );

		if( this.remOnDeath ){
			game.removePlayer(this);
		}

	}

	onIdChanged(){
		this.updatePassives();
		this.getAssetsEquipped().map(el => el.onEquip());
	}

	/* Kinks */
	getKinks(){

		return this.passives.filter(el => el.hasTag(stdTag.wrKink));

	}

	hasKink( label ){

		let all = this.getKinks();
		for( let kink of all ){

			if( kink.label === label )
				return true;

		}

		return false;

	}

	removeKinks(){
		this.getKinks().map(this.removePassive, this);
	}

	shuffleKinks(){

		// Scan the wrapper DB
		const evt = new GameEvent({
			sender:this,
			target:this
		});
		const kinks = Wrapper.getKinks().filter(wrapper => wrapper.testAgainst( evt, false ));
		shuffle(kinks);

		this.removeKinks();
		for( let i = 0; i < MAX_KINKS; ++i )
			this.addPassive(kinks[i]);

	}


	/* TurnTags */
	addTurnTags( tags, sender ){
		for( let tag of tags ){
			this.removeTurnTag(tag);
			this._turn_tags.push({tag:tag, s:sender});
		}
	}

	// returns a turnTag object if it exists
	getTurnTag( tag ){
		for( let ttObj of this._turn_tags ){
			if( ttObj.tag === tag )
				return ttObj;
		}
		return false;
	}

	removeTurnTag( tag ){
		for( let i in this._turn_tags ){
			if( this._turn_tags[i].tag === tag ){
				this._turn_tags.splice(i,1);
				return;
			}
		}
	}

	resetTurnTags(){
		this._turn_tags = [];
	}


	/* Assets */
	// if fromStacks is true, it only iterates once and adds amount to stacks instead of asset._stacks
	// returns false on fail, or an array of all added assets on success
	addAsset( asset, amount = 1, fromStacks = false, no_equip = false, resetid = false ){
		if( !(asset instanceof Asset) ){
			console.error("Trying to add non-asset. Did you mean to use addLibraryAsset?");
			return false;
		}
		asset.equipped = false;

		const out = {};
		asset.onPlacedInWorld();
		for( let i = 0; i<amount && (!fromStacks || i<1); ++i ){
			// Needs to be its own object
			const a = asset.clone(this);

			if( resetid )
				a.g_resetID();	// Buying stacks will bork everything otherwise

			const exists = this.getAssetByLabel(a.label);
			let n = a._stacks;
			if( fromStacks )
				n = amount;
			if( a.stacking && exists )
				exists._stacks += n;
			else{
				a._stacks = n;
				this.assets.push(a);
			}
			if( a.category === Asset.Categories.consumable ){
				
				if( this.getEquippedAssetsBySlots(Asset.Slots.action).length < 3 ){
					this.equipAsset(a.id, this);
				}

			}
			else if( this.isNPC() ){

				if( !no_equip && !game.battle_active && !this.getEquippedAssetsBySlots(a.slots).length && a.equippable() )
					this.equipAsset(a.id, this);

			}

			out[a.id] = a;

		}
		this.raiseInvChange();
		game.onInventoryAdd( this, asset );
		return Object.values(out);

	}
	raiseInvChange(){
		new GameEvent({type:GameEvent.Types.inventoryChanged, sender:this, target:this}).raise();
	}
	addLibraryAsset( label, amount = 1 ){

		let asset = glib.get(label, 'Asset');
		if( !asset ){
			console.error("Invalid library asset", label);
			return false;
		}
		asset.g_resetID();
		asset.repair();
		asset.resetCharges();
		return this.addAsset(asset, amount);

	}
	getAssetById(id){
		for(let asset of this.assets){
			if(asset.id === id)
				return asset;
		}
		return false;
	}
	// useful for stackable items like currency
	getAssetByLabel( label ){
		for(let asset of this.assets){
			if( asset.label === label )
				return asset;
		}
		return false;
	}
	isAssetEquipped(id){
		let asset = this.getAssetById(id);
		if(!asset)
			return false;
		return asset.equipped;
	}
	getEquippedAssetsBySlots( slots, includeBroken ){
		if( !Array.isArray(slots) )
			slots = [slots];
		let assets = this.getAssetsEquipped(includeBroken);
		let out = [];
		for(let asset of assets){
			for( let slot of slots ){
				if( ~asset.slots.indexOf(slot) ){
					out.push(asset);
					break;
				}
			}
		}
		return out;
	}
	// byPlayer is the player who initiated the equip. If it's not a player, no event is raised.
	equipAsset( id, byPlayer ){

		let assets = this.getAssetsInventory();
		for(let asset of assets){

			if(asset.id === id){

				if( !asset.equippable() ){
					console.error("Item can not be equipped");
					return false;
				}

				// Special case for action slot
				const isActionAsset = ~asset.slots.indexOf(Asset.Slots.action);
				if( isActionAsset && !this.unequipActionAssetIfFull() )
					return false;
				if( !isActionAsset && !this.unequipAssetsBySlots(asset.slots, byPlayer) )
					return false;

				asset.equipped = true;
				asset.onEquip();
				this.onItemChange();
				if( game.battle_active && byPlayer )
					game.ui.addText( this.getColoredName()+" equips "+asset.name+".", undefined, this.id, this.id, 'statMessage important' );
				this.rebindWrappers();

				if( byPlayer ){
					new GameEvent({
						type : GameEvent.Types.armorEquipped,
						sender : byPlayer,
						target : this,
						asset : asset
					}).raise();
				}

				return true;

			}

		}
		return false;

	}

	// byPlayer is the player who initiated it. If it's not a player object, no event is raised
	unequipAsset( id, byPlayer, noText ){

		let assets = this.getAssetsEquipped(true);
		for(let asset of assets){

			if( asset.id === id ){

				if( asset.rem_unequip )
					this.destroyAsset(asset.id);

				asset.equipped = false;
				this.onItemChange();
				if( game.battle_active && byPlayer && !noText )
					game.ui.addText( this.getColoredName()+" unequips "+asset.name+".", undefined, this.id, this.id, 'statMessage important' );
				this.rebindWrappers();

				if( byPlayer ){
					new GameEvent({
						type : GameEvent.Types.armorUnequipped,
						sender : byPlayer,
						target : this,
						asset : asset
					}).raise();
				}
				return asset;

			}

		}
		return true;

	}
	unequipAssetsBySlots( slots, byPlayer ){

		let equipped = this.getEquippedAssetsBySlots(slots, true);
		if(!equipped.length)
			return true;
		for( let e of equipped ){
			if(!this.unequipAsset(e.id, byPlayer))
				return false;
		}
		return true;

	}

	// returns nr of assets of label, including stacks
	numAssets( label ){
		let out = 0;
		for(let asset of this.assets){
			if( asset.label === label ){
				out += asset.stacking ? asset._stacks : 1;
			}
		}
		return out;
	}

	// Returns nr of assets by label, including stacks and charges
	numAssetUses( label, equipped_only = false ){

		let assets = this.assets;
		if( equipped_only )
			assets = this.getAssetsEquipped();
		let out = 0;
		for(let asset of assets){
			if( asset.label === label ){
				let n = asset.stacking ? asset._stacks : 1;
				if( asset.charges > 1 ){
					n = (n-1)*asset.charges+asset._charges;
				}
				else if( asset.charges === -1 )
					return -1;
				out += n;
			}
		}
		return out;
	}

	// Unequips the leftmost one if toolbelt is full
	unequipActionAssetIfFull(){

		let assets = this.getEquippedAssetsBySlots(Asset.Slots.action, true);
		if( assets.length < 3 )
			return true;
		return this.unequipAsset(assets[0].id, this);

	}

	// Returns equipped assets
	getAssetsEquipped( includeBroken ){
		const out = [], assets = this.getAssets();
		for(let asset of assets){
			if( asset === undefined )
				console.error("Undefined asset in", this);
			if( asset.equipped && (includeBroken || asset.durability > 0) )
				out.push(asset);
		}
		return out;
	}

	destroyAsset( id, amount ){

		if( id instanceof Asset )
			id = id.id;

		
		this.getAssetWrappers(id).map(el => el.remove());

		for(let i in this.assets){

			let asset = this.assets[i];
			if(asset.id === id){

				if( Math.floor(amount) && asset.stacking )
					asset._stacks -= amount;
				if( !amount || !this.assets[i].stacking || asset._stacks <= 0 )
					this.assets.splice(i, 1);
				this.raiseInvChange();
				this.rebindWrappers();
				return true;

			}

		}

		return false;

	}

	// Gets wrappers attached to an asset we own by asset id
	getAssetWrappers( id ){

		return this.wrappers.filter(wr => wr.asset && wr.asset === id);

	}

	destroyAssetsByLabel( label, amount = 1 ){

		for( let asset of this.assets ){

			if( asset.label === label ){	

				let nrToRemove = !asset.stacking ? 1 : asset._stacks;
				if( nrToRemove > amount )
					nrToRemove = amount;
				this.destroyAsset(asset.id, amount);
				amount -= nrToRemove;
				if( amount < 1 )
					return;

			}

		}

	}

	// Transfers an asset to a player. Player is a player object
	transferAsset( id, player, byPlayer ){

		let asset = this.getAssetById(id);
		if( !asset )
			return false;
		this.unequipAsset(id, byPlayer || this);
		player.addAsset(asset);
		this.destroyAsset(id);
		return true;

	}

	// Returns a list of assets that have their durability damaged
	getRepairableAssets(){
		return this.assets.filter(asset => {
			return asset.durability < asset.getMaxDurability() && asset.isDamageable();
		});
	}

	getAssets(){
		return this.assets;
	}

	// Returns non-equipped assets
	getAssetsInventory(){
		const out = [], assets = this.getAssets();
		for(let asset of assets){
			if(!asset.equipped)
				out.push(asset);
		}
		return out;
	}
	// Overwrite inventory items with defaults from database
	refetchInventory(){

		let lib = glib.getFull('Asset');
		for(let i in this.assets){

			let asset = this.assets[i];
			if( lib[asset.label] ){
				const stacks = this.assets[i]._stacks,
					equipped = this.assets[i].equipped;
				console.debug("Overwriting ", asset.label);
				this.assets[i] = lib[asset.label].clone(this);
				this.assets[i]._stacks = stacks;
				this.assets[i].equipped = equipped;

			}

		}

	}

	getLootableAssets(){
		return this.assets;
	}

	lootToPlayer( id, player, silent = false ){

		let asset = this.getAssetById(id);
		if( !asset ){
			if( !silent )
				console.error("Asset not found", id, "in", this);
			return false;
		}
		
		if( game.is_host && asset.loot_sound )
			game.playFxAudioKitById(asset.loot_sound, player, player, undefined, true );
		
		if( !game.is_host ){
			Game.net.playerLootPlayer( player, this, asset );
			return;
		}

		asset.equipped = false;		// Make sure it's not equipped
		if( player.addAsset(asset) )
			this.destroyAsset(id);

		game.ui.addText( player.getColoredName()+" looted "+asset.name+" from "+this.getColoredName()+".", undefined, player.id,  player.id, 'statMessage important' );
		game.save();
		game.ui.draw();

	}

	// By default it damages all worn items
	// Returns an array of {armor_damage:{slot:damage}, armor_strips:{slot:true}}
	damageDurability( sender, effect, amount, slots, fText = false ){

		const out = {
			armor_damage : {},
			armor_strips : {}
		};
		let assets = [];
		// Pick a slot at random
		if( slots === 'RANDOM' ){

			let viableAssets = this.getEquippedAssetsBySlots([Asset.Slots.lowerBody, Asset.Slots.upperBody]);
			if( !viableAssets.length )
				return;
			assets = [viableAssets[Math.floor(Math.random()*viableAssets.length)]];

		}
		else{

			if( !slots )
				slots = [Asset.Slots.lowerBody, Asset.Slots.upperBody];
			slots = toArray(slots);
			assets = this.getEquippedAssetsBySlots(slots);

		}

		let asc = assets.slice();	// Prevents adding to the one we're looping over
		for( let asset of asc ){
			
			let slots = asset.slots;
			if( Math.random() < 0.5 && slots.includes(Asset.Slots.lowerBody) )
				assets.push(...this.getEquippedAssetsBySlots([Asset.Slots.lowerBodyCosmetic]));
			if( Math.random() < 0.5 && slots.includes(Asset.Slots.upperBody) )
				assets.push(...this.getEquippedAssetsBySlots([Asset.Slots.upperBodyCosmetic]));
			
		}

		// 10% chance for jewellery
		if( Math.random() < 0.1 )
			assets.push(...this.getEquippedAssetsBySlots([Asset.Slots.jewelleryCosmetic]));
		
		
		amount = Math.round(amount);
		for( let asset of assets ){

			let destroyed = asset.damageDurability( sender, effect, amount, fText );
			if( destroyed !== false ){
				for( let slot of asset.slots ){

					out.armor_damage[slot] = amount;
					if( destroyed )
						out.armor_strips[slot] = asset;

				}
			}

		}
		this.rebindWrappers();

		return out;

	}


	// returns between 0 and 1
	getAssetDurabilityPercentageBySlot( slot ){

		let asset = this.getEquippedAssetsBySlots(slot);
		if( !asset.length )
			return 0;
		asset = asset.shift();
		return asset.durability / asset.getMaxDurability();

	}

	// Gets max carry capacity in grams
	getCarryingCapacity(){

		let flat = 
			35000+
			this.getGenericAmountStatPoints(Effect.Types.carryModifier)
		;

		return flat*this.getGenericAmountStatMultiplier(Effect.Types.carryModifier, this);

	}
	getCarriedWeight(){
		let out = 0;
		for(let asset of this.assets){
			let weight = asset.getWeight();
			out+= weight;
		}
		return out;
	}
	isEncumbered(){
		return !this.isBeast() && this.getCarriedWeight() > this.getCarryingCapacity();
	}

	// Currency
	// Returns currency value in copper
	getMoney(){
		let out = 0;
		for( let asset of this.assets ){
			if( asset.label === 'platinum' )
				out += asset._stacks*1000;
			else if( asset.label === 'gold' )
				out += asset._stacks*100;
			else if( asset.label === 'silver' )
				out += asset._stacks*10;
			else if( asset.label === 'copper' )
				out += asset._stacks;
		}
		return out;
	}

	consumeMoney( copper = 0 ){

		let total = this.getMoney();
		if( total < copper )
			return false;

		let costRemaining = copper;		// Remaining cost in copper we need to pay
		let consumeCopper = 0,			// Copper assets we need to remove
			consumeSilver = 0,			// Silver assets we need to remove
			consumeGold = 0,			// Gold assets we need to remove
			consumePlatinum = 0			// Plat assets we need to remove
		;
		let copperAsset = this.getAssetByLabel('copper'),
			silverAsset = this.getAssetByLabel('silver'),
			goldAsset = this.getAssetByLabel('gold')
		;
		// First see if we can handle it with just copper
		if( copperAsset && copperAsset._stacks >= copper ){
			consumeCopper = costRemaining;
			costRemaining = 0;
		}else{
			// Start by spending all copper
			if( copperAsset ){
				consumeCopper = copperAsset._stacks;
				costRemaining -= consumeCopper;
			}
			while( costRemaining > 0 ){
				// See if we still have any silver
				if( silverAsset && silverAsset._stacks > consumeSilver ){
					// Split a silver
					++consumeSilver;
					costRemaining -= 10;
				}else if( goldAsset && goldAsset._stacks > consumeGold ){
					// Split a gold
					++consumeGold;
					costRemaining -= 100;
				}
				else{
					// Split a platinum
					++consumePlatinum;
					costRemaining -= 1000;
				}
			}
		}

		const change = this.calculateMoneyExhange(Math.abs(costRemaining));
		consumeCopper -= change[3];
		consumeSilver -= change[2];
		consumeGold -= change[1];
		consumePlatinum -= change[0];

		//console.log("Consume: ", consumeCopper, "copper", consumeSilver, "silver", consumeGold, "gold", consumePlatinum, "plat." "Change in copper", Math.abs(costRemaining));
		
		if( consumeCopper < 0 ){
			const asset = glib.get('copper', 'Asset');
			asset._stacks = Math.abs(consumeCopper);
			this.addAsset(asset);
		}
		else if( consumeCopper > 0 )
			this.destroyAsset(copperAsset.id, consumeCopper);

		if( consumeSilver < 0 ){
			const asset = glib.get('silver', 'Asset');
			asset._stacks = Math.abs(consumeSilver);
			this.addAsset(asset);
		}
		else if( consumeSilver > 0 )
			this.destroyAsset(silverAsset.id, consumeSilver);
		
		if( consumeGold < 0 ){
			const asset = glib.get('gold', 'Asset');
			asset._stacks = Math.abs(consumeGold);
			this.addAsset(asset);
		}
		else if( consumeGold > 0 )
			this.destroyAsset(goldAsset.id, consumeGold);

		if( consumePlatinum < 0 ){
			const asset = glib.get('platinum', 'Asset');
			asset._stacks = Math.abs(consumePlatinum);
			this.addAsset(asset);
		}
		else if( consumePlatinum > 0 ){
			this.destroyAsset(this.getAssetByLabel('platinum').id, consumePlatinum);
		}
		return true;

	}

	// See Player.calculateMoneyExchange
	calculateMoneyExhange( input = 0 ){
		return Player.calculateMoneyExhange(input);
	}

	// Auto exchanges money assets to the fewest amounts of coins
	exchangeMoney(){
		const copper = this.getMoney();
		let asset;
		if( asset = this.getAssetByLabel('platinum') )
			this.destroyAsset(asset);
		if( asset = this.getAssetByLabel('gold') )
			this.destroyAsset(asset);
		if( asset = this.getAssetByLabel('silver') )
			this.destroyAsset(asset);
		if( asset = this.getAssetByLabel('copper') )
			this.destroyAsset(asset);
		
		let assets = Player.copperToAssets(copper);
		for( let a of assets )
			this.addAsset(a);
		
		return true;
		
	}

	// Exchanges a copper amount into plat, gold etc and adds
	addCopperAsMoney( copper = 0 ){
		copper = parseInt(copper);
		if( copper < 1 )
			return;

		const exch = Player.calculateMoneyExhange(copper);
		for( let i in exch ){
			if( !exch[i] )
				continue;
			const asset = glib.get(Player.currencyWeights[i], 'Asset');
			asset._stacks = exch[i];
			this.addAsset(asset);
		}

	}

	canExchange(){

		const labels = Player.currencyWeights.slice(1);
		for( let asset of this.assets ){
			if( ~labels.indexOf(asset.label) && asset._stacks >= 10 )
				return true;
		}

	}



	/* Leveling & Experience */
	getExperienceUntilNextLevel(){
		if( this.level === 1 )
			return 4;
		
		return Math.ceil(1+this.level*2+Math.pow(this.level,2.5));
	}

	// NPC kills
	getExperienceWorth(){
		return Math.ceil(this._difficulty*this.level/4);
	}

	// adds experience and returns levels gained
	addExperience( points ){

		if( !points )
			console.error("Invalid points to addexperience: ", points);

		points = points*this.getGenericAmountStatMultiplier(Effect.Types.expMod, this);

		if( isNaN(points) ){

			console.error("Trying to add NaN experience");
			return false;

		}

		if( Math.random() < points-Math.floor(points) )
			++points;

		points = Math.floor(points);
		this.experience += Math.floor(points);
		
		if( this.level === Player.MAX_LEVEL )
			this.experience = 0;
		
		let startLevel = this.level;
		while( this.experience >= this.getExperienceUntilNextLevel() ){
			this.experience -= this.getExperienceUntilNextLevel();
			++this.level;
			if( this.level === Player.MAX_LEVEL ){
				this.experience = 0;
				break;
			}
		}
		game.ui.addText( this.getColoredName()+" gained "+points+" experience!", undefined, this.id, this.id, 'important statMessage' );

		

		let levelsGained = this.level-startLevel;
		if( levelsGained ){
			
			this.addActionsForClass();
			game.onPlayerLevelup(this, levelsGained);

		}

		if( !this.actionSlotsFull() ){

			const n = this.getNrFreeActionSlots();
			game.ui.addText( this.getColoredName()+" has "+n+" free action slot"+(n === 1 ? '' : 's')+"! Visit a gym to learn new actions!", undefined, this.id, this.id, 'important statMessage' );

		}

		return levelsGained;
	}







	/* RESOURCES */
	addAP( amount, fText = false ){

		if( this.isAPDisabled() )
			return false;

		if( isNaN(amount) ){

			console.error("AP amount is NaN", amount);
			return false;

		}

		const pre = this.ap;
		this.ap += amount;
		this.ap = Math.floor(Math.max(0, Math.min(this.getMaxAP(), this.ap)));
		if( fText && this.ap-pre !== 0 )
			game.ui.floatingCombatText(this.ap-pre, this, "ap");
		
	}

	addMP( amount, fText = false ){

		if( this.isMPDisabled() )
			return false;

		if( isNaN(amount) ){

			console.error("MP amount is NaN", amount);
			return false;

		}

		const pre = this.mp;
		this.mp += amount;
		this.mp = Math.floor( Math.max(0, Math.min(this.getMaxMP(), this.mp)) );

		if( fText && this.mp-pre !== 0 )
			game.ui.floatingCombatText(this.mp-pre, this, "mp");

	}

	addThreat( playerID, amount ){
		if( typeof playerID !== "string" ){
			console.error("Can't add non-string player threat, received:", playerID);
			return;
		}
		if( !this._threat.hasOwnProperty(playerID) )
			this._threat[playerID] = 0;
		this._threat[playerID] += amount;		
	}

	// min amount of 1
	getPlayerThreat( player ){
		let thr = 1;
		if( this._threat[player.id] > 0 )
			thr = this._threat[player.id];
		return thr;
	}

	// Adds block. Returns the amount added/subtracted
	addBlock( amount, type ){

		let pre = this.getBlock(type);
		if( isNaN(pre) )
			throw 'Invalid type passed to block: '+type;

		amount = parseInt(amount);
		if( isNaN(amount) )
			throw 'Invalid value passed to block: '+amt;

		// Damage
		if( amount < 0 ){

			let n = this['bl'+type]+amount;
			if( n < 0 ){	// We went below 0, and have to remove from incoming block too
				this['bl'+type] = 0;
				this['ibl'+type] = Math.max(0, this['ibl'+type]+n);
			}
			else
				this['bl'+type] = n;

		}
		// ADD
		else{

			if( game.getTurnPlayer() === this )
				this['bl'+type] += amount;
			else
				this['ibl'+type] += amount;

		}
		
		return this.getBlock(type)-pre;

	}

	getBlock( type ){
		return this['bl'+type] + this['ibl'+type];
	}

	// Returns an object with {died:(bool)died, hp:(int)hp_damage, blk:(int)amount_blocked/defended}.
	// IgnoreBlock attacks HP directly if damage. Or copies healing into block if beneficial.
	addHP( amount, sender, effect, dmgtype, ignoreBlock, fText = false ){

		if( this.isHPDisabled() )
			return false;

		if( isNaN(amount) ){

			console.error("HP amount is NaN", amount);
			return false;

		}

		let out = {died:false, hp:0, blk:0};

		let pre = this.hp;
		let prehp = this.hp;
		let wasDead = this.hasTag(stdTag.dead);

		// Taking damage
		if( dmgtype ){
			
			let shield = this.getBlock(dmgtype);
			pre += shield;
			if( amount < 0 && !ignoreBlock ){

				out.blk = this.addBlock(amount, dmgtype);	// Add the full amount to shield first. addBlock caps to 0
				amount += shield;	// Amount is negative, so add the shield
				amount = Math.min(0, amount);		// Min because neg

				
			}
			else if( amount > 0 && ignoreBlock ){

				this.addBlock(amount, Action.Types.arcane);
				this.addBlock(amount, Action.Types.physical);
				this.addBlock(amount, Action.Types.corruption);
				out.blk = amount;

			}

		}

		this.hp += amount;
		this.hp = Math.floor( Math.max(0, Math.min(this.getMaxHP(), this.hp)) );

		let post = this.hp;
		if( dmgtype )
			post += this.getBlock(dmgtype);

		// Out of combat HP damage can occur, but players can't go under 1. Use SET HP instead if you want to kill someone through an RP.
		if( !game.battle_active && this.hp <= 0 )
			this.hp = 1;

		out.hp = this.hp-prehp;

		if( fText && post-pre !== 0 )
			game.ui.floatingCombatText(Math.abs(out.hp) + (out.blk ? '('+Math.abs(out.blk)+')' : ''), this, "hp");

		
		
		if( this.hp === 0 && !wasDead ){

			this.onDeath( sender, effect );

			if( this.hp === 0 )
				out.died = true;

		}

		return out;

	}

	addArousal( amount, fText = false, force = false ){

		if( this.isArousalDisabled() && !force )
			return false;
		if( this.isOrgasming() && !force )
			return;
		if( isNaN(amount) )
			return console.error("Invalid amount of arousal", amount);
			
		const pre = this.arousal, max = this.getMaxArousal();
		this.arousal += amount;
		this.arousal = Math.floor( Math.min(max, Math.max(0, this.arousal)) );

		// Out of combat arousal can occur, but players are limited to max-1. Use SET arousal instead if used in an RP.
		if( !game.battle_active && amount > 0 && this.arousal >= max )
			this.arousal = max-1;

		if( this.arousal >= max && pre < max ){

			glib.get("overWhelmingOrgasm", "Wrapper").useAgainst(this, this, false);
			game.save();
			game.ui.draw();

		}

		if( fText && this.arousal-pre !== 0 )
			game.ui.floatingCombatText(this.arousal-pre, this, "arousal");

	}


	fullRegen(){
		this.hp = this.getMaxHP();
	}

	getMaxHP(){
		return Math.max(Math.ceil(
			(BASE_HP+this.getGenericAmountStatPoints(Effect.Types.maxHP))
			*this.getPowerMultiplier()
			*this.hpMulti
			*this.getGenericAmountStatMultiplier(Effect.Types.maxHP, this)
		), 1);
	}
	getMaxAP(){
		return Math.round(
			Math.max(
				(BASE_AP+this.getGenericAmountStatPoints(Effect.Types.maxAP))
				*this.getPowerMultiplier()
				*this.getGenericAmountStatMultiplier(Effect.Types.maxAP, this)
				, 1
			)
		);
	}
	getMaxMP(){
		return Math.ceil(
			Math.max(
				(BASE_MP+this.getGenericAmountStatPoints(Effect.Types.maxMP))
				*this.getPowerMultiplier()
				*this.getGenericAmountStatMultiplier(Effect.Types.maxMP, this)
			, 1)
		);
	}
	getMaxArousal(){
		return Math.ceil(Math.max(3, 
			(BASE_AROUSAL+this.getGenericAmountStatPoints(Effect.Types.maxArousal))
			*this.getGenericAmountStatMultiplier(Effect.Types.maxArousal, this)
		));
	}
	// returns a random chance between 0 and 1
	getCritDoneChance( targ ){

		// 10% baseline chance. Only affects actions with the crit flag set
		// critDoneMod and critTakenMod are ADDITIVE
		let out = 0.1+this.getGenericAmountStatPoints(Effect.Types.critDoneMod, targ);
		if( targ instanceof Player )
			out += targ.getGenericAmountStatPoints(Effect.Types.critTakenMod, this);
		return out;

	}

	// Gets damage multiplier
	getCritDoneMod( target ){
		return this.getGenericAmountStatMultiplier(Effect.Types.critDmgDoneMod, target);
	}

	getCritTakenMod( sender ){
		return this.getGenericAmountStatMultiplier(Effect.Types.critDmgDoneMod, sender);
	}



	/* STATS */
	getPowerMultiplier(){

		let out = this.power;
		if( this.power < 0 )
			out = game.dungeon.getDifficulty()*(Math.abs(this.power));
		
		// 0 power becomes 1 for legacy reasons
		if( out === 0 )
			out = 1;
		if( out < .1 )
			return .1;
		return this.power;

	}

	// Effect in these methods are only included to prevent recursion
	// SV Types
	getSV( type ){

		let grappled = 0;
		if( type === Action.Types.physical )
			grappled = this.getGrappledBy().length ? -4 : 0;

		return Math.floor(
			(
				this.getGenericAmountStatPoints('sv'+type)+
				this.getLevel()+
				(this.class ? this.class['sv'+type] : 0)+
				(!isNaN(this['sv'+type]) ? this['sv'+type] : 0)+
				grappled
			)*this.getGenericAmountStatMultiplier('sv'+type, this)
		);
	}

	// Bon types
	getBon( type ){

		let grappled = 0;
		if( type === Action.Types.physical )
			grappled = this.getGrappledBy().length ? -4 : 0;

		return Math.floor(
			(
				this.getGenericAmountStatPoints('bon'+type)+
				this.getLevel()+
				(this.class ? this.class['bon'+type] : 0)+
				(!isNaN(this['bon'+type]) ? this['bon'+type] : 0)+
				grappled
			)*this.getGenericAmountStatMultiplier('bon'+type, this)
		);

	}

	// Returns the sum of effect.data.amount of an effect with type, and that aren't multiplicative
	getGenericAmountStatPoints( type, player ){

		let w = this.getActiveEffectsByType(type),
			out = 0
		;

		for(let effect of w){

			if( effect.data.multiplier )
				continue;

			if( player && effect.data.casterOnly && player.id !== effect.parent.caster )
				continue;

			let n = Calculator.run(
				effect.data.amount, 
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out += n*(effect.no_stack_multi ? 1 : effect.parent.stacks);

		}

		// Effects that should allow a floating point number
		const ALLOW_FLOAT = [
			Effect.Types.critDoneMod,
			Effect.Types.critTakenMod,
		]
		
		if( ALLOW_FLOAT.includes(type) )
			return out;
		
		return Math.round(out);
		
	}

	// Player is only used when checking caster_only, and should be the target
	// Auto checks effects with a conditions property
	getGenericAmountStatMultiplier( type, player ){
		let w = this.getActiveEffectsByType(type),
			out = 1
		;

		// The effect might have a setting to make it a flat stat, or multiply. Multiply being off by default.
		// Some effects are ALWAYS multiplicative, so they can be included here
		const ALWAYS_MULTIPLY = [
			Effect.Types.critDoneMod,
			Effect.Types.expMod,
			Effect.Types.regenAP,
		];
		
		const evt = new GameEvent({
			sender : this,
			target : player,
		});
		for( let effect of w ){

			if( !effect.data.multiplier && !ALWAYS_MULTIPLY.includes(type) )
				continue;

			if( player ){

				if( effect.data.casterOnly && player.id !== effect.parent.caster )
					continue;

				if( Array.isArray(effect.data.conditions) ){

					evt.effect = effect;
					evt.wrapper = effect.parent;
					if( !Condition.all(effect.data.conditions, evt) )
						continue;

				}

			}


			let n = Calculator.run(
				effect.data.amount, 
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);

			out *= ((n-1)*(effect.no_stack_multi ? 1 : effect.parent.stacks)+1);
			
		}

		return out;
	}

	getArmorPoints( modified = true ){

		let out = this.armor;
		const slots = [Asset.Slots.lowerBody, Asset.Slots.upperBody];

		for( let slot of slots ){

			let gear = this.getEquippedAssetsBySlots(slot);
			if( gear.length )
				out += gear[0].getArmorPoints();

		}

		if( modified ){

			out += this.getGenericAmountStatPoints(Effect.Types.globalArmorMod);
			out *= this.getGenericAmountStatMultiplier(Effect.Types.globalArmorMod);

		}

		return Math.min(100, Math.max(0, out));

	}

	// Returns a multiplier against damage based on armor, utilizes sender armor penetration if sender is set
	getArmorDamageMultiplier( sender, effect ){

		let reduction = this.getArmorPoints();

		// If sender is present, lower by the sender's armor penetration
		if( sender ){

			// Get armor penetration percentage
			let armorPen = sender.getGenericAmountStatPoints(Effect.Types.globalArmorPen, this)/100;
			// Reduce damage reduction by armor pen
			reduction *= (1-armorPen);
			
		}

		// If effect is present, see if it has the armor_pen value
		if( effect && effect?.data?.armor_pen ){

			// Armor penetration from effects is separate to other effects and multiplied against those, rather than additive which the base effect is
			let armorPen = 1.0-effect.data.armor_pen;
			if( isNaN(armorPen) )
				armorPen = 1.0;

			reduction *= armorPen;

		}

		return 1-reduction/100;

	}
	
	// Takes an attack type and returns a proc chance multiplier
	getStatProcMultiplier( stat, recipient = false){

		let out = 1;
		recipient = Boolean(recipient);
		const effects = this.getActiveEffectsByType(stat.toLowerCase()+'ProcMultiplier');
		for( let effect of effects ){
			if( typeof effect.data.receive === "boolean" && effect.data.receive !== recipient )
				continue;
			const n = Calculator.run(
				effect.data.amount,
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out *= (n*(effect.no_stack_multi ? 1 : effect.parent.stacks));
		};
		return out;

	}

	getHealAggroMultiplier( recipient = false){

		let out = 1;
		const effects = this.getActiveEffectsByType(Effect.Types.healAggroMultiplier);
		for( let effect of effects ){
			if( typeof effect.data.receive === "boolean" && effect.data.receive !== recipient )
				continue;
			const n = Calculator.run(
				effect.data.amount,
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out *= (n*(effect.no_stack_multi ? 1 : effect.parent.stacks));
		};
		return out;

	}




	/* Actions */
	addDefaultActions(){

		// Don't add default actions in the editor
		if( !window.game )
			return;

		const evt = new GameEvent({sender:this, target:this});
		let lib = Object.values(glib.getFull('Action')).filter(el => el.std && Condition.all(el.std_conds, evt));
		for( let action of lib ){

			if(!this.getActionByLabel(action.label))
				this.actions.unshift(action.clone(this));

		}

		this.rebindWrappers();

	}

	addActionFromLibrary( label ){

		let asset = glib.getFull('Action')[label];
		if( !asset ){
			console.error("Invalid library asset", label);
			return false;
		}
		return this.addAction(asset);

	}

	addAction( action, silent = false ){

		if( !action ){
			console.error("Invalid action add", action);
			return false;
		}
		if( this.getLearnedActionByLabel(action.label) ){
			console.error("Action already learned");
			return false;
		}

		let ac = action.clone(this);
		this.actions.push(ac);
		if( !ac.hidden && !silent )
			game.ui.addText( this.getColoredName()+" learned "+ac.name+"!", undefined, this.id, this.id, 'actionLearned' );
		

		if( !this.actionSlotsFull() && !action.std ){
			this.activateAction(ac.id);
		}

		this.rebindWrappers();

		return true;
	}

	getNrFreeActionSlots(){

		const total = this.getNrActionSlots();
		let occupied = 0;
		for( let action of this.actions ){

			if( !action.std && action._slot > -1 )
				++occupied;
				
		}
		return total-occupied;

	}

	actionSlotsFull(){
		return this.getNrFreeActionSlots() <= 0;
	}

	getActionAtSlot( slot ){

		for( let action of this.actions ){
			if( !action.std && action._slot === slot )
				return action;
		}

	}

	activateAction( id, slot ){
		
		// Doesn't need to be activated if we auto learn. Otherwise this causes issues in the npc generator
		if( this.auto_learn )
			return;

		if( id instanceof Action )
			id = id.id;

		if( this.actionSlotsFull() )
			throw "Action slots are full. Disable one first.";

		

		slot = parseInt(slot);
		if( isNaN(slot) ){

			for( let i=0; i<this.getNrActionSlots(); ++i ){

				if( !this.getActionAtSlot(i) ){
					slot = i;
					break;
				}

			}

		}

		this.deactivateAction(id);
		const action = this.getLearnedAction(id);
		if( !action )
			throw "Trying to activate nonfound action";
		
		if( slot < 0 || isNaN(slot) )
			throw "Out of bounds error on action activation: "+slot;


		action._slot = slot;
		
		this.rebindWrappers();

		return true;

	}

	deactivateAction( id ){

		// Disable an action
		const action = this.getLearnedAction(id);
		if( action )
			action._slot = -1;

		this.rebindWrappers();

	}

	toggleAction( id ){
		
		if( !this.getLearnedAction(id) )
			throw 'Action not found: '+id;
		if( this.isActionActive(id) )
			this.deactivateAction(id);
		else
			this.activateAction(id);

		return true;

	}

	

	// Gets an action from the action array by id, regardless of if it's active or not
	getLearnedAction( id ){

		for( let action of this.actions ){
			if( action === id || action.id === id )
				return action;
		}
		return false;

	}

	// Same as above but checks label
	getLearnedActionByLabel( label ){

		for( let action of this.actions ){

			if( action.label === label )
				return action;

		}

	}

	

	isActionActive( id ){

		const action = this.getLearnedAction(id);
		if( !action )
			return false;

		return action._slot > -1;

	}

	getInactiveActions(){

		const out = [];
		for( let action of this.actions ){
			if( !action.std && !this.isActionActive(action.id) )
				out.push(action);
		}
		return out;

	}

	// Gets actions that can be seen with clairvoyance
	getClairvoyanceActions(){

		return this.getActions().filter(action =>
			!action.hidden && !action.no_clairvoyance
		);

	}

	// Checks effects whether an action is enabled.
	isActionEnabled( action ){
		
		const a = action;
		if( typeof action === "string" ){
			action = this.getActionByLabel(a);
			if( !action )
				action = this.getActionById(a);
		}
		if( !action ){
			console.error("Action not found", a);
			return false;
		}

		// Action is considered enabled if it's tied to an action slot, or the player is auto learn, or the action is std, or not directly tied to this player. Such as an item or a wrapper
		return ~action._slot || this.auto_learn || action.std || action.parent !== this;

	}

	// Returns disable EFFECTs that cause the supplied action not to be enabled to this player
	getDisableActionEffects(){
		return this.getActiveEffectsByType(Effect.Types.disableActions);
	}

	removeActionById( id ){
		for( let i in this.actions ){
			let action = this.actions[i];
			if( action.id === id ){
				this.actions.splice(i, 1);
				return true;
			}
		}
		return false;
	}

	// Tries to update actions from database, you should not do this if you've modified actions via the console or spell editor
	refetchActions( std_only = false ){

		let lib = glib.getFull('Action');

		const add = [];
		const actions = this.actions.slice();
		for(let i in actions ){

			const action = actions[i];
			if( !action.std && std_only )
				continue;
			
			if( lib[action.label] ){

				console.debug("Rebasing action", action.label, "with", lib[action.label]);
				this.removeActionById(action.id);
				add.push(lib[action.label]);
				//this.actions[i] = lib[action.label].clone(this);

			}

		}

		for( let a of add ){
			this.addAction(a, true);
		}


	}

	getActionByLabel(label){

		let actions = this.getActions();
		for( let action of actions ){

			if(action.label === label)
				return action;

		}
		return false;

	}

	// If include_items is 'e' it only includes equipped items
	getActions( include_items = true, include_non_learned = false, include_temp = true, sort_result = true ){
		
		let out = this.actions.slice();
		
		if( include_items ){

			for( let asset of this.assets ){

				let action = asset.use_action;
				if( !asset.isConsumable )
					console.error("Invalid asset", asset, "in player inventory", this);
				if( asset.isConsumable() && (asset.equipped || include_items !== 'e') )
					out.push(action);

			}

		}
		
		// Filter out nonenabled
		if( !this.auto_learn && !include_non_learned )
			out = out.filter(el => this.isActionEnabled(el));
		
		// Temp actions shouldn't be filtered
		if( include_temp )
			out = out.concat(this.getTempActions());

		if( sort_result ){

			const alwaysFirst = ['stdAttack', 'stdArouse'];
			out.sort((a,b) => {

				const aConsumable = Boolean(a.parent.use_action);
				const bConsumable = Boolean(b.parent.use_action);
				const aName = aConsumable ? a.parent.name : a.name;
				const bName = bConsumable ? b.parent.name : b.name;
				const aIsStd = alwaysFirst.includes(a.label);
				const bIsStd = alwaysFirst.includes(b.label);
				
				// nonconsumable first
				if( aConsumable !== bConsumable )
					return bConsumable ? -1 : 1;

				// Then std
				if( aIsStd !== bIsStd )
					return aIsStd ? -1 : 1;

				// Then positive slots
				if( (a._slot >= 0) !== (b._slot >= 0) )
					return a._slot >= 0 ? -1 : 1;


				const acd = a.getCooldown(), bcd = b.getCooldown();

				// Then sort on spell slot
				if( a._slot !== b._slot )
					return a._slot < b._slot ? -1 : 1;

				// Lower cooldown second
				if( acd !== bcd )
					return acd < bcd ? -1 : 1;
				// Finally name
				return aName < bName ? -1 : 1;

			});

		}
		
		return out;

	}

	// Rebuilds temp actions
	resetTempActions(){
		this._tmp_actions = [];
		this.getTempActions();
	}
	// Gets temporary actions such as actions granted from effects
	getTempActions(){
		
		// Nonhost gets this from the host
		if( game && !game.is_host && Game.net.isInNetgame() ){
			return this._tmp_actions;	
		}
		
		const ids = {};
		const scanned = {};
		for( let a of this._tmp_actions )
			ids[a.label] = true;

		const effects = this.getActiveEffectsByType(Effect.Types.addActions);
		for( let effect of effects ){

			const actions = Action.loadThese(effect.data.actions, this);
			for( let action of actions ){

				scanned[action.label] = true;
				if( !ids[action.label] ){

					ids[action.label] = true;
					action.g_resetID();
					action._slot = -2;			// TMP action gets assigned -2
					this._tmp_actions.push(action);

				}

			}

		}
		
		// Remove missing ones
		for( let i =0; i<this._tmp_actions.length && this._tmp_actions.length; ++i ){

			const action = this._tmp_actions[i];
			if( !scanned[action.label] ){

				this._tmp_actions.splice(i, 1);
				--i;

			}

		}

		return this._tmp_actions;

	}

	getActionById( id ){

		let actions = this.getActions();
		for( let action of actions ){

			if( action.id === id )
				return action;

		}
		return false;

	}

	useActionId( id, targets, netPlayer ){

		let action = this.getActionById(id);
		if( action ){
			const out = action.useOn(targets, false, netPlayer);
			return out;
		}
		console.error("Action missing", id, "in", this);
		return false;

	}

	useActionLabel( label, targets ){
		
		let action = this.getActionByLabel(label);
		if( action )
			return action.useOn(targets);
		return false;
		
	}

	// Adds auto unlock actions for your class
	addActionsForClass( silent ){
		
		let lib = Object.values(glib.getFull("ActionLearnable"));
		for( let a of lib ){

			if( !a.auto_learn || this.getActionByLabel(a.action) || !a.validate(this) )
				continue;

			const action = a.getAction();
			if( !action )
				continue;
			this.addAction(action, silent);
		

		}


	}

	// Returns ActionLearnable objects that can be unlocked by this player
	getUnlockableActions(){

		let out = [];
		let lib = Object.values(glib.getFull("ActionLearnable"));
		for( let a of lib ){

			if( a.auto_learn || this.getLearnedActionByLabel(a.action) )
				continue;
			if( a.validate(this) )
				out.push(a);

		}

		return out;

	}
	
	getNrActionSlots(){

		if( this.level < 3 )
			return this.level;
		return Player.getActionSlotsForLevel(this.level);	// 3 unlocked by default, then at 4, 7, 10

	}

	getNrPassiveSlots(){
		if( this.level < 5 )
			return 0;
		if( this.level >= 10 )
			return 4;
		return Math.min(4, Math.ceil((this.level-2)/3));
	}

	// Checks encumberance
	updateAutoWrappers(){

		this.auto_wrappers = [];
		if( this.isEncumbered() )
			this.auto_wrappers.push(new Wrapper({
				label : '_encumbered_',
				name : 'Encumbered',
				icon : 'encumbered.svg',
				description : 'You are carrying too much. All hit chance reduced by 50%',
				duration : -1,
				victim : this.id,
				caster : this.id,
				tags : [stdTag.wrEncumbered],
				effects : [
					new Effect({
						type : Effect.Types.globalHitChanceMod,
						data : {amount : -0.5}
					})
				]
			}, this));

	}

	// Activates cooldowns by labels
	consumeActionCharges( labels, charges = 1 ){
		if( !Array.isArray(labels) )
			labels = [labels];

		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action ){
				action.consumeCharges(charges);
			}
		}
	}

	// Adds action charges by labels
	addActionCharges( labels, charges = 1 ){
		if( !Array.isArray(labels) )
			labels = [labels];
		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action )
				action.consumeCharges(-charges);
		}
	}

	// Adds action cooldowns by labels
	addActionCooldowns( labels, amount ){
		if( !Array.isArray(labels) )
			labels = [labels];
		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action )
				action.addCooldown(amount);
		}
	}

	// returns an array of charged actions or false if none. You can supply your own actions array to prevent recursion or check specific actions. 
	isCasting( actions ){

		if( !actions )
			actions = this.getActions();

		let spells = [];
		for( let action of actions ){
			if( action._cast_time > 0 )
				spells.push(action);
		}
		if( spells.length )
			return spells;
		return false;

	}

	// Returns nr actions interrupted successfully
	interrupt( sender, force = false ){
		
		let actions = this.isCasting();
		if( !actions )
			return 0;
		let out = 0;
		for( let action of actions ){
			if( action.interrupt(sender, force) )
				++out;
		}
		return out;
	}

	// Checks the allowReceiveSpells effect
	checkActionFilter( sender, action ){
		if( !(action instanceof Action) ){
			console.error("Action", action, "is not an action");
			return false;
		}
		const effects = this.getActiveEffectsByType(Effect.Types.allowReceiveSpells);
		const evt = new GameEvent({action:action, sender:sender, target:this});
		for( let effect of effects ){
			evt.effect = effect;
			if( !Condition.all(effect.data.conditions, evt) )
				return false;
		}
		return true;
	}

	// Checks if this doesn't have the untargetable effect against an action
	hasTargetableForAction( action ){

		if( !(action instanceof Action) )
			throw 'Trying to check untargetable against non action';

		// Self cast always allowed
		if( action.parent === this )
			return true;

		let effects = this.getActiveEffectsByType( Effect.Types.untargetable );
		// No effects
		if( !effects.length )
			return true;

		let disallowFriendly = effects.filter(el => !el?.data?.beneficial).length;
		// Allow friendly actions through if all effects have allow friendly
		if( !disallowFriendly && !action.detrimental )
			return true;
		
		// Check if at least one has the action label
		for( let effect of effects ){
			
			let arr = effect?.data?.exceptions;
			if( !arr )
				continue;
			arr = toArray(arr);
			if( arr.includes(action.label) )
				return true;

		}


		return false;

	}


	/* Wrappers */
	// Force lets you override cache, if unequipped is true, it also uses asset-attached wrappers that aren't equipped
	getWrappers( force = false, unequipped = false ){

		if( !window.game )
			return [];

		if( game._caches && this._cache_wrappers && !force )
			return this._cache_wrappers;

		const evt = new GameEvent({
			target : this,
			sender: this,
			dungeon : game.dungeon,
		});

		let out = this.wrappers
			.filter(el => {
				if( !el.asset || unequipped )
					return true;
				const asset = this.getAssetById(el.asset); 
				return asset && asset.equipped;
			})
			.concat(
				this.passives, 
				game.encounter.passives.filter(el => {

					return Condition.all(el.add_conditions || [], evt);

				})
				.map(el => { 
					/*
					el = el.clone();
					el.caster = '';
					el.victim = this.id;
					*/
					el.caster = this.id;
					el.victim = this.id;
					return el;

				})
			);

		for( let asset of this.assets ){

			if( asset.equipped ){

				if( asset.durability > 0 )
					out = out.concat(asset.wrappers);

			}

		}

		// Note: temp actions can't have passives for recursion reasons
		const actions = this.getActions(true, false, false, false);
		for( let action of actions )
			out = out.concat(action.passives);

		let casting = this.isCasting( actions );
		if( casting ){

			for( let c of casting )
				out = out.concat(c.cpassives);

		}

		const ret = out.concat(this.auto_wrappers);
		if( game._caches )
			this._cache_wrappers = ret;

		return ret;

	}

	getWrapperByLabel( label ){
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){

			if( wrapper.label === label )
				return wrapper;

		}
	}

	getActiveEffectsByType( type ){
		
		return this.getEffects().filter(fx => {
			return (fx.type === type && (!this._ignore_effects || this._ignore_effects.indexOf(fx) === -1));
		});

	}

	removeWrapper( wrapper ){

		for(let i in this.wrappers){

			if( this.wrappers[i] === wrapper ){

				this.wrappers.splice(i, 1);
				this.rebindWrappers();
				return true;

			}

		}
		return false;

	}

	// Wrappers that shouldn't be added. Returns an array.
	getBlockedWrappers(){
		
		let effects = this.getActiveEffectsByType(Effect.Types.preventWrappers);
		let blocked = {};
		for( let effect of effects ){

			if( effect.data.labels ){

				let labels = toArray(effect.data.labels);
				for( let label of labels )
					blocked[label] = true;

			}

		}
		return Object.keys(blocked);

	}

	// Use Wrapper.useAgainst, not this
	// Also see rebindWrappers for ignoreStayCheck
	addWrapper( wrapper, ignoreStayCheck = false ){

		wrapper.parent = this;
		this.wrappers.push(wrapper);
		this.handleWrapperStun(wrapper);
		this.rebindWrappers(ignoreStayCheck);

	}

	handleWrapperStun( wrapper ){

		let isStun = wrapper.getEffects({ type:Effect.Types.stun });
		if( 
			isStun.length && 
			wrapper.duration > 0 && 
			(!isStun[0].data || !isStun[0].data.ignoreDiminishing) 
		)this._stun_diminishing_returns += wrapper._duration*2;
		
		if( isStun.length )
			this.interrupt( wrapper.getCaster(), true );

	}

	getActiveWrappersWithTag(...tags){
		return this.getWrappers().filter(wrapper => {
			return wrapper.hasTag(tags);
		});
	}

	// overWhelmingOrgasm triggered from max arousal
	isOrgasming(){
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){
			if( wrapper.label === "overWhelmingOrgasm" ){
				return true;
			}
		}
	}

	// Makes sure passives have the right ID
	updatePassives(){

		for( let passive of this.passives ){

			passive.caster = passive.victim = this.id;
			passive.parent = this;
			passive.bindEvents();

		}

	}

	removePassive( wrapper ){

		wrapper.unbindEvents();
		let pos = this.passives.indexOf(wrapper);
		if( pos > -1 )
			this.passives.splice(pos, 1);

	}

	addPassive( wrapper ){

		if( typeof wrapper === 'string' )
			wrapper = glib.get(wrapper, 'Wrapper');

		if( !(wrapper instanceof Wrapper) ){
			console.error("Invalid passive", wrapper);
			throw 'Trying to add non-wrapper';
		}

		this.passives.push(wrapper.clone());
		this.updatePassives();

	}

	
	/* Effects */
	// Gets all effects (effects on other players may affect you if the target is you or AoE)
	getEffects( force = false ){

		if( !window.game )
			return [];

		if( game._caches && this._cache_effects && !force )
			return this._cache_effects;

		

		let out = new Map();
		for( let player of game.getEnabledPlayers() ){
			
			const wrappers = player.getWrappers();

			for( let wrapper of wrappers ){

				const effects = wrapper.getEffectsForPlayer(this);
				for( let effect of effects )
					out.set(effect, true);

			}

		}

		out = Array.from(out.keys());
		if( game._caches )
			this._cache_effects = out;

		return out;

	}	
	getDisabledLevel(){
		let level = 0;
		const effects = this.getActiveEffectsByType(Effect.Types.disable);
		for( let effect of effects ){
			let lv = effect.level;
			if( isNaN(lv) )
				lv = 1;
			if( lv > level )
				level = lv;
		}
		return level;
	}
	// Returns true if any of the disabled effects triggers it
	getDisabledHidden(){
		const effects = this.getActiveEffectsByType(Effect.Types.disable);
		for( let effect of effects ){
			if( effect.data.hide )
				return true;
		}
	}

	isHealInverted(){
		return this.getActiveEffectsByType(Effect.Types.healInversion).length;
	}

	isInterruptProtected(){
		return this.getActiveEffectsByType(Effect.Types.blockInterrupt).length;
	}



	/* CHATS */
	onChatUsed( id ){

		this._used_chats[id] = true;

		if( !game.battle_active )
			this._last_chat = Date.now();
		else
			this._last_chat = game.totTurns;

	}

	hasUsedChat( id ){
		return this._used_chats[id];
	}
	// Checks if this NPC has chatted too recently
	canOptionalChat(){

		if( !game.battle_active )
			return ( Date.now()-this._last_chat > 3000 );	// Max 3 sec when out of combat

		let turnsSinceLastSpoke = game.totTurns-this._last_chat;
		return Math.random() < turnsSinceLastSpoke*Math.pow(this.talkative, 2);

	}


	// Bot
	autoPlay( force ){

		if( !this.isNPC() && !force )
			return;
		this.bot.play( force );

	}

	usePunishment( players, force ){
		
		if( !this.isNPC() && !force )
			return;
		this.bot.punish(players);

	}
	


	// Static
	static getActionSlotsForLevel( level ){
		return Math.min(this.MAX_ACTION_SLOTS, Math.floor((level-4)/3)+4);
	}
	static getLevelForActionSlot( index ){

		// First 3 slots are unlocked immediately
		if( index < 3 )
			return 1;
		
		return 4+Math.floor((index-3)*3);

	}

	// Returns a value where <= 0 = always miss, and >= 100 = always hit
	static getHitChance( attacker, victim, action ){

		if( attacker.id === victim.id )
			return 100;
		if( !action.detrimental )
			return 100;
		if( action.hit_chance > 100 )
			return 100;

		let out = action.hit_chance;
		let modifier = (1+((attacker.getBon(action.type)-victim.getSV(action.type))*0.05))
			*attacker.getGenericAmountStatMultiplier(Effect.Types.globalHitChanceMod, victim)
		;
		if( modifier < 0.1 )
			modifier = 0.1;

		// Hit chance above 100 is set as "always hit"
		return Math.max(10, Math.round(out*modifier+attacker.getGenericAmountStatPoints(Effect.Types.globalHitChanceMod, victim)));

	};


	static getAdvantage( attacker, victim, stat, detrimental ){

		let tot = attacker.getBon(stat);
		if( detrimental )
			tot -= victim.getSV(stat);
		return tot;

	};

	// Returns a multiplier of 4% if you go over 100% hit chance
	static getBonusDamageMultiplier( attacker, victim, stat, detrimental ){

		let tot = this.getAdvantage(attacker, victim, stat, detrimental);

		if( tot < 0 )
			tot = 0;

		// Add 25% bonus damage per additional player
		let add = 1;
		if( attacker.team !== 0 ){

			const tp = game.getTeamPlayers().filter(pl => !pl.isNPC());
			add = 1+(tp.length-1)*0.2;
			// increase enemy damage by 20% per player

			// Reduce enemy damage at low levels
			// level 1 has -50%, level 2 has -25%
			if( attacker.level < 3 )
				add -= 0.25*(3-attacker.level);

		}

		// Each point of advantage adds 10% damage
		const out = (1+tot*0.1)*add;
		return out;

	};


	// Exchanges copper into the fewest coins possible
	// returns an array of [platinum, gold, silver, copper] after exchange. You can use Player.currencyWeights to map this to assets
	static calculateMoneyExhange( input = 0 ){
		return [
			Math.floor(input/1000),
			Math.floor((input%1000)/100),
			Math.floor((input%100)/10),
			input%10
		];
	};

	// Converts copper into an array of assets
	static copperToAssets( copper = 0 ){

		const out = [];
		const exchanged = this.calculateMoneyExhange( copper );

		for( let i in exchanged ){
			const amt = exchanged[i];
			if( amt ){
				const label = this.currencyWeights[i];
				const a = glib.get(label, 'Asset');
				a._stacks = amt;
				out.push(a);
			}
		}
		return out;

	};

	static copperToReadable( copper = 0 ){
		const coins = this.calculateMoneyExhange(copper);
		let out = [];
		for( let i in coins ){
			if( coins[i] )
				out.push(coins[i]+' '+Player.currencyWeights[i]);
		}
		if( !out.length )
			return '0 copper';
		return out.join(', ');
	};


	async exportFile(){

		const zip = new JSZip();
		zip.file(
			'player.json', 
			JSON.stringify(Player.saveThis(this, true))
		);

		const content = await zip.generateAsync({
			type:"blob",
			compression : "DEFLATE",
			compressionOptions : {
				level: 9
			}
		})
		
		const a = document.createElement('a');
		const url = URL.createObjectURL(content);

		a.setAttribute('href', url);
		a.setAttribute('download', this.name + '.fqchar');

		document.body.appendChild(a);
		a.click();
		a.remove();

		game.ui.modal.addNotice('Player exported!');

	};

	// Takes a file event, imports it, and returns a new player
	static async importFile( event ){

		const file = event.target.files[0];
		if( !file )
			return;

		const zip = await JSZip.loadAsync(file);

		let player;
		for( let path in zip.files ){

			if( path !== 'player.json' )
				continue;

			const entry = zip.files[path];
			try{

				const raw = JSON.parse(await entry.async("text"));
				if( !raw.id || !raw.name )
					throw 'INVALID_ID';
				
				player = new this(raw);
				player.g_resetID();


			}catch(err){

				let reason = "JSON Error";
				if( err === "INVALID_ID" )
					reason = 'Required parameters missing';
				alert("This is not a valid player file ("+reason+")");
				console.error(err);

			}

			break;

		}

		return player;

	};



}

Player.MAX_LEVEL = 14;

Player.TEAM_PLAYER = 0;
Player.TEAM_ENEMY = 1;

Player.MAX_ACTION_SLOTS = 6;

Player.currencyWeights = [
	'platinum',
	'gold',
	'silver',
	'copper'
];
Player.currencyColors = [
	'#FFF',
	'#FF8',
	'#AAA',
	'#FA8'
];

// Saves the last used action in a grouped action
class PlayerActionGroup extends Generic{
	
	constructor(data){
		super(data);

		this.id = '';		// group name
		this.active = 0;	// Index of active action

		this.load(data);
	}

	save(){

		const out = {
			id : this.id,
			active : this.active
		};
		return out;

	}


	load( data ){
		this.g_autoload(data);
	}

	rebase(){
		this.g_rebase();	// Super
	}


}


