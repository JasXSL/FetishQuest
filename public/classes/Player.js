import Generic from './helpers/Generic.js';
import Action from "./Action.js";
import Asset from "./Asset.js";
import stdTag from "../libraries/stdTag.js";

import { Wrapper, Effect } from './EffectSys.js';
import Bot from './Bot.js';
import PlayerClass from './PlayerClass.js';
import Calculator from './Calculator.js';
import GameEvent from './GameEvent.js';
import Dungeon from './Dungeon.js';
import Condition from './Condition.js';
import Collection from './helpers/Collection.js';
import Encounter from './Encounter.js';
import Game from './Game.js';
import Roleplay from './Roleplay.js';

const BASE_HP = 30;
const BASE_AROUSAL = 7;
const MAX_KINKS = 2;


export default class Player extends Generic{

	static BANK_SLOTS = 64;

	static getRelations(){ 
		return {
			actions : Action,
			assets : Asset,
			wrappers : Wrapper,
			passives : Wrapper,
			class : PlayerClass,
			follower : Roleplay
		};
	}

	constructor(data){

		super(data);

		this.label = '';					// Unique editor label
		this.netgame_owner_name = '';		// This is a custom thing that should only be relied on when adding a new player
		this.netgame_owner = '';			// ID corresponding to one from Game.net.players
		this.name = "Adventurer";			// Name
		this.species = "";
		this.spre = "";						// A/AN for species
		this.description = "";
		this.ior = "";						// Local override
		this.icon = "";						// URL - Has to be HTTPS
		this.icon_upperBody = "";			// == || ==
		this.icon_lowerBody = "";			// == || ==
		this.icon_nude = "";				// == || ==
		this.icon_ai = false;				// Sets if this icon was AI generated or not. Note: Host only.
		this.auto_learn = true;			// if true, this player always knows all their spells
		this.leader = false;				// Party leader
		this.generated = false;				// This was generated by an encounter, and should be purged when leaving the cell
		this.follower = null;					// Set to the label of an RP which you setup for the follower menu

		this.actions = [];			// Unlocked actions. Action objects, use getActions since assets can also add actions
		this.assets = [];			// Asset objects, use getAssets
		this.inventory = [];		// NPC only. This is an array of numbers specifying which items above are equipped when entering the game.

		this.tags = [];				// Player tags, these are automatically prefixed with PL_, use getTags
		this.wrappers = [];			// Wrappers, use getWrappers
		this.auto_wrappers = [];	// Automatic wrappers such as encumbered
		this.passives = [];			// Passive wrappers that should not be cleared when a battle starts or ends
		this.hp = BASE_HP;				// 
		
		this.momOff = 0;			// Offensive momentum
		this.momDef = 0;			// Defensive momentum
		this.momUti = 0;			// Utility momentum
		this.incMom = [];			// Incoming momentum added next turn, max 12. Items can be added to this, including -1 for random while it's not your turn.
		
		this.team = 0;				// 0 = player
		this.size = 5;				// 0-10
		this.level = 1;				// 
		this.experience = 0;
		
		this.endedTurn = false;
		this.reroll = 0;

		this.arousal = 0;
		this.armor = 0;				// 0-100. Given primarily to NPCs that can't wear armor.
		this.leveled = false;		// Level is an offset of the player average level
		this.power = 1;				// This is used in NPCs when calculating how difficult they should be. 1 = power of 1 player, can be higher or lower. -1 will automatically set it to nr players
		this.hpMulti = 1;			// Quick way to build NPCs with different HP instead of having to add a bunch of wrappers. Negative value will SET max HP to a specific value. Used for illium who loses 1 HP each turn
		this.disabled = false;		// Disable a player, ignoring drawing it and ignoring it in game methods
		this.voice = '';			// Voice kit label for pain/pleasure sounds etc

		// Use getBlock(type)
		this.block = 0;				// Blocking points of damage
		this.iBlock = 0;			// Block applied while it wasn't my turn
		this._untappedBlock = 0;		// Set on turn start and contains the value of any block wasted. Not saved.

		this.svPhysical = 0;
		this.svArcane = 0;
		this.svCorruption = 0;

		this.bonPhysical = 0;
		this.bonArcane = 0;
		this.bonCorruption = 0;
		this.bot = new Bot(this);
		this.used_punish = false;				// We have punished a target since the last battle ended or we left the room

		this.remOnDeath = false;				// Delete this player if it dies

		// Personality types
		this.talkative = 0.3;					// How often they output combat chats. Multiplied by nr turns. So after 1 turn, 0.5 = 50% chance, 2 turns = 100% etc. Setting this to one overrides the limit of one chat per turn.
		this.sadistic = 0.5;					// Normal vs Sadistic.
		this.dominant = 0.8;					// Dominant vs submissive
		this.hetero = 0.5;						// 0 = gay, 0.5 = bi, 1 = straight
		this.emotive = 0.5;						// Only used for the host. Determines the chance of triggering a combat pain sound.
		this.intelligence = 0.6;				// 0 = No intelligence, .1 = Mollusk, .2 = Animal, .4 = Child, .6 = Average human, .9 = Mastermind, 1 = Godlike
												/* Notes on intelligence:
													<= 0 = It has no intelligence and always attacks a random player, even friendly players
													< 0.2 = No longer attacks friends, but doesn't use the aggro system.
													>= 0.2 = Now able to use the aggro system, but only short term, wiping aggro at the end of their turn
													>= 0.4 = Can speak, now affected by the full aggro system
													>= 0.6 + Judging = Able to set traps, triggering at the start of a battle
													>= 0.8 = Now too smart for aggro, always picks targets carefully
												*/
		// Pronouns
		this.he = '';
		this.him = '';
		this.his = '';

		this.actionGroups = [];					// Contains PlayerActionGroup objects. Built on the fly
		
		
		this.class = null;
		this._stun_diminishing_returns = 0;		// Rounds you can't be stunned

		this._turns = 0;						// Total turns played in combat
		this._turn_ap_spent = 0;				// AP spent on actions this turn
		this._turn_action_used = 0;				// Actions used this turn
		this._threat = {};						// playerID : threatAmount

		// These are incoming damage
		this._damaging_since_last = {};			// playerID : {(str)dmageType:(int)nrDamagingAttacks} - nr damaging actions received since last turn. Not the actual damage.
		this._damage_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total damage points player received since last turn.
		// Same as above, but DONE by this player
		this._d_damaging_since_last = {};			// playerID : {(str)dmageType:(int)nrDamagingAttacks} - nr damaging actions used by this player since last turn. Not the actual damage.
		this._d_damage_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total damage points this player did since last turn.
		this._riposted_since_last = {};			// playerID : num_times_this_player_riposted_use
		this._riposting_since_last = {};		// playerID : num_times_we_riposted_them
		// Healing received
		this._healing_a_since_last = {};			// playerID : {(str)damageType:(int)nrHealingAttacks} - nr healing actions received since last turn. Not the actual damage.
		this._healing_p_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total HP player received by heals last turn
		// Healing done
		this._d_healing_a_since_last = {};			// playerID : {(str)damageType:(int)nrHealingAttacks} - nr healing actions done since last turn.
		this._d_healing_p_since_last = {};			// playerID : {(str)damageType:(int)damage} - Total healing points player did since last turn.
		
		// If an object should be netcoded, it needs to be a collection, otherwise it's passed by reference
		this._targeted_by_since_last = new Collection();			// playerID : (int)num_actions - Total actions directly targeted at you since last turn. (AoE doesn't count)
		this._used_chats = {};					// id : true - Chats used. Not saved or sent to netgame. Only exists in the local session to prevent NPCs from repeating themselves.
		this._last_chat = 0;					// Turn we last spoke on. 

		this._turn_tags = [];					// {tag:(str)tag, s:(Player)sender}... These are wiped whenever an action text is used
		
		this.color = '';						// Assigned by the game

		this.start_equip = [];					// Set on combat start. These are items you wore, that you can re-equip. Other items can't.

		// Prevents recursion for encumbrance
		this._ignore_effects = null;			// Internal helper that prevents recursion
		this._difficulty = 1;					// Added from monster template, used in determining exp rewards
		this._bound_wrappers = [];
		this._cache_tags = null;					// Holds all active tags in a cache for quicker validation
		this._cache_effects = null;					// Holds all active effects in a cache for quicker validation
		this._cache_wrappers = null;				// == || ==

		this._ignore_check_effect = new Map();	// effect : true - Another recursion preventor
		this._tmp_actions = [];					// Actions from effects and such bound to a battle
		this._debug_chat = false;				// Only stored in the session, can be used to test player chat while they're controlled by a player. Since PC controlled characters can't auto speak.
		

		this.load(data);
		
	}

	load(data){

		if( data && data.follower === null )
			data.follower = '';

		if( data && data.class === null )
			data.class = '';

		this.g_autoload(data);
		if( data?._incMom )
			this.unpackIncomingMomentum(data._incMom, true);

	}

	// Automatically invoked after g_autoload
	rebase(){

		if( !this.class )
			this.class = new PlayerClass({}, this);

		if( !this.follower )
			this.follower = new Roleplay({}, this);

		this.g_rebase();	// Super

		this._ignore_check_effect = new Map();	// Needed when cloning since clone brings all things along
		// only load tmp actions in a netgame (for ID mostly)
		//if( game && game !== true && !game.is_host && Game.net.isConnected() )
			this._tmp_actions = Action.loadThese(this._tmp_actions, this);
		
		this._targeted_by_since_last = new Collection(this._targeted_by_since_last);
		this.actionGroups = PlayerActionGroup.loadThese(this.actionGroups);

		if( window.game ){
			
			if( !game.is_host )
				this.auto_wrappers = Wrapper.loadThese(this.auto_wrappers, this);

		}
		
		this.tags = this.tags.map(tag => tag.toLowerCase());

	}

	// Data that should be saved to drive
	save( full ){

		if( window.game && game.is_host )
			this.updateAutoWrappers();

		const out = {
			auto_learn : this.auto_learn,
			disabled : this.disabled,
			name : this.name,
			icon : this.icon,
			follower : this.follower instanceof Roleplay ? Roleplay.saveThis(this.follower, full) : this.follower,
			actions : Action.saveThese(this.actions, full),
			tags : this.tags,
			team : this.team,
			species : this.species,
			spre : this.spre,
			description : this.description,
			size : this.size,
			level : this.level,
			class : this.class instanceof PlayerClass ? PlayerClass.saveThis(this.class, full) : this.class,
			svPhysical : this.svPhysical,
			svArcane : this.svArcane,
			svCorruption : this.svCorruption,
			bonPhysical : this.bonPhysical,
			bonArcane : this.bonArcane,
			bonCorruption : this.bonCorruption,
			used_punish : this.used_punish,
			leader : this.leader,
			talkative : this.talkative,
			label : this.label,
			icon_lowerBody : this.icon_lowerBody,
			icon_nude : this.icon_nude,
			icon_upperBody : this.icon_upperBody,
			power : this.power,
			hpMulti : this.hpMulti,
			passives : Wrapper.saveThese(this.passives, full),
			sadistic : this.sadistic,					// Normal vs Sadistic
			dominant : this.dominant,					// Dominant vs submissive
			hetero : this.hetero,						// 0 = gay, 0.5 = bi, 1 = straight
			intelligence : this.intelligence,
			he : this.he,
			him : this.him,
			his : this.his,
			start_equip : this.start_equip,
			generated : this.generated,	// Needed for playerMarkers in webgl
			armor : this.armor,
			actionGroups : PlayerActionGroup.saveThese(this.actionGroups),
			voice : this.voice,
			momOff : this.momOff,
			momDef : this.momDef,
			momUti : this.momUti,
		};

		if( full !== "mod" ){
			out.experience = this.experience;
			out.endedTurn = this.endedTurn;
			out.reroll = this.reroll;
		}
		// Should only be sent while we're hosting a netgame
		//if( window.game && Game.net.isInNetgameHost() && !full )
		out._tmp_actions = Action.saveThese(this._tmp_actions, full);

		// Assets are only sent if equipped, PC, or full
		out.assets = Asset.saveThese(this.assets.filter(el => 
			full || 
			(
				!el.inBank && 
				(
					el.equipped || 
					!this.isNPC() || 
					this.isDead()
				)
			)
		), full);

		if( full ){

			out.icon_ai = this.icon_ai;
			out.emotive = this.emotive;
			out.remOnDeath = this.remOnDeath;
			out.leveled = this.leveled;
			out.inventory = this.inventory;
			out.talkative = this.talkative;
			if( full !== "mod" ){
				out._stun_diminishing_returns = this._stun_diminishing_returns;
				out._difficulty = this._difficulty;
				out._threat = this._threat;
				out._turn_ap_spent = this._turn_ap_spent;
				out._damaging_since_last = this._damaging_since_last;
				out._damage_since_last = this._damage_since_last;
				out._d_damaging_since_last = this._d_damaging_since_last;
				out._d_damage_since_last = this._d_damage_since_last;
				out._turns = this._turns;
				out._turn_action_used = this._turn_action_used;
				out._riposted_since_last = this._riposted_since_last;
				out._riposting_since_last = this._riposting_since_last;
				out._healing_a_since_last = this._healing_a_since_last;
				out._healing_p_since_last = this._healing_p_since_last;
				out._d_healing_a_since_last = this._d_healing_a_since_last;
				out._d_healing_p_since_last = this._d_healing_p_since_last;
			}

		}


		// Everything except mod
		if( full !== "mod" ){
			
			out.id = this.id;
			out._incMom = this.packIncomingMomentum(true);
			out.hp = this.hp;
			out.momBon = this.momBon;
			out.block = this.block;
			out.iBlock = this.iBlock;
			out.wrappers = Wrapper.saveThese(this.wrappers, full);
			out.netgame_owner = this.netgame_owner;
			out.netgame_owner_name = this.netgame_owner_name;
			out.color = this.color;
			out.arousal = this.arousal;
			out._targeted_by_since_last = this._targeted_by_since_last.save(full);		// Needed by netcode

		}
		else
			this.g_sanitizeDefaults(out);

		return out;
	}

	// Code that's run after the game has finished loading
	initialize(){

		// Apply constraints
		this.addHP(0);
		this.addMomentum(Player.MOMENTUM.All, 0); // add 0 momentum
		this.updateAutoWrappers();
		this.addTagSynonyms();
		
		if( game.is_host ){
			this.rebindWrappers(true);
		}

		this.updatePassives();

	}

	rebindWrappers( ignoreStayCheck = false ){

		this.unbindWrappers();
		let w = this.getWrappers();	// Otherwise items not equipped might cause procs
		w.map(wrapper => {
			wrapper.bindEvents();
		});
		this._bound_wrappers = w;
		
		// Ignored when adding wrappers because wrappers may need to apply required tags before checking the conditions
		if( !ignoreStayCheck )
			Wrapper.checkAllStayConditions();

	}

	unbindWrappers(){

		for( let wrapper of this._bound_wrappers ){

			// These are bound on an encounter by encounter basis, and all players share these
			if( wrapper.parent && wrapper.parent instanceof Encounter )
				continue;
				
			wrapper.unbindEvents();

		}

	}


	uncache(){
		this._cache_tags = null;
		this._cache_effects = null;
		this._cache_wrappers = null;
	}


	/* Metadata */

	// Helper method for below to summarize
	summarizeSinceLast( obj, player, type ){

		if( player && player.constructor === Player )
			player = player.id;

		let block = obj[player];
		if( !block )
			return 0;

		let out = 0;
		for( let i in block ){

			if( i === type || type === undefined )
				out += block[i];

		}

		return out;

	}

	// For these functions, type is an Action.Types value, if undefined, it counts ALL types
	// Returns how many damaging actions a player has used since this one's last turn
	damagingSinceLastByPlayer( player, type ){
		return this.summarizeSinceLast(this._damaging_since_last, player, type);
	}
	// Returns how many healing player has used on us since last round
	healingActionsTakenSinceLastByPlayer( player, type ){
		return this.summarizeSinceLast(this._healing_a_since_last, player, type);
	}

	// Total damage taken taken since last turn from player to this
	damageSinceLastByPlayer( player, type ){
		return this.summarizeSinceLast(this._damage_since_last, player, type);
	}
	// Total healing points taken since last turn from player to this one
	healingPointsTakenSinceLastByPlayer( player, type ){
		return this.summarizeSinceLast(this._healing_p_since_last, player, type);
	}

	// Total damaging actions we've used against player
	damagingDoneSinceLastToPlayer( player, type ){
		return this.summarizeSinceLast(this._d_damaging_since_last, player, type);
	}
	// Total healing actions we've used against player
	healingActionsDoneSinceLastToPlayer( player, type ){
		return this.summarizeSinceLast(this._d_healing_a_since_last, player, type);
	}
	// Damage points this has done to player since last round
	damageDoneSinceLastToPlayer( player, type ){
		return this.summarizeSinceLast(this._d_damage_since_last, player, type);
	}
	// Healing points this has done to player since last round
	healingPointsDoneSinceLastToPlayer( player, type ){
		return this.summarizeSinceLast(this._d_healing_p_since_last, player, type);
	}

	// How many times this player has riposted me
	ripostedSinceLastByPlayer( player ){

		if( player && player.constructor === Player )
			player = player.id;
		if( !this._riposted_since_last[player] )
			return 0;
		return this._riposted_since_last[player][i];

	}
	// How many times we riposted that player
	ripostingSinceLastByPlayer( player ){

		if( player && player.constructor === Player )
			player = player.id;
		if( !this._riposting_since_last[player] )
			return 0;
		return this._riposting_since_last[player][i];

	}
	// Calculates a total number for any of the above, allowing you to filter by type 
	// Use the object property as input, and it returns the sum
	datTotal( input, type ){
		let out = 0;
		for( let i in input ){
			for( let t in input[i] ){
				if( t === type || type === undefined )
					out += input[i][t];
			}
		}
		return out;
	}

	// Used for riposte that only has one level
	datTotalShort( input ){

		let out = 0;
		for( let i in input )
			out += input[i];
		return out;

	}

	// Returns an array of enabled actions belonging to a group
	getActionGroup( group ){

		let out = [];
		const actions = this.getActions();
		for( let action of actions ){
			if( action.group === group )
				out.push(action);
		}
		return out;

	}

	// Returns a numeric index of where the current label of an action group is in its array of viable actions
	// Returns 0 if the group isn't found, or the action isn't found
	getActiveActionGroupIndex( group ){

		let actions = this.getActionGroup(group);
		let label = this.getActiveActionGroupLabel(group);
		for( let i = 0; i < actions.length; ++i ){

			if( actions[i].label === label )
				return i;

		}
		return 0;

	}

	// Action groups
	// Returns the selected action in a group
	getActiveActionGroupLabel( group ){

		const actions = this.getActionGroup(group);
		// We don't have a single action of this group. Shouldn't happen, but might as well put this here
		if( !actions.length )
			return false;
		// Search for the group
		for( let g of this.actionGroups ){

			// Found group
			if( g.id === group ){

				// Make sure the active action exists
				for( let action of actions ){

					if( action.label === g.active )
						return action.label;

				}	
				
				break;	// Can only have one entry per group, so stop trying

			}

		}

		// Didn't find a group yet (probably because we haven't used an action from this group yet).
		// Return the first action in the group
		// Otherwise the UI cocks up
		return actions[0].label;

	}
	
	// Sets
	// Was: setActiveActionGroupIndex
	// Label can be 1 or -1 to offset instead of setting. And adds or subtracts based on where the current label is
	setActiveActionGroupLabel( group, label ){

		for( let g of this.actionGroups ){

			if( g.id === group ){

				if( label === 1 || label === -1 ){

					let actions = this.getActionGroup(group);
					const length = actions.length;
					let current = this.getActiveActionGroupIndex()+label;
					if( current >= length )
						current = 0;
					else if( current < 0 )
						current = length-1;
					g.active = actions[current].label;

				}
				else
					g.active = label;
				return;

			}

		}
		// Not found
		const add = new PlayerActionGroup({
			id : group,
			active : label
		});
		this.actionGroups.push(add);

	}

	// When run from an effect, the effect needs to be present to prevent recursion 
	appendMathVars( prefix, vars, event ){

		let isRoot = this._ignore_effects === null;
		if( isRoot )
			this._ignore_effects = [];

		if( event && event.effect )
			this._ignore_effects.push(event.effect);
		// Theres a recursion here when math is used in SV/Bon and to get SV/Bon you need math
		vars[prefix+'SvPhysical'] = this.getSV(Action.Types.physical);
		vars[prefix+'SvArcane'] = this.getSV(Action.Types.arcane);
		vars[prefix+'SvCorruption'] = this.getSV(Action.Types.corruption);
		
		vars[prefix+'BonPhysical'] = this.getBon(Action.Types.physical);
		vars[prefix+'BonArcane'] = this.getBon(Action.Types.arcane);
		vars[prefix+'BonCorruption'] = this.getBon(Action.Types.corruption);
		vars[prefix+'Lv'] = this.level;
		vars[prefix+'HP'] = this.hp;
		vars[prefix+'Off'] = this.getMomentum(Player.MOMENTUM.Off);
		vars[prefix+'Def'] = this.getMomentum(Player.MOMENTUM.Def);
		vars[prefix+'Uti'] = this.getMomentum(Player.MOMENTUM.Uti);
		vars[prefix+'Mom'] = this.getMomentum();
		vars[prefix+'Arousal'] = this.arousal;
		vars[prefix+'Team'] = this.team;
		vars[prefix+'Size'] = this.size;
		vars[prefix+'TeamPlayers'] = game.getTeamPlayers(this.team).length;
		vars[prefix+'MaxHP'] = this.getMaxHP();
		vars[prefix+'MaxArousal'] = this.getMaxArousal();
		vars[prefix+'Money'] = this.getMoney();
		vars[prefix+'apSpentThisTurn'] = this._turn_ap_spent;
		vars[prefix+'actionsUsedThisTurn'] = this._turn_action_used;

		vars[prefix+'ButtSize'] = this.getGenitalSizeValue(stdTag.butt);
		vars[prefix+'BreastSize'] = this.getGenitalSizeValue(stdTag.breasts);
		vars[prefix+'PenisSize'] = this.getGenitalSizeValue(stdTag.penis);

		vars[prefix+'Talkative'] = this.talkative;
		vars[prefix+'Sadistic'] = this.sadistic;
		vars[prefix+'Dominant'] = this.dominant;
		vars[prefix+'Hetero'] = this.hetero;
		vars[prefix+'Emotive'] = this.emotive;
		vars[prefix+'Intelligence'] = this.intelligence;
		
		vars[prefix+'Casting'] = +Boolean(this.isCasting()) || 0;

		vars[prefix+'UntappedBlock'] = this._untappedBlock;

		vars[prefix+'Block'] = this.getBlock();
		
		let tags = this.getTags();
		for( let tag of tags )
			vars[prefix+'Tag_'+tag] = 1;

		// Get a total value
		vars[prefix+'damagingReceivedSinceLast'] = this.datTotal( this._damaging_since_last );
		vars[prefix+'damageReceivedSinceLast'] = this.datTotal( this._damage_since_last );
		vars[prefix+'damagingDoneSinceLast'] = this.datTotal( this._d_damaging_since_last );
		vars[prefix+'damageDoneSinceLast'] = this.datTotal( this._d_damage_since_last );
		vars[prefix+'healingActionsDoneSinceLast'] = this.datTotal( this._d_healing_a_since_last );
		vars[prefix+'healingPointsDoneSinceLast'] = this.datTotal( this._d_healing_p_since_last );
		vars[prefix+'healingActionsReceivedSinceLast'] = this.datTotal( this._healing_a_since_last );
		vars[prefix+'healingPointsReceivedSinceLast'] = this.datTotal( this._healing_p_since_last );
		vars[prefix+'ripostedSinceLast'] = this.datTotalShort(this._riposted_since_last);
		vars[prefix+'ripostingSinceLast'] = this.datTotalShort(this._riposting_since_last);

		vars[prefix+'targetedSinceLast'] = objectSum(this._targeted_by_since_last.save());
		for( let i in Action.Types ){

			let type = Action.Types[i];
			vars[prefix+'damagingReceivedSinceLast'+type] = this.datTotal( this._damage_since_last, type );
			vars[prefix+'damageReceivedSinceLast'+type] = this.datTotal( this._damage_since_last, type );
			vars[prefix+'damagingDoneSinceLast'+type] = this.datTotal( this._d_damaging_since_last, type );
			vars[prefix+'damageDoneSinceLast'+type] = this.datTotal( this._d_damage_since_last, type );
			
		}

		// The mathvars event has a sender and target, and this player is the victim
		const weAreVictim = ( event && this === event.target && event.sender instanceof Player );
		const weAreSender = ( event && this === event.sender && event.target instanceof Player );
		// If we're the target of the event, append these
		if( weAreVictim ){

			// Add how much damage the sender has done to us
			vars.se_TaDamagingReceivedSinceLast = this.damagingSinceLastByPlayer(event.sender);
			vars.se_TaDamageReceivedSinceLast = this.damageSinceLastByPlayer(event.sender);
			// How much healing sender has done to target (us)
			vars.se_TaHealingActionsReceivedSinceLast = this.healingActionsTakenSinceLastByPlayer(event.sender);
			vars.se_TaHealingPointsReceivedSinceLast = this.healingPointsTakenSinceLastByPlayer(event.sender);

			// Target's crit chance on sender ta_Crit_se
			vars[prefix+'Crit_se'] = this.getCritDoneChance(event.sender);

			vars[prefix+'GrappledByS'] = +this.hasTagBy([stdTag.wrGrapple], event.sender) || 0;

		}
	
		if( weAreSender ){

			// Sender's crit chance on target se_Crit_ta
			vars[prefix+'Crit_ta'] = this.getCritDoneChance();

			vars.ta_SeDamagingReceivedSinceLast = this.damagingSinceLastByPlayer(event.target);
			vars.ta_SeDamageReceivedSinceLast = this.damageSinceLastByPlayer(event.target);

			vars.ta_SeHealingActionsReceivedSinceLast = this.healingActionsTakenSinceLastByPlayer(event.target);
			vars.ta_SeHealingPointsReceivedSinceLast = this.healingPointsTakenSinceLastByPlayer(event.target);

			vars[prefix+'GrappledByT'] = +this.hasTagBy([stdTag.wrGrapple], event.target) || 0;

		}

		for( let i in Asset.Slots ){
			let slot = Asset.Slots[i];
			vars[prefix+slot] = this.getEquippedAssetsBySlots(slot).length ? 1 : 0;
		}

		let wrappers = this.getWrappers();
		for(let wrapper of wrappers){

			if( !wrapper.label )
				continue;

			vars[prefix+'Wrapper_'+wrapper.label] = wrapper.stacks;
			// This wrapper was added by the sender. Then we add it again and append _se to indicate the wrapper was added by the sender of the event.
			// Used in damage effects where you want to do something with the nr of stacks the caster has put on a target
			// ex ta_Wrapper_corruptingOoze_se
			if( weAreVictim && wrapper.getCaster() === event.sender )
				vars[prefix+'Wrapper_'+wrapper.label+'_se'] = wrapper.stacks;

			// Gets effects the target has put on the sender
			// ex se_Wrapper_corruptingOoze_ta
			if( weAreSender && wrapper.getCaster() === event.target )
				vars[prefix+'Wrapper_'+wrapper.label+'_ta'] = wrapper.stacks;

		}

		

		if( isRoot )
			this._ignore_effects = null;

		return vars;
	}

	getArticle(){
		
		if( this.spre )
			return this.spre;
		return 'aeiou'.includes(this.species.charAt(0).toLowerCase()) ? 'an' : 'a';

	}

	getName(){
		let out = this.name;
		return out;
	}

	getColoredName(){
		return '|c'+this.color+'|'+this.getName()+'|/c|';
	}

	// Statuses
	isDead(){
		return this.hp <= 0;
	}


	isNPC(){
		return !this.netgame_owner;
	}

	isLootableBy( player ){
		return Boolean(player) && !game.battle_active && this.isDead() && this.getLootableAssets().length && this.team !== player.team;
	}

	isArousalDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableArousal);
	}
	isMomentumDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableMomentum);
	}
	
	isNonRequiredForVictory(){
		return this.hasTag('pl_'+stdTag.gpDisableVictoryCondition);
	}
	isHPDisabled(){
		return this.hasTag('pl_'+stdTag.gpDisableHP);
	}
	isInvisible(){
		return this.hasTag(stdTag.gpInvisible);
	}
	isSkipAllTurns(){
		return this.hasTag(['pl_'+stdTag.gpSkipTurns, stdTag.gpSkipTurns]);
	}
	isLeader(){
		return this.leader || !Game.net.isConnected();
	}
	isFollower(){
		return this.follower && this.follower.label;
	}
	// Updates follower RP from DB
	refetchFollower(){
		this.follower = glib.get(this.follower.label, 'Roleplay');
	}

	canRiposte(){
		return !this.hasTag(stdTag.wrNoRiposte);
	}

	// Can't accept their turn
	isIncapacitated(){
		let stun = this.getActiveEffectsByType(Effect.Types.stun);
		return stun.length > 0 || this.isSkipAllTurns();
	}

	// ActionRange is from Action.Range
	getTauntedBy( actionRange, returnAllIfNone = true, debug = false, ignoreGrapple = false ){

		let tauntEffects = this.getActiveEffectsByType(Effect.Types.taunt);

		// Filter by range
		tauntEffects = tauntEffects.filter(effect => {

			if( ignoreGrapple && effect.data.grapple )
				return false;

			// Either works
			if( effect.data.melee === undefined || actionRange === undefined )
				return true;

			if( effect.data.melee && actionRange !== Action.Range.Melee )
				return false;

			if( !effect.data.melee && actionRange !== Action.Range.Ranged )
				return false;
			
			return true;

		});

		if( debug )
			console.debug("Taunt effects", tauntEffects);
		if( !tauntEffects.length )
			return returnAllIfNone ? game.getEnabledPlayers() : [];

		let out = [];
		for( let effect of tauntEffects ){
			// Pick the sender
			let sender = effect.parent.getCaster();
			if( effect.data && effect.data.victim )
				sender = effect.parent.parent;

			if( sender && out.indexOf(sender) === -1 )
				out.push(sender);

		}
		return out;

	}

	isBeast(){
		return this.hasTag(stdTag.plBeast);
	}
	isTargetBeast(){
		return this.hasTag([stdTag.plBeast, stdTag.plTargetBeast]);
	}

	// Gets level including difficulty adjust. Used only in rolls.
	getLevel(){
		return this.level + (this.team !== Player.TEAM_PLAYER ? game.difficulty : 0);
	}


	// ICONS
	// useCache will use _cache_tags instead of tags. Useful if you're testing against a dummy player.
	getActiveIcon( useCache = false ){
		
		if( this.ior )
			return this.ior;

		// AI art disabled
		if( !this.constructor.AI_ENABLED && this.icon_ai )
			return this.constructor.MISSING_ART;

		if( useCache )
			useCache = -1;
		else
			useCache = true;	// This should always skip cache unless enforced

		let ub = this.hasTag(stdTag.asUpperBody, undefined, useCache),
			lb = this.hasTag(stdTag.asLowerBody, undefined, useCache)
		;
		if( !ub && !lb && this.icon_nude )
			return this.icon_nude;
		if( ub && !lb && this.icon_upperBody )
			return this.icon_upperBody;
		if( !ub && lb && this.icon_lowerBody )
			return this.icon_lowerBody;

		if( !this.icon )
			return this.constructor.MISSING_ART;
		return this.icon;

	}




	// RP Tags

	// Auto adds base tags like pl_penis if the player only has pl_big_penis etc
	addTagSynonyms(){

		
		const tags = this.getTags();
		const hasSynonymTag = ending => {
			
			for( let tag of tags ){
				
				if( tag.startsWith('pl_') && tag.endsWith('_'+ending) )
					return true;

			}

		};
		let synonyms = [
			'penis',
			'breasts'
		];
		for( let synonym of synonyms ){

			if( hasSynonymTag(synonym) ){

				const tn = 'pl_'+synonym;
				if( !this.tags.includes(tn) )
					this.tags.push(tn);

			}
		}

	}

	// Searches tags for pl_<prefix>_huge/big/small and returns a synonym
	getSizeTag( prefix ){

		prefix = prefix.substr(3);
		let texts = [""];
		if( this.hasTag('pl_big_'+prefix) )
			texts = ["big", "large", "sizable"];
		else if( this.hasTag('pl_huge_'+prefix) )
			texts = ["huge", "enormous", "gigantic", "massive"];
		else if( this.hasTag('pl_small_'+prefix) )
			texts = ['small'];

		return texts[Math.floor(Math.random()*texts.length)];

	}
	getBreastSizeTag(){
		return this.getSizeTag(stdTag.breasts);
	}
	getPenisSizeTag(){
		return this.getSizeTag(stdTag.penis);
	}
	getButtSizeTag(){
		return this.getSizeTag(stdTag.butt);
	}

	// Returns a value where 0 = none, 1 = small, 2 = average, 3 = large, 4 = huge
	// Prefix should be either stdTag.breasts, stdTag.penis or stdTag.butt
	getGenitalSizeValue( prefix ){

		prefix = prefix.split('_');
		prefix.shift();
		prefix = prefix.join('_');

		if( this.hasTag('pl_huge_'+prefix) )
			return 4;
		if( this.hasTag('pl_big_'+prefix) )
			return 3;
		if( this.hasTag('pl_small_'+prefix) )
			return 1;
		if( this.hasTag('pl_'+prefix) )
			return 2;
		return 0;
	}

	// Overrides the generic definition for the parent class
	// wrapperReturn can be used to add temporary armor strips
	// force will force ignore the cache. If force is -1, it always returns cache
	getTags( wrapperReturn, force = false ){

		if( force === -1 )
			return this._cache_tags;

		if( window.game && game._caches && this._cache_tags && !force )
			return this._cache_tags;

		let out = {};
		if( this.hp <= 0 )
			out[stdTag.dead] = true;

		for( let tag of this.tags ){

			if( !tag.startsWith('pl_') )
				tag = 'pl_'+tag;
			out[tag] = true;

		}

		// adds a tag to the name map
		const addTag = tag => out[tag] = true;

		let assets = this.getAssetsEquipped();
		if( wrapperReturn && wrapperReturn.armor_strips[this.id] ){

			for( let slot in wrapperReturn.armor_strips[this.id] ){

				const a = wrapperReturn.armor_strips[this.id][slot];
				if( assets.indexOf(a) === -1 ){
					assets.push(a);
				}
				
			}

		}

		for( let asset of assets ){
			if( !asset.getTags )
				console.error("Invalid asset", asset, "in", this);
			asset.getTags().map(addTag);
		}
		let fx = this.getWrappers();
		for( let f of fx ){
			f.getTags().map(addTag);
		}

		fx = this.getEffects();
		for( let f of fx ){

			f.getTags(this).map(addTag);
			// Bondage device mapping
			if( f.type === Effect.Types.tieToRandomBondageDevice && f.data._device ){

				const device = game.dungeon.getActiveRoom().getAssetById(f.data._device);
				if( device ){
					
					const dTags = device.getTags();
					for( let tag of dTags )
						out['bo_'+tag] = true;

				}
			}

		}
		this._turn_tags.map(t => out[t.tag] = true);

		if( this.species )
			out['p_'+this.species.toLowerCase()] = true;

		if( window.game && game.dungeon instanceof Dungeon )
			game.dungeon.getTags().map(t => out[t] = true);

		const ret = Object.keys(out);
		if( window.game && game._caches )
			this._cache_tags = ret;

		return ret;

	}

	// overrides generic class
	hasTagBy( tags, sender ){

		tags = toArray(tags);
		sender = toArray(sender);
		let sids = sender.map(el => el.id);


		// Start by checking turn tags
		for( let tt of this._turn_tags ){
			if( sids.includes(tt.s.id) && tags.includes(tt.tag) )
				return true;
		}

		
		// Check wrapper tags
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){
			if( sids.includes(wrapper.caster) && wrapper.hasTag(tags) )
				return true;
		}
		

		// Next check the effects
		const effects = this.getEffects();
		for( let effect of effects ){
			if( sids.includes(effect.parent.caster) && effect.hasTag(tags) )
				return true;
		}

		
		return false;

	}

	getPronoun(pronoun){

		if( pronoun === 'he' && this.he )
			return this.he;
		if( pronoun === 'him' && this.him )
			return this.him;
		if( pronoun === 'his' && this.his )
			return this.his;

		let out = 
			(this.hasTag('pl_penis') ? 1 : 0) |
			(this.hasTag('pl_vagina') ? 2 : 0) |
			(this.hasTag('pl_breasts') ? 4 : 0)
		;
		let pronouns = ['it', 'it', 'its'];
		if( out && out < 3 )
			pronouns = ['he', 'him', 'his'];
		else if( out === 6 )
			pronouns = ['she', 'her', 'her'];
		else if( out )
			pronouns = ['shi', 'hir', 'hir'];
		
		if( pronoun === 'he' )
			return pronouns[0];
		if( pronoun === 'him' )
			return pronouns[1];
		return pronouns[2];

	}
	// Get gender according to Game.Genders
	getGameGender(){

		let out = 
			(this.hasTag('pl_penis') ? 1 : 0) |
			(this.hasTag('pl_vagina') ? 2 : 0) |
			(this.hasTag('pl_breasts') ? 4 : 0)
		;
		
		if( out === 1 )
			return Game.Genders.Male;
		else if( out === 6 )
			return Game.Genders.Female;
		return Game.Genders.Other;

	}

	// Sets tags and strips pl_ prefix
	// Chainable
	setTags( tags ){
		this.tags = [];
		for( let tag of tags ){
			tag = tag.split('_');
			if( tag[0] === 'pl' )
				tag.shift();
			this.tags.push(tag.join('_'));
		}
		return this;
	}


	

	


	/* Events */
	// happens to players the first time they're placed in world from an encounter
	onPlacedInWorld(){

		//this.netgame_owner = '';
		if( this.leveled ){
			
			this.level += game.getHighestLevelPlayer();
			this.leveled = false;

		}

		this.addDefaultActions();
		this.addGlobalPassives();

		this.assets = this.assets.map(el => Asset.convertDummy(el, this));
		for( let index of this.inventory ){
			if( this.assets[index] && this.assets[index].equippable() ){
				this.equipAsset(this.assets[index].id, undefined, true);
			}
		}
		this.inventory = [];

		for( let inv of this.assets )
			inv.onPlacedInWorld();

		for( let passive of this.passives )
			passive.g_resetID();
		
		if( !this.getKinks().length && !this.hasTag([stdTag.plBeast, stdTag.plTargetBeast, stdTag.plNoFetish]) )
			this.shuffleKinks();
		
	}
	onRebalanced(){
		this.addHP(Infinity);
		//this.addMP(Infinity);
		this.arousal = 0;
	}
	onRemoved(){
		this.unbindWrappers();
	}
	onTurnEnd(){

		const wrappers = this.getWrappers(undefined, true);
		for(let wrapper of wrappers)
			wrapper.onTurnEnd();

		for(let action of this.actions)
			action.onTurnEnd();
		if( this._stun_diminishing_returns > 0 )
			--this._stun_diminishing_returns;
		this._damaging_since_last = {};
		this._damage_since_last = {};
		this._targeted_by_since_last = new Collection();
		this.endedTurn = false;
		++this._turns;

	}

	// Raised after effects
	onTurnStart(){

		this.reroll = 2;
		this.endedTurn = false;
		this._d_damaging_since_last = {};
		this._d_damage_since_last = {};
		this._riposted_since_last = {};
		this._riposting_since_last = {};
		this._healing_a_since_last = {};
		this._healing_p_since_last = {};
		this._d_healing_a_since_last = {};
		this._d_healing_p_since_last = {};
		
		// Prevent block from fading
		if( this.blockFadeLocked() )
			this.iBlock += this.block;

		// Convert incoming block (block added while it's not your turn) into block that vanishes the next turn
		this._untappedBlock = this.block;
		this.block = this.iBlock;
		this.iBlock = 0;
		
		if( this._untappedBlock )
			new GameEvent({sender:this, target:this, type:GameEvent.Types.blockExpired, custom:{
				amount: this._untappedBlock
			}}).raise();

		// Wipe turnTags on start
		this.resetTurnTags();

		if( this.bot )
			this.bot.onTurnStart();

		
		const wrappers = this.getWrappers(undefined, true);
		for(let wrapper of wrappers)
			wrapper.onTurnStart();

		const actions = this.getActions();
		for(let action of actions)
			action.onTurnStart();

		/*
		if( this.arousal > 0 && this._turns%2 === 0 ){

			this.addArousal(-1);	// Lose 1 every 2 turns
			
		}
		*/

		// Stored up momentum gets added first
		for( let m of this.incMom )
			this.addMomentum(m, 1, false);
		this.incMom = [];	// Stores incoming momentum
		
		// Then class momentum
		let addedMomentum = this.addMomentum(Player.getValidMomentum(this.class.momType), 1, false);
		

		// Finally random momentum
		let total = 2+this.getGenericAmountStatPoints(Effect.Types.momentumRegen);
		total *= this.getGenericAmountStatMultiplier(Effect.Types.momentumRegen);
		total = randRound(total);
		if( total > 0 ){
			const add = this.addMomentum(Player.MOMENTUM.All, total);	// random momentum
			addedMomentum[0] += add[0];
			addedMomentum[1] += add[1];
			addedMomentum[2] += add[2];
		}
		
		if( Game.net.isInNetgameHost() )
			Game.net.dmDrawMomentumGain(this, addedMomentum);
		if( game.is_host && this === game.getMyActivePlayer() )
			game.ui.drawMomentumGain(...addedMomentum);

		this._turn_action_used = 0;
		this._turn_ap_spent = 0;		// Todo: probably want this by type later
		
	}
	onBattleStart(){

		this._used_chats = {};
		this._turn_tags = [];
		this.resetMomentum();
		this.incMom = [];
		this._threat = {};
		this._stun_diminishing_returns = 0;
		this._damaging_since_last = {};
		this._damage_since_last = {};
		this._last_chat = -1;
		this._turn_action_used = 0;
		this.block = this.iBlock = 0;
		if( this.arousal >= this.getMaxArousal() )
			this.arousal = this.getMaxArousal()-1;

		this.start_equip = this.getAssetsEquipped(true).map(el => el.id);
		

		this.resetTempActions();

		let actions = this.getActions();
		for(let action of actions)
			action.onBattleStart();
			

	}
	onBattleEnd(){

		this.start_equip = [];
		this.blCorruption = this.block = this.iBlock = 0;
		this._last_chat = 0;	// Needed for out of combat chat
		this.resetMomentum();
		this.incMom = [];
		let actions = this.getActions();
		for(let action of actions)
			action.onBattleEnd();

		this.wrappers = this.wrappers.filter(wrapper => {

			if( wrapper.ext )	// Use external timer (game time)
				return true;

			// Purge the wrapper
			wrapper.unbindEvents();

		});

		const assets = this.getAssets(false);
		for( let asset of assets )
			asset.onBattleEnd();

		let wrappers = this.getWrappers(undefined, true);
		for(let wrapper of wrappers)
			wrapper.onBattleEnd();
			
		this._stun_diminishing_returns = 0;
		this._turns = 0;
		this.used_punish = false;

		// Prevent PCs from ending a battle at max arousal
		if( this.arousal >= this.getMaxArousal() && this.team === Player.TEAM_PLAYER )
			this.arousal = this.getMaxArousal()-1;

		this.resetTempActions();
		
	}
	// only triggers on PC for now
	onBattleWon(){
		
		if( this.generated )
			return;

		this.addHP(Math.ceil(this.getMaxHP()*0.1));		// Regen 30% of your HP
		this.addArousal(-Math.ceil(this.getMaxArousal()*0.15), undefined, true);

	}

	// Item broken, repaired, equipped, or removed
	onItemChange(){
		this.addHP(0);
		this.addMomentum(Player.MOMENTUM.All, 0);
	}

	onCellChange(){
		this.used_punish = true;
	}

	onTimePassed( delta ){
		
		// May need getWrappers()? But it's important that wrappers attached to assets also tick
		this.getWrappers(undefined, true).map(wrapper => wrapper.onTimePassed());
		this.getAssets().map(asset => asset.onTimePassed());

		// Out of combat regen
		if( !game.battle_active && this.team === Player.TEAM_PLAYER ){
			
			const 
				startTime = game._combat_changed,
				curTime = game.time
			;

			const 
				preMinutes = Math.floor((curTime-startTime-delta)/60),
				postMinutes = Math.floor((curTime-startTime)/60)
			;
			
			// Newly added minutes
			if( postMinutes > preMinutes ){

				//this.addMP(postMinutes-preMinutes);
				this.addHP(postMinutes-preMinutes);
				this.addArousal(-(postMinutes-preMinutes));
				this.addMomentum(Player.MOMENTUM.All, (postMinutes-preMinutes)*3);	// 3 AP per minute
				
				const actions = this.getActions(true, false, true, false);
				for( let action of actions )	// Subtract 1 cooldown per minute
					action.addCooldown(-(postMinutes-preMinutes));

			}

		}

	}

	

	onDamagingAttackReceived( sender, type ){
		if(!this._damaging_since_last[sender.id])
			this._damaging_since_last[sender.id] = {};
		if(!this._damaging_since_last[sender.id][type])
			this._damaging_since_last[sender.id][type] = 0;
		
		++this._damaging_since_last[sender.id][type];
	}
	onHealingAttackReceived( sender, type ){
		if(!this._healing_a_since_last[sender.id])
			this._healing_a_since_last[sender.id] = {};
		if(!this._healing_a_since_last[sender.id][type])
			this._healing_a_since_last[sender.id][type] = 0;
		
		++this._healing_a_since_last[sender.id][type];
	}
	onDamagingAttackDone(target, type){

		if(!this._d_damaging_since_last[target.id])
			this._d_damaging_since_last[target.id] = {};
		if(!this._d_damaging_since_last[target.id][type])
			this._d_damaging_since_last[target.id][type] = 0;
		
		++this._d_damaging_since_last[target.id][type];

	}
	onHealingAttackDone( target, type ){
		if(!this._d_healing_a_since_last[target.id])
			this._d_healing_a_since_last[target.id] = {};

		if( !this._d_healing_a_since_last[target.id][type] )
			this._d_healing_a_since_last[target.id][type] = 0;
		
		++this._d_healing_a_since_last[target.id][type];
	}

	onDamageTaken( sender, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._damage_since_last[sender.id])
			this._damage_since_last[sender.id] = {};
		if(!this._damage_since_last[sender.id][type])
			this._damage_since_last[sender.id][type] = 0;
		
		this._damage_since_last[sender.id][type] += amount;
	}
	onHealingTaken( sender, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._healing_p_since_last[sender.id])
			this._healing_p_since_last[sender.id] = {};
		if(!this._healing_p_since_last[sender.id][type])
			this._healing_p_since_last[sender.id][type] = 0;
		
		this._healing_p_since_last[sender.id][type] += amount;
	}

	onDamageDone( target, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._d_damage_since_last[target.id])
			this._d_damage_since_last[target.id] = {};
		if(!this._d_damage_since_last[target.id][type])
			this._d_damage_since_last[target.id][type] = 0;
		this._d_damage_since_last[target.id][type] += amount;
	}
	onHealingDone( target, type, amount = 0 ){
		if( isNaN(amount) )
			return;
		if(!this._d_healing_p_since_last[target.id])
			this._d_healing_p_since_last[target.id] = {};
		if(!this._d_healing_p_since_last[target.id][type])
			this._d_healing_p_since_last[target.id][type] = 0;
		this._d_healing_p_since_last[target.id][type] += amount;
	}


	onTargetedActionUsed( target ){
	}
	onTargetedActionReceived( sender ){
		let amount = this._targeted_by_since_last.get(sender.id) || 0;
		++amount;
		this._targeted_by_since_last.set(sender.id, amount);
	}
	onRiposteDone( target ){
		if( !this._riposting_since_last[target.id] )
			this._riposting_since_last[target.id] = 0;
		++this._riposting_since_last[target.id];
	}
	onRiposteReceived( target ){
		if( !this._riposted_since_last[target.id] )
			this._riposted_since_last[target.id] = 0;
		++this._riposted_since_last[target.id];
	}
	

	onDeath( attacker, effect ){
		
		// Damage durability
		const assets = this.getAssetsEquipped(false);
		for( let asset of assets )
			asset.damageDurability( attacker, effect, Math.ceil(asset.getMaxDurability()*0.2) );

		if( this.remOnDeath ){
			game.removePlayer(this);
		}

	}

	onIdChanged(){
		this.updatePassives();
		this.getAssetsEquipped().map(el => el.onEquip());
	}

	/* Kinks */
	getKinks(){

		return this.passives.filter(el => el.hasTag(stdTag.wrKink));

	}

	hasKink( label ){

		let all = this.getKinks();
		for( let kink of all ){

			if( kink.label === label )
				return true;

		}

		return false;

	}

	removeKinks(){
		this.getKinks().map(this.removePassive, this);
	}

	shuffleKinks(){

		// Scan the wrapper DB
		const evt = new GameEvent({
			sender:this,
			target:this
		});
		const kinks = Wrapper.getKinks().filter(wrapper => wrapper.testAgainst( evt, false ));
		shuffle(kinks);

		this.removeKinks();
		for( let i = 0; i < MAX_KINKS; ++i )
			this.addPassive(kinks[i]);

	}


	/* TurnTags */
	addTurnTags( tags, sender ){
		for( let tag of tags ){
			this.removeTurnTag(tag);
			this._turn_tags.push({tag:tag, s:sender});
		}
	}

	// returns a turnTag object if it exists
	getTurnTag( tag ){
		for( let ttObj of this._turn_tags ){
			if( ttObj.tag === tag )
				return ttObj;
		}
		return false;
	}

	removeTurnTag( tag ){
		for( let i in this._turn_tags ){
			if( this._turn_tags[i].tag === tag ){
				this._turn_tags.splice(i,1);
				return;
			}
		}
	}

	resetTurnTags(){
		this._turn_tags = [];
	}


	/* Assets */
	// if fromStacks is true, it only iterates once and adds amount to stacks instead of asset._stacks
	// returns false on fail, or an array of all added assets on success
	addAsset( asset, amount = 1, fromStacks = false, no_equip = false, resetid = true, toBank = false ){
		if( !(asset instanceof Asset) ){
			console.error("Trying to add non-asset. Did you mean to use addLibraryAsset?");
			return false;
		}
		asset.equipped = false;

		const out = {};
		asset.onPlacedInWorld();
		for( let i = 0; i<amount && (!fromStacks || i<1); ++i ){
			// Needs to be its own object
			const a = asset.clone(this);

			if( resetid )
				a.g_resetID();	// Buying stacks will bork everything otherwise

			const exists = this.getAssetByLabel(a.label, toBank);

			if( toBank && (!exists || !a.stacking) && this.getAssets(true).length >= Player.BANK_SLOTS )
				throw 'Bank is full';

			let n = a._stacks;
			if( fromStacks )
				n = amount;
			if( a.stacking && exists )
				exists._stacks += n;
			else{
				a._stacks = n;
				this.assets.push(a);
			}
			if( !toBank && a.equippable() && !game.battle_active && !no_equip ){

				// Potions auto equip out of combat
				if( 
					a.category === Asset.Categories.consumable && 
					this.getEquippedAssetsBySlots(Asset.Slots.action).length < 3
				){
					this.equipAsset(a.id, this);
				}
				// NPCs equip items handed to them unless they're already wearing one
				else if( this.isNPC() && !this.getEquippedAssetsBySlots(a.slots).length ){

					this.equipAsset(a.id, this);

				}

			}
			
			a.inBank = Boolean(toBank);
			

			out[a.id] = a;

		}
		this.raiseInvChange();
		if( !toBank )
			game.onInventoryAdd( this, asset );
		return Object.values(out);

	}
	raiseInvChange(){
		new GameEvent({type:GameEvent.Types.inventoryChanged, sender:this, target:this}).raise();
	}
	addLibraryAsset( label, amount = 1 ){

		let asset = glib.get(label, 'Asset');
		if( !asset ){
			console.error("Invalid library asset", label);
			return false;
		}
		const newAsset = this.addAsset(asset, amount)[0];	// Resets ID
		if( newAsset ){
			newAsset.repair();
			newAsset.resetCharges();
		}
		return newAsset;

	}
	// Use -1 to get from either
	getAssetById( id, inBank ){

		let assets;
		if( inBank === -1 )
			assets = this.getAssets(true).concat(this.getAssets(false));
		else
			assets = this.getAssets(inBank);


		for( let asset of assets ){

			if( asset.id === id )
				return asset;

		}
		return false;

	}
	// useful for stackable items like currency
	getAssetByLabel( label, inBank ){

		let assets = this.getAssets(inBank);
		for(let asset of assets){

			if( asset.label === label )
				return asset;

		}
		return false;

	}
	isAssetEquipped(id){
		let asset = this.getAssetById(id);
		if(!asset)
			return false;
		return asset.equipped;
	}
	getEquippedAssetsBySlots( slots, includeBroken ){
		if( !Array.isArray(slots) )
			slots = [slots];
		let assets = this.getAssetsEquipped(includeBroken);
		let out = [];
		for(let asset of assets){
			for( let slot of slots ){
				if( ~asset.slots.indexOf(slot) ){
					out.push(asset);
					break;
				}
			}
		}
		return out;
	}

	getStealableAssets(){

		const assets = this.getAssets(false);
		return assets.filter(el => {
			return !el.soulbound && el.hasTag(stdTag.asStealable);
		});

	}

	// Accepts an asset or an id
	canEquip( asset, ignoreBattleState ){

		if( typeof asset === "string" )
			asset = this.getAssetById(asset);

		return (
			asset.equippable() &&
			(
				ignoreBattleState || !game.battle_active || this.start_equip.includes(asset.id)
			)
		);

	}

	// byPlayer is the player who initiated the equip. If it's not a player, no event is raised.
	equipAsset( id, byPlayer, ignoreBattleState ){

		const asset = this.getAssetById(id);
		if( !asset )
			return false;

		if( !this.canEquip(asset, ignoreBattleState) ){
			console.error("Item can not be equipped", asset, "ignore battle state:", ignoreBattleState);
			return false;
		}

		// Special case for action slot
		const isActionAsset = ~asset.slots.indexOf(Asset.Slots.action);
		if( isActionAsset && !this.unequipActionAssetIfFull() )
			return false;
		if( !isActionAsset && !this.unequipAssetsBySlots(asset.slots, byPlayer) )
			return false;

		asset.equipped = true;
		asset.onEquip();
		this.onItemChange();
		if( game.battle_active && byPlayer )
			game.ui.addText( this.getColoredName()+" equips "+asset.name+".", undefined, this.id, this.id, 'statMessage important' );
		this.rebindWrappers();

		if( byPlayer ){
			new GameEvent({
				type : GameEvent.Types.armorEquipped,
				sender : byPlayer,
				target : this,
				asset : asset
			}).raise();
		}

		return true;

	}

	// byPlayer is the player who initiated it. If it's not a player object, no event is raised
	unequipAsset( id, byPlayer, noText ){

		let assets = this.getAssetsEquipped(true);
		for(let asset of assets){

			if( asset.id === id ){

				if( asset.rem_unequip )
					this.destroyAsset(asset.id);

				asset.equipped = false;
				this.onItemChange();
				if( game.battle_active && byPlayer === this && !noText )
					game.ui.addText( this.getColoredName()+" unequips "+asset.name+".", undefined, this.id, this.id, 'statMessage important' );
				this.rebindWrappers();

				if( byPlayer ){
					new GameEvent({
						type : GameEvent.Types.armorUnequipped,
						sender : byPlayer,
						target : this,
						asset : asset
					}).raise();
				}
				return asset;

			}

		}
		return true;

	}
	unequipAssetsBySlots( slots, byPlayer ){

		let equipped = this.getEquippedAssetsBySlots(slots, true);
		if(!equipped.length)
			return true;
		for( let e of equipped ){
			if(!this.unequipAsset(e.id, byPlayer))
				return false;
		}
		return true;

	}

	// returns nr of assets of label, including stacks
	numAssets( label, inBank ){

		let out = 0;
		const assets = this.getAssets(inBank);
		for( let asset of assets ){

			if( asset.label === label )
				out += asset.stacking ? asset._stacks : 1;

		}

		return out;

	}

	// Returns nr of assets by label, including stacks and charges
	numAssetUses( label, equipped_only = false ){

		let assets = this.getAssets(false);
		if( equipped_only )
			assets = this.getAssetsEquipped();
		let out = 0;
		for(let asset of assets){

			if( asset.label === label ){
				let n = asset.stacking ? asset._stacks : 1;
				if( asset.charges > 1 ){
					n = (n-1)*asset.charges+asset._charges;
				}
				else if( asset.charges === -1 )
					return -1;
				out += n;
			}

		}
		return out;
	}

	// Unequips the leftmost one if toolbelt is full
	unequipActionAssetIfFull(){

		let assets = this.getEquippedAssetsBySlots(Asset.Slots.action, true);
		if( assets.length < 3 )
			return true;
		return this.unequipAsset(assets[0].id, this);

	}

	// Returns equipped assets
	getAssetsEquipped( includeBroken ){
		const out = [], assets = this.getAssets();
		for(let asset of assets){
			if( asset === undefined )
				console.error("Undefined asset in", this);
			if( asset.equipped && (includeBroken || asset.durability > 0) )
				out.push(asset);
		}
		return out;
	}

	destroyAsset( id, amount, inBank ){

		if( id instanceof Asset )
			id = id.id;

		
		this.getAssetWrappers(id).map(el => el.remove());

		for( let i in this.assets ){

			let asset = this.assets[i];
			if( asset.id === id && Boolean(asset.inBank) === Boolean(inBank) ){

				if( Math.floor(amount) && asset.stacking )
					asset._stacks -= amount;
				if( !amount || !this.assets[i].stacking || asset._stacks <= 0 )
					this.assets.splice(i, 1);
				this.raiseInvChange();
				this.rebindWrappers();
				return true;

			}

		}

		return false;

	}

	// Gets wrappers attached to an asset we own by asset id
	getAssetWrappers( id ){

		return this.wrappers.filter(wr => wr.asset && wr.asset === id);

	}

	destroyAssetsByLabel( label, amount = 1, inBank = false ){

		let assets = this.getAssets(inBank);
		for( let asset of assets ){

			if( asset.label === label ){	

				let nrToRemove = !asset.stacking ? 1 : asset._stacks;
				if( nrToRemove > amount )
					nrToRemove = amount;
				this.destroyAsset(asset.id, amount);
				amount -= nrToRemove;
				if( amount < 1 )
					return;

			}

		}

	}

	// Transfers an asset to a player. Player is a player object
	transferAsset( id, player, byPlayer ){

		let asset = this.getAssetById(id);
		if( !asset )
			return false;
		this.unequipAsset(id, byPlayer || this);
		player.addAsset(asset);	// Resets the ID too
		this.destroyAsset(id);
		return true;

	}

	// Returns a list of assets that have their durability damaged
	getRepairableAssets( includeFullDurability = false ){

		const assets = this.getAssets();
		return assets.filter(asset => {
			return (includeFullDurability || asset.isDamaged()) && asset.isDamageable();
		});

	}

	getAssets( banked ){

		return this.assets.filter(el => Boolean(el.inBank) === Boolean(banked));

	}

	// Returns non-equipped assets
	getAssetsInventory(){
		const out = [], assets = this.getAssets();
		for(let asset of assets){
			if(!asset.equipped)
				out.push(asset);
		}
		return out;
	}
	// Overwrite inventory items with defaults from database
	refetchInventory(){

		let lib = glib.getFull('Asset');
		for(let i in this.assets){

			let asset = this.assets[i];
			if( lib[asset.label] ){
				const stacks = this.assets[i]._stacks,
					equipped = this.assets[i].equipped;
				console.debug("Overwriting ", asset.label);
				this.assets[i] = lib[asset.label].clone(this);
				this.assets[i]._stacks = stacks;
				this.assets[i].equipped = equipped;

			}

		}

	}

	getLootableAssets(){
		return this.getAssets();
	}

	lootToPlayer( id, player, silent = false ){

		let asset = this.getAssetById(id);
		if( !asset ){
			if( !silent )
				console.error("Asset not found", id, "in", this);
			return false;
		}
		
		if( game.is_host && asset.loot_sound )
			game.playFxAudioKitById(asset.loot_sound, player, player, undefined, true );
		
		if( !game.is_host ){
			Game.net.playerLootPlayer( player, this, asset );
			return;
		}

		asset.equipped = false;		// Make sure it's not equipped
		if( player.addAsset(asset) )
			this.destroyAsset(id);

		game.ui.addText( player.getColoredName()+" looted "+asset.name+" from "+this.getColoredName()+".", undefined, player.id,  player.id, 'statMessage important' );
		game.save();
		game.ui.draw();

	}

	// By default it damages all worn items
	// Returns an array of {armor_damage:{slot:damage}, armor_strips:{slot:true}}
	damageDurability( sender, effect, amount, slots, fText = false ){

		const out = {
			armor_damage : {},
			armor_strips : {}
		};
		let assets = [];
		// Pick a slot at random
		if( slots === 'RANDOM' ){

			let viableAssets = this.getEquippedAssetsBySlots([Asset.Slots.lowerBody, Asset.Slots.upperBody]);
			if( !viableAssets.length )
				return;
			assets = [viableAssets[Math.floor(Math.random()*viableAssets.length)]];

		}
		else{

			if( !slots )
				slots = [Asset.Slots.lowerBody, Asset.Slots.upperBody];
			slots = toArray(slots);
			assets = this.getEquippedAssetsBySlots(slots);

		}

		let asc = assets.slice();	// Prevents adding to the one we're looping over
		for( let asset of asc ){
			
			let slots = asset.slots;
			if( Math.random() < 0.5 && slots.includes(Asset.Slots.lowerBody) )
				assets.push(...this.getEquippedAssetsBySlots([Asset.Slots.lowerBodyCosmetic]));
			if( Math.random() < 0.5 && slots.includes(Asset.Slots.upperBody) )
				assets.push(...this.getEquippedAssetsBySlots([Asset.Slots.upperBodyCosmetic]));
			
		}

		// 10% chance for jewellery
		if( Math.random() < 0.1 )
			assets.push(...this.getEquippedAssetsBySlots([Asset.Slots.jewelleryCosmetic]));
		
		
		amount = Math.round(amount);
		for( let asset of assets ){

			let destroyed = asset.damageDurability( sender, effect, amount, fText );
			if( destroyed !== false ){
				for( let slot of asset.slots ){

					out.armor_damage[slot] = amount;
					if( destroyed )
						out.armor_strips[slot] = asset;

				}
			}

		}
		this.rebindWrappers();

		return out;

	}


	// returns between 0 and 1
	getAssetDurabilityPercentageBySlot( slot ){

		let asset = this.getEquippedAssetsBySlots(slot);
		if( !asset.length )
			return 0;
		asset = asset.shift();
		return asset.durability / asset.getMaxDurability();

	}

	// Gets max carry capacity in grams
	getCarryingCapacity(){

		let flat = 
			35000+
			this.getGenericAmountStatPoints(Effect.Types.carryModifier)
		;

		return flat*this.getGenericAmountStatMultiplier(Effect.Types.carryModifier, this);

	}
	getCarriedWeight(){

		let out = 0;
		const assets = this.getAssets();
		for( let asset of assets ){

			let weight = asset.getWeight();
			out+= weight;

		}
		return out;

	}
	isEncumbered(){
		return !this.isBeast() && this.getCarriedWeight() > this.getCarryingCapacity();
	}

	// Currency
	// Returns currency value in copper
	getMoney( bank ){

		let out = 0;
		const assets = this.getAssets(bank);
		for( let asset of assets ){
			if( asset.label === 'platinum' )
				out += asset._stacks*1000;
			else if( asset.label === 'gold' )
				out += asset._stacks*100;
			else if( asset.label === 'silver' )
				out += asset._stacks*10;
			else if( asset.label === 'copper' )
				out += asset._stacks;
		}
		return out;

	}

	consumeMoney( copper = 0, bank = false ){

		let total = this.getMoney(bank);
		if( total < copper )
			return false;

		let costRemaining = copper;		// Remaining cost in copper we need to pay
		let consumeCopper = 0,			// Copper assets we need to remove
			consumeSilver = 0,			// Silver assets we need to remove
			consumeGold = 0,			// Gold assets we need to remove
			consumePlatinum = 0			// Plat assets we need to remove
		;
		let copperAsset = this.getAssetByLabel('copper', bank),
			silverAsset = this.getAssetByLabel('silver', bank),
			goldAsset = this.getAssetByLabel('gold', bank)
		;
		// First see if we can handle it with just copper
		if( copperAsset && copperAsset._stacks >= copper ){
			consumeCopper = costRemaining;
			costRemaining = 0;
		}else{
			// Start by spending all copper
			if( copperAsset ){
				consumeCopper = copperAsset._stacks;
				costRemaining -= consumeCopper;
			}
			while( costRemaining > 0 ){
				// See if we still have any silver
				if( silverAsset && silverAsset._stacks > consumeSilver ){
					// Split a silver
					++consumeSilver;
					costRemaining -= 10;
				}else if( goldAsset && goldAsset._stacks > consumeGold ){
					// Split a gold
					++consumeGold;
					costRemaining -= 100;
				}
				else{
					// Split a platinum
					++consumePlatinum;
					costRemaining -= 1000;
				}
			}
		}

		const change = this.calculateMoneyExhange(Math.abs(costRemaining));
		consumeCopper -= change[3];
		consumeSilver -= change[2];
		consumeGold -= change[1];
		consumePlatinum -= change[0];

		//console.log("Consume: ", consumeCopper, "copper", consumeSilver, "silver", consumeGold, "gold", consumePlatinum, "plat." "Change in copper", Math.abs(costRemaining));
		
		if( consumeCopper < 0 ){
			const asset = glib.get('copper', 'Asset');
			asset._stacks = Math.abs(consumeCopper);
			this.addAsset(asset, undefined, undefined, undefined, undefined, bank);
		}
		else if( consumeCopper > 0 )
			this.destroyAsset(copperAsset.id, consumeCopper, bank);

		if( consumeSilver < 0 ){
			const asset = glib.get('silver', 'Asset');
			asset._stacks = Math.abs(consumeSilver);
			this.addAsset(asset, undefined, undefined, undefined, undefined, bank);
		}
		else if( consumeSilver > 0 )
			this.destroyAsset(silverAsset.id, consumeSilver, bank);
		
		if( consumeGold < 0 ){
			const asset = glib.get('gold', 'Asset');
			asset._stacks = Math.abs(consumeGold);
			this.addAsset(asset, undefined, undefined, undefined, undefined, bank);
		}
		else if( consumeGold > 0 )
			this.destroyAsset(goldAsset.id, consumeGold, bank);

		if( consumePlatinum < 0 ){
			const asset = glib.get('platinum', 'Asset');
			asset._stacks = Math.abs(consumePlatinum);
			this.addAsset(asset, undefined, undefined, undefined, undefined, bank);
		}
		else if( consumePlatinum > 0 ){
			this.destroyAsset(this.getAssetByLabel('platinum').id, consumePlatinum, bank);
		}
		return true;

	}

	// See Player.calculateMoneyExchange
	calculateMoneyExhange( input = 0 ){
		return Player.calculateMoneyExhange(input);
	}

	// Auto exchanges money assets to the fewest amounts of coins
	exchangeMoney( bank ){
		const copper = this.getMoney(bank);
		let asset;
		if( asset = this.getAssetByLabel('platinum', bank) )
			this.destroyAsset(asset, undefined, bank);
		if( asset = this.getAssetByLabel('gold', bank) )
			this.destroyAsset(asset, undefined, bank);
		if( asset = this.getAssetByLabel('silver', bank) )
			this.destroyAsset(asset, undefined, bank);
		if( asset = this.getAssetByLabel('copper', bank) )
			this.destroyAsset(asset, undefined, bank);
		
		let assets = Player.copperToAssets(copper);
		for( let a of assets )
			this.addAsset(a, undefined, undefined, undefined, undefined, bank);
		
		return true;
		
	}

	// Exchanges a copper amount into plat, gold etc and adds
	addCopperAsMoney( copper = 0, bank = false ){

		copper = parseInt(copper);
		if( copper < 1 )
			return;

		const exch = Player.calculateMoneyExhange(copper);
		for( let i in exch ){

			if( !exch[i] )
				continue;
			const asset = glib.get(Player.currencyWeights[i], 'Asset');
			asset._stacks = exch[i];
			this.addAsset(asset, undefined, undefined, undefined, undefined, bank);
			
		}

	}

	canExchange( bank ){

		const labels = Player.currencyWeights.slice(1);
		const assets = this.getAssets( bank );
		for( let asset of assets ){
			if( ~labels.indexOf(asset.label) && asset._stacks >= 10 )
				return true;
		}

	}



	// BANK

	// Move an asset to bank. Supports either the asset itself or its ID.
	moveAssetToBank( asset, amount ){

		if( typeof asset === 'string' )
			asset = this.getAssetById(asset, false);
		if( !(asset instanceof Asset) )
			throw 'Asset not found';

		this.unequipAsset(asset, this, true);
		this.addAsset(asset, amount || 1, true, true, true, true);
		this.destroyAsset(asset.id, amount, false);

	}

	moveAssetFromBank( asset, amount ){

		if( typeof asset === 'string' )
			asset = this.getAssetById(asset, true);
		if( !(asset instanceof Asset) )
			throw 'Banked asset not found';

		this.addAsset(asset, amount || 1, true, true, true, false);
		this.destroyAsset(asset.id, amount, true);
		
	}




	/* Leveling & Experience */
	getExperienceUntilNextLevel(){
		if( this.level === 1 )
			return 4;
		
		return Math.ceil(1+this.level*2+Math.pow(this.level,2.5));
	}

	// NPC kills
	getExperienceWorth(){
		return Math.ceil(this._difficulty*this.level/4);
	}

	// adds experience and returns levels gained
	addExperience( points ){

		if( !points )
			console.error("Invalid points to addexperience: ", points);

		points = points*this.getGenericAmountStatMultiplier(Effect.Types.expMod, this);

		if( isNaN(points) ){

			console.error("Trying to add NaN experience");
			return false;

		}

		if( Math.random() < points-Math.floor(points) )
			++points;

		points = Math.floor(points);
		this.experience += Math.floor(points);
		
		if( this.level === Player.MAX_LEVEL )
			this.experience = 0;
		
		let startLevel = this.level;
		while( this.experience >= this.getExperienceUntilNextLevel() ){
			this.experience -= this.getExperienceUntilNextLevel();
			++this.level;
			if( this.level === Player.MAX_LEVEL ){
				this.experience = 0;
				break;
			}
		}
		game.ui.addText( this.getColoredName()+" gained "+points+" experience!", undefined, this.id, this.id, 'important statMessage' );

		

		let levelsGained = this.level-startLevel;
		if( levelsGained ){
			
			this.addActionsForClass();
			game.onPlayerLevelup(this, levelsGained);

		}

		if( !this.actionSlotsFull() ){

			const n = this.getNrFreeActionSlots();
			game.ui.addText( this.getColoredName()+" has "+n+" free action slot"+(n === 1 ? '' : 's')+"! Visit a gym to learn new actions!", undefined, this.id, this.id, 'important statMessage' );

		}

		return levelsGained;
	}







	/* RESOURCES */
	// Adds or subtracts momentum by type
	// If add is -1 it adds to random types
	// If remove is -1 it removes from random types
	addMomentum( type, amount = 0, fText = false ){

		let out = [0,0,0];

		// This player doesn't support momentum (such as the sharktopus gong)
		if( this.isMomentumDisabled() )
			return out;

		type = Player.getValidMomentum(type);
		amount = Math.trunc(amount);
		
		let pre = this.getMomentum(type);

		const all = this.getMomentum();
		// If we go over max momentum, add the rest as rerolls
		if( amount+all > this.getMaxMomentum() ){

			const offs = amount+all-this.getMaxMomentum();
			this.reroll += offs;
			amount -= offs;

		}
		// Nothing to change. Also prevents division by 0.
		if( !amount )
			return out;

		let amts = [
			type === Player.MOMENTUM.Off && amount || 0,
			type === Player.MOMENTUM.Def && amount || 0,
			type === Player.MOMENTUM.Uti && amount || 0
		];
		if( type === Player.MOMENTUM.All ){

			const n = amount/Math.abs(amount);	// Convert it to +1 or -1
			for( let i = 0; i < Math.abs(amount); ++i )
				amts[Math.floor(Math.random()*3)] += n;
			
		}
		
		this.momOff = Math.max(0, this.momOff+amts[0]);
		this.momDef = Math.max(0, this.momDef+amts[1]);
		this.momUti = Math.max(0, this.momUti+amts[2]);

		let ch = this.getMomentum(type)-pre;
		if( fText && ch !== 0 )
			game.ui.floatingCombatText(ch, this, "ap ap"+type);

		return amts;

	}

	// Can be used later for effects that alter momentum
	getMaxMomentum(){
		return Player.MAX_MOMENTUM;
	}

	// Returns nr of momentum of a type
	getMomentum( type = -1 ){

		if( type == Player.MOMENTUM.Off )
			return this.momOff;
		if( type == Player.MOMENTUM.Def )
			return this.momDef;
		if( type == Player.MOMENTUM.Uti )
			return this.momUti;
		return this.momOff+this.momDef+this.momUti;

	}

	consumeReroll( amount = 1 ){
		if( isNaN(amount) )
			return;
		this.reroll -= Math.trunc(amount);
		if( this.reroll < 0 )
			this.reroll = 0;
	}

	// Reroll a point of momentum from one type to another. Returns the type it was rolled into or boolean false on fail
	rerollMomentum( type ){
		
		type = Player.getValidMomentum(type);
		if( type === Player.MOMENTUM.All ){
			let viable = [];
			
			if( this.momOff )
				viable.push(Player.MOMENTUM.Off);
			if( this.momDef )
				viable.push(Player.MOMENTUM.Def);
			if( this.momUti )
				viable.push(Player.MOMENTUM.Uti);
			
			if( !viable.length )
				return false;
			type = randElem(viable);
			
		}

		let cur = this.getMomentum(type);
		// Not enough to reroll
		if( !cur )
			return false;
		
		let targ = type+Math.ceil(Math.random()*2);
		targ = targ%3;
		this.addMomentum(type, -1);
		this.addMomentum(targ, 1);
		return targ;

	}

	resetMomentum(){
		this.momOff = this.momDef = this.momUti = 0;
	}

	// Todo: allow subtract
	addIncomingMomentum( type, amount ){

		type = Player.getValidMomentum(type);
		amount = randRound(amount);
		if( amount < 1 )
			return;
		
		for( let i = 0; i < amount; ++i )
			this.incMom.unshift(type);

		this.incMom = this.incMom.slice(0, Player.MAX_MOMENTUM); // max 12 for stacking reasons

	}
	
	// Packs momentum or incoming momentum into a 20 bit number, making it easier to transport to other players
	packIncomingMomentum(){

		const table = this.incMom;
		let out = 0;
		for( let i = 0; i < Player.MAX_MOMENTUM && i < table.length; ++i ){
			let v = table[i]+1;
			out = out|(v<<(2*i));
		}
		return out;
	}
	// Unpacks momentum from a 20bit (2 bit per momentum) to an array
	unpackIncomingMomentum( nr ){

		this.incMom = [];
		for( let i = 0; i < Player.MAX_MOMENTUM; ++i ){
			let n = (nr>>(i*2)) & 3;
			if( n )
				this.incMom.push(n-1);
		}

	}


	addThreat( playerID, amount ){
		if( typeof playerID !== "string" ){
			console.error("Can't add non-string player threat, received:", playerID);
			return;
		}
		if( !this._threat.hasOwnProperty(playerID) )
			this._threat[playerID] = 0;
		this._threat[playerID] += amount;		
	}

	// min amount of 1
	getPlayerThreat( player ){
		let thr = 1;
		if( this._threat[player.id] > 0 )
			thr = this._threat[player.id];
		return thr;
	}

	// Adds block. Returns the amount added/subtracted
	addBlock( amount, byPlayer ){
		
		let pre = this.getBlock();
		
		amount = parseInt(amount);
		if( isNaN(amount) )
			throw 'Invalid value passed to block: '+amt;

		// Damage
		if( amount < 0 ){

			let n = this.block+amount;
			if( n < 0 ){	// We went below 0, and have to remove from incoming block too
				this.block = 0;
				this.iBlock = Math.max(0, this.iBlock+n);
			}
			else
				this.block = n;

		}
		// ADD
		else{

			if( game.isTurnPlayer(this) )
				this.block += amount;
			else
				this.iBlock += amount;

		}

		let added = this.getBlock()-pre;

		const evt = new GameEvent({
			sender : byPlayer,
			target : this,
			custom : {
				amount : Math.abs(added)
			}
		});
		evt.type = added > 0 ? GameEvent.Types.blockAdded : GameEvent.Types.blockSubtracted;
		evt.raise();
		
		return added;

	}

	getBlock(){
		return this.block + this.iBlock;
	}

	isBlockDisabled(){
		return this.getActiveEffectsByType(Effect.Types.preventBlock).length > 0;
	}

	// Returns if block of a type shouldn't fade on turn start
	blockFadeLocked(){
		return this.getActiveEffectsByType(Effect.Types.preventBlockAutoFade).length > 0;
	}

	// Returns an object with {died:(bool)died, hp:(int)hp_damage, blk:(int)amount_blocked/defended}.
	// IgnoreBlock attacks HP directly.
	addHP( amount, sender, effect, dmgtype, ignoreBlock, fText = false ){

		if( !ignoreBlock )
			ignoreBlock = this.isBlockDisabled();

		if( this.isHPDisabled() )
			return false;

		if( isNaN(amount) ){

			console.error("HP amount is NaN", amount);
			return false;

		}

		let out = {died:false, hp:0, blk:0};

		let pre = this.hp;
		let prehp = this.hp;
		let wasDead = this.hasTag(stdTag.dead);

		// Taking damage
		if( dmgtype ){
			
			let shield = this.getBlock();
			pre += shield;
			if( amount < 0 && !ignoreBlock ){

				out.blk = this.addBlock(amount);	// Add the full amount to shield first. addBlock caps to 0
				amount += shield;	// Amount is negative, so add the shield
				amount = Math.min(0, amount);		// Min because neg

			}

		}

		this.hp += amount;
		this.hp = Math.floor( Math.max(0, Math.min(this.getMaxHP(), this.hp)) );

		let post = this.hp;
		if( dmgtype )
			post += this.getBlock();

		// Out of combat HP damage can occur, but players can't go under 1. Use SET HP instead if you want to kill someone through an RP.
		if( !game.battle_active && this.hp <= 0 && this.team === Player.TEAM_PLAYER )
			this.hp = 1;

		out.hp = this.hp-prehp;

		if( fText && post-pre !== 0 )
			game.ui.floatingCombatText(out.hp + (out.blk ? '('+Math.abs(out.blk)+')' : ''), this, "hp");

		
		
		if( this.hp === 0 && !wasDead ){

			this.onDeath( sender, effect );

			if( this.hp === 0 )
				out.died = true;

		}

		return out;

	}

	addArousal( amount, fText = false, force = false, sender ){

		if( this.isArousalDisabled() && !force )
			return false;
		if( this.isOrgasming() && !force )
			return;
		if( isNaN(amount) )
			return console.error("Invalid amount of arousal", amount);

		if( !(sender instanceof Player) )
			sender = this;
			
		const pre = this.arousal, max = this.getMaxArousal();
		amount = randRound(amount);
		this.arousal += amount;
		this.arousal = Math.floor( Math.min(max, Math.max(0, this.arousal)) );

		// Out of combat arousal can occur, but players are limited to max-1. Use SET arousal instead if used in an RP.
		if( !game.battle_active && amount > 0 && this.arousal >= max )
			this.arousal = max-1;

		if( this.arousal >= max && pre < max ){

			glib.get("overWhelmingOrgasm", "Wrapper").useAgainst(sender, this, false);
			game.save();
			game.ui.draw();

		}

		if( fText && this.arousal-pre !== 0 )
			game.ui.floatingCombatText(this.arousal-pre, this, "arousal");

	}


	fullRegen(){
		this.hp = this.getMaxHP();
	}

	getMaxHP(){

		if( this.hpMulti < 0 )
			return Math.ceil(Math.abs(this.hpMulti));

		const add = Math.max(0, 15-game.getTeamPlayers().length*5);

		return Math.max(Math.ceil(
			(BASE_HP+add+this.getGenericAmountStatPoints(Effect.Types.maxHP))
			*this.getPowerMultiplier()
			*this.hpMulti
			*this.getGenericAmountStatMultiplier(Effect.Types.maxHP, this)
		), 1);
	}
	getMaxArousal(){
		return Math.ceil(Math.max(3, 
			(BASE_AROUSAL+this.getGenericAmountStatPoints(Effect.Types.maxArousal))
			*this.getGenericAmountStatMultiplier(Effect.Types.maxArousal, this)
		));
	}
	// returns a random chance between 0 and 1
	getCritDoneChance( targ ){

		// 10% baseline chance. Only affects actions with the crit flag set
		// critDoneMod and critTakenMod are ADDITIVE
		let out = 0.1+this.getGenericAmountStatPoints(Effect.Types.critDoneMod, targ);
		if( targ instanceof Player )
			out += targ.getGenericAmountStatPoints(Effect.Types.critTakenMod, this);
		return out;

	}

	// Gets damage multiplier
	getCritDoneMod( target ){
		return this.getGenericAmountStatMultiplier(Effect.Types.critDmgDoneMod, target);
	}

	getCritTakenMod( sender ){
		return this.getGenericAmountStatMultiplier(Effect.Types.critDmgDoneMod, sender);
	}



	/* STATS */
	getPowerMultiplier(){

		let out = this.power;
		if( this.power < 0 )
			out = game.dungeon.getDifficulty()*Math.abs(this.power);
		
		// 0 power becomes 1 for legacy reasons
		if( out === 0 )
			out = 1;
		
		if( this.isNPC() && this.team !== Player.TEAM_PLAYER ){
			if( this.level < 2 )
				out *= 0.5;
			else if( this.level < 4)
				out *= 0.75;
		}
		

		if( out < .1 )
			return .1;
		return out;

	}

	// Effect in these methods are only included to prevent recursion
	// SV Types
	getSV( type ){

		return Math.floor(
			(
				this.getGenericAmountStatPoints('sv'+type)+
				this.getLevel()+
				(this.class ? this.class['sv'+type] : 0)+
				(!isNaN(this['sv'+type]) ? this['sv'+type] : 0)
			)*this.getGenericAmountStatMultiplier('sv'+type, this)
		);
	}

	// Bon types
	getBon( type ){

		return Math.floor(
			(
				this.getGenericAmountStatPoints('bon'+type)+
				this.getLevel()+
				(this.class ? this.class['bon'+type] : 0)+
				(!isNaN(this['bon'+type]) ? this['bon'+type] : 0)
			)*this.getGenericAmountStatMultiplier('bon'+type, this)
		);

	}

	// Returns the sum of effect.data.amount of an effect with type, and that aren't multiplicative
	getGenericAmountStatPoints( type, player ){

		let w = this.getActiveEffectsByType(type),
			out = 0
		;

		for(let effect of w){

			if( effect.data.multiplier )
				continue;

			if( player && effect.data.casterOnly && player.id !== effect.parent.caster )
				continue;

			let n = Calculator.run(
				effect.data.amount, 
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out += n*(effect.no_stack_multi ? 1 : effect.parent.stacks);

		}

		// Effects that should allow a floating point number
		const ALLOW_FLOAT = [
			Effect.Types.critDoneMod,
			Effect.Types.critTakenMod,
		]
		
		if( ALLOW_FLOAT.includes(type) )
			return out;
		
		return Math.round(out);
		
	}

	// Player is only used when checking caster_only, and should be the target
	// Auto checks effects with a conditions property
	getGenericAmountStatMultiplier( type, player ){
		let w = this.getActiveEffectsByType(type),
			out = 1
		;

		// The effect might have a setting to make it a flat stat, or multiply. Multiply being off by default.
		// Some effects are ALWAYS multiplicative, so they can be included here
		const ALWAYS_MULTIPLY = [
			Effect.Types.critDoneMod,
			Effect.Types.expMod,
			Effect.Types.globalArousalTakenMod
		];
		
		const evt = new GameEvent({
			sender : this,
			target : player,
		});

		for( let effect of w ){

			if( !effect.data.multiplier && !ALWAYS_MULTIPLY.includes(type) )
				continue;

			if( player ){

				if( effect.data.casterOnly && player.id !== effect.parent.caster )
					continue;

				if( Array.isArray(effect.data.conditions) ){

					evt.effect = effect;
					evt.wrapper = effect.parent;
					if( !Condition.all(effect.data.conditions, evt) )
						continue;

				}

			}


			let n = Calculator.run(
				effect.data.amount, 
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);

			out *= ((n-1)*(effect.no_stack_multi ? 1 : effect.parent.stacks)+1);
			
		}

		return out;
	}

	getArmorPoints( modified = true ){

		let out = this.armor;
		const slots = [Asset.Slots.lowerBody, Asset.Slots.upperBody];

		for( let slot of slots ){

			let gear = this.getEquippedAssetsBySlots(slot);
			if( gear.length )
				out += gear[0].getArmorPoints();

		}


		if( modified ){

			out += this.getGenericAmountStatPoints(Effect.Types.globalArmorMod);
			out *= this.getGenericAmountStatMultiplier(Effect.Types.globalArmorMod);

		}

		return Math.min(100, Math.max(0, out));

	}

	// Returns a multiplier against damage based on armor, utilizes sender armor penetration if sender is set
	getArmorDamageMultiplier( sender, effect ){

		let reduction = this.getArmorPoints();

		// If sender is present, lower by the sender's armor penetration
		if( sender ){

			// Get armor penetration percentage
			let armorPen = sender.getGenericAmountStatPoints(Effect.Types.globalArmorPen, this)/100;
			// Reduce damage reduction by armor pen
			reduction *= (1-armorPen);
			
		}

		// If effect is present, see if it has the armor_pen value
		if( effect && effect?.data?.armor_pen ){

			// Armor penetration from effects is separate to other effects and multiplied against those, rather than additive which the base effect is
			let armorPen = 1.0-effect.data.armor_pen;
			if( isNaN(armorPen) )
				armorPen = 1.0;

			reduction *= armorPen;

		}

		return 1-reduction/100;

	}
	
	// Takes an attack type and returns a proc chance multiplier
	getStatProcMultiplier( stat, recipient = false){

		let out = 1;
		recipient = Boolean(recipient);
		const effects = this.getActiveEffectsByType(stat.toLowerCase()+'ProcMultiplier');
		for( let effect of effects ){
			if( typeof effect.data.receive === "boolean" && effect.data.receive !== recipient )
				continue;
			const n = Calculator.run(
				effect.data.amount,
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out *= (n*(effect.no_stack_multi ? 1 : effect.parent.stacks));
		};
		return out;

	}

	getHealAggroMultiplier( recipient = false){

		let out = 1;
		const effects = this.getActiveEffectsByType(Effect.Types.healAggroMultiplier);
		for( let effect of effects ){
			if( typeof effect.data.receive === "boolean" && effect.data.receive !== recipient )
				continue;
			const n = Calculator.run(
				effect.data.amount,
				new GameEvent({sender:this, target:this, wrapper:effect.parent, effect:effect})
			);
			out *= (n*(effect.no_stack_multi ? 1 : effect.parent.stacks));
		};
		return out;

	}




	/* Actions */
	addDefaultActions(){

		// Don't add default actions in the editor
		if( !window.game )
			return;

		const evt = new GameEvent({sender:this, target:this});
		let lib = Object.values(glib.getFull('Action')).filter(el => el.std && Condition.all(el.std_conds, evt));
		for( let action of lib ){

			if(!this.getActionByLabel(action.label))
				this.actions.unshift(action.clone(this));

		}

		this.rebindWrappers();

	}

	addActionFromLibrary( label ){

		let asset = glib.getFull('Action')[label];
		if( !asset ){
			console.error("Invalid library asset", label);
			return false;
		}
		return this.addAction(asset);

	}

	addAction( action, silent = false ){

		if( !action ){
			console.error("Invalid action add", action);
			return false;
		}
		if( this.getLearnedActionByLabel(action.label) ){
			if( !silent )
				console.error("Action already learned");
			return false;
		}

		let ac = action.clone(this);
		this.actions.push(ac);
		if( !ac.hidden && !silent )
			game.ui.addText( this.getColoredName()+" learned "+ac.name+"!", undefined, this.id, this.id, 'actionLearned' );
		

		if( !this.actionSlotsFull() && !action.std ){
			this.activateAction(ac.id);
		}

		this.rebindWrappers();

		return true;
	}

	getNrFreeActionSlots(){

		const total = this.getNrActionSlots();
		let occupied = 0;
		for( let action of this.actions ){

			if( !action.std && action._slot > -1 )
				++occupied;
				
		}
		return total-occupied;

	}

	actionSlotsFull(){
		return this.getNrFreeActionSlots() <= 0;
	}

	getActionAtSlot( slot ){

		for( let action of this.actions ){
			if( !action.std && action._slot === slot )
				return action;
		}

	}

	activateAction( id, slot ){
		
		// Doesn't need to be activated if we auto learn. Otherwise this causes issues in the npc generator
		if( this.auto_learn )
			return;

		if( id instanceof Action )
			id = id.id;

		if( this.actionSlotsFull() )
			throw "Action slots are full. Disable one first.";

		

		slot = parseInt(slot);
		if( isNaN(slot) ){

			for( let i=0; i<this.getNrActionSlots(); ++i ){

				if( !this.getActionAtSlot(i) ){
					slot = i;
					break;
				}

			}

		}

		this.deactivateAction(id);
		const action = this.getLearnedAction(id);
		if( !action )
			throw "Trying to activate nonfound action";
		
		if( slot < 0 || isNaN(slot) )
			throw "Out of bounds error on action activation: "+slot;


		action._slot = slot;
		
		this.rebindWrappers();

		return true;

	}

	deactivateAction( id ){

		// Disable an action
		const action = this.getLearnedAction(id);
		if( action )
			action._slot = -1;

		this.rebindWrappers();

	}

	toggleAction( id ){
		
		if( !this.getLearnedAction(id) )
			throw 'Action not found: '+id;
		if( this.isActionActive(id) )
			this.deactivateAction(id);
		else
			this.activateAction(id);

		return true;

	}

	

	// Gets an action from the action array by id, regardless of if it's active or not
	getLearnedAction( id ){

		for( let action of this.actions ){
			if( action === id || action.id === id )
				return action;
		}
		return false;

	}

	// Same as above but checks label
	getLearnedActionByLabel( label ){

		for( let action of this.actions ){

			if( action.label === label )
				return action;

		}

	}

	

	isActionActive( id ){

		const action = this.getLearnedAction(id);
		if( !action )
			return false;

		return action._slot > -1;

	}

	getInactiveActions(){

		const out = [];
		for( let action of this.actions ){
			if( !action.std && !this.isActionActive(action.id) )
				out.push(action);
		}
		return out;

	}

	// Gets actions that can be seen with clairvoyance
	getClairvoyanceActions(){

		return this.getActions('e', false, true, true).filter(action =>
			!action.hidden && !action.no_clairvoyance
		);

	}

	// Checks effects whether an action is enabled.
	isActionEnabled( action ){
		
		const a = action;
		if( typeof action === "string" ){
			action = this.getActionByLabel(a);
			if( !action )
				action = this.getActionById(a);
		}
		if( !action ){
			console.error("Action not found", a);
			return false;
		}

		// Action is considered enabled if it's tied to an action slot, or the player is auto learn, or the action is std, or not directly tied to this player. Such as an item or a wrapper
		return ~action._slot || this.auto_learn || action.std || action.parent !== this;

	}

	// Returns disable EFFECTs that cause the supplied action not to be enabled to this player
	getDisableActionEffects(){
		return this.getActiveEffectsByType(Effect.Types.disableActions);
	}

	removeActionById( id ){
		for( let i in this.actions ){
			let action = this.actions[i];
			if( action.id === id ){
				this.actions.splice(i, 1);
				return true;
			}
		}
		return false;
	}

	// Tries to update actions from database, you should not do this if you've modified actions via the console or spell editor
	refetchActions( std_only = false ){

		let lib = glib.getFull('Action');

		const add = [];
		const actions = this.actions.slice();
		for(let i in actions ){

			const action = actions[i];
			if( !action.std && std_only )
				continue;
			
			if( lib[action.label] ){

				console.debug("Rebasing action", action.label, "with", lib[action.label]);
				this.removeActionById(action.id);
				add.push(lib[action.label]);
				//this.actions[i] = lib[action.label].clone(this);

			}

		}

		for( let a of add ){
			this.addAction(a, true);
		}


	}

	getActionByLabel(label){

		let actions = this.getActions();
		for( let action of actions ){

			if(action.label === label)
				return action;

		}
		return false;

	}

	// If include_items is 'e' it only includes equipped items
	getActions( include_items = true, include_non_learned = false, include_temp = true, sort_result = true ){
		
		let out = this.actions.slice();
		
		if( include_items ){

			const assets = this.getAssets();
			for( let asset of assets ){

				let action = asset.use_action;
				if( !asset.isConsumable )
					console.error("Invalid asset", asset, "in player inventory", this);
				if( asset.isConsumable() && (asset.equipped || include_items !== 'e') )
					out.push(action);

			}

		}
		
		// Filter out nonenabled
		if( !this.auto_learn && !include_non_learned )
			out = out.filter(el => this.isActionEnabled(el));
		
		// Temp actions shouldn't be filtered
		if( include_temp )
			out = out.concat(this.getTempActions());

		if( sort_result ){

			const alwaysFirst = ['stdAttack', 'stdArouse'];
			out.sort((a,b) => {

				const aConsumable = Boolean(a.parent.use_action);
				const bConsumable = Boolean(b.parent.use_action);
				const aName = aConsumable ? a.parent.name : a.name;
				const bName = bConsumable ? b.parent.name : b.name;
				const aIsStd = alwaysFirst.includes(a.label);
				const bIsStd = alwaysFirst.includes(b.label);
				
				// nonconsumable first
				if( aConsumable !== bConsumable )
					return bConsumable ? -1 : 1;

				// Then std
				if( aIsStd !== bIsStd )
					return aIsStd ? -1 : 1;

				// Then positive slots
				if( (a._slot >= 0) !== (b._slot >= 0) )
					return a._slot >= 0 ? -1 : 1;

				// Then sort on spell slot
				if( a._slot !== b._slot )
					return a._slot < b._slot ? -1 : 1;


				// Finally name
				return aName < bName ? -1 : 1;

			});

		}
		
		return out;

	}

	// Rebuilds temp actions
	resetTempActions(){
		this._tmp_actions = [];
		this.getTempActions();
	}
	// Gets temporary actions such as actions granted from effects
	getTempActions(){
		
		// Nonhost gets this from the host
		if( game && !game.is_host && Game.net.isInNetgame() ){
			return this._tmp_actions;	
		}
		
		const ids = {};
		const scanned = {};
		for( let a of this._tmp_actions )
			ids[a.label] = true;

		const effects = this.getActiveEffectsByType(Effect.Types.addActions);
		for( let effect of effects ){

			const actions = Action.loadThese(effect.data.actions, this);
			for( let action of actions ){

				scanned[action.label] = true;
				if( !ids[action.label] ){

					ids[action.label] = true;
					action.g_resetID();
					action._slot = -2;			// TMP action gets assigned -2
					this._tmp_actions.push(action);

				}

			}

		}
		
		// Remove missing ones
		for( let i =0; i<this._tmp_actions.length && this._tmp_actions.length; ++i ){

			const action = this._tmp_actions[i];
			if( !scanned[action.label] ){

				this._tmp_actions.splice(i, 1);
				--i;

			}

		}

		return this._tmp_actions;

	}

	getActionById( id ){

		let actions = this.getActions();
		for( let action of actions ){

			if( action.id === id )
				return action;

		}
		return false;

	}

	useActionId( id, targets, netPlayer ){

		let action = this.getActionById(id);
		if( action ){
			const out = action.useOn(targets, false, netPlayer);
			return out;
		}
		console.error("Action missing", id, "in", this);
		return false;

	}

	useActionLabel( label, targets ){
		
		let action = this.getActionByLabel(label);
		if( action )
			return action.useOn(targets);
		return false;
		
	}

	// Adds auto unlock actions for your class
	addActionsForClass( silent ){
		
		let lib = Object.values(glib.getFull("ActionLearnable"));
		for( let a of lib ){

			if( !a.auto_learn || this.getActionByLabel(a.action) || !a.validate(this) )
				continue;

			const action = a.getAction();
			if( !action )
				continue;
			this.addAction(action, silent);
		

		}


	}

	// Returns ActionLearnable objects that can be unlocked by this player
	getUnlockableActions(){

		let out = [];
		let lib = Object.values(glib.getFull("ActionLearnable"));
		for( let a of lib ){

			if( a.auto_learn || this.getLearnedActionByLabel(a.action) )
				continue;
			if( a.validate(this) )
				out.push(a);

		}

		return out;

	}
	
	getNrActionSlots(){

		if( this.level < 3 )
			return this.level;
		return Player.getActionSlotsForLevel(this.level);	// 3 unlocked by default, then at 4, 7, 10

	}

	getNrPassiveSlots(){
		if( this.level < 5 )
			return 0;
		if( this.level >= 10 )
			return 4;
		return Math.min(4, Math.ceil((this.level-2)/3));
	}

	// Checks encumberance
	updateAutoWrappers(){

		this.auto_wrappers = [];
		if( this.isEncumbered() )
			this.auto_wrappers.push(new Wrapper({
				label : '_encumbered_',
				name : 'Encumbered',
				icon : 'encumbered.svg',
				description : 'You are carrying too much. All hit chance reduced by 50%',
				duration : -1,
				victim : this.id,
				caster : this.id,
				tags : [stdTag.wrEncumbered],
				effects : [
					new Effect({
						type : Effect.Types.globalHitChanceMod,
						data : {amount : 0.5, multiplier:true}
					})
				]
			}, this));

	}

	// Consumes action charges. ForceCooldown can be used to force reset the cooldown
	consumeActionCharges( labels, charges = 1, forceCooldown = false ){
		if( !Array.isArray(labels) )
			labels = [labels];

		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action ){
				action.consumeCharges(charges, forceCooldown);
			}
		}
	}

	// Adds action charges by labels
	addActionCharges( labels, charges = 1 ){
		if( !Array.isArray(labels) )
			labels = [labels];
		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action )
				action.consumeCharges(-charges);
		}
	}

	// Adds action cooldowns by labels
	addActionCooldowns( labels, amount ){
		if( !Array.isArray(labels) )
			labels = [labels];
		for( let label of labels ){
			let action = this.getActionByLabel(label);
			if( action )
				action.addCooldown(amount);
		}
	}

	// returns an array of charged actions or false if none. You can supply your own actions array to prevent recursion or check specific actions. 
	isCasting( actions ){

		if( !actions )
			actions = this.getActions(true, false, true, false);

		let spells = [];
		for( let action of actions ){
			if( action._cast_time > 0 )
				spells.push(action);
		}
		if( spells.length )
			return spells;
		return false;

	}

	// Returns nr actions interrupted successfully
	interrupt( sender, force = false ){
		
		let actions = this.isCasting();
		if( !actions )
			return 0;
		let out = 0;
		for( let action of actions ){
			if( action.interrupt(sender, force) )
				++out;
		}
		return out;
	}

	// Checks the allowReceiveSpells effect
	checkActionFilter( sender, action ){
		if( !(action instanceof Action) ){
			console.error("Action", action, "is not an action");
			return false;
		}
		const effects = this.getActiveEffectsByType(Effect.Types.allowReceiveSpells);
		const evt = new GameEvent({action:action, sender:sender, target:this});
		for( let effect of effects ){
			evt.effect = effect;
			if( !Condition.all(effect.data.conditions, evt) )
				return false;
		}
		return true;
	}

	// Checks if this doesn't have the untargetable effect against an action
	hasTargetableForAction( action ){

		if( !(action instanceof Action) )
			throw 'Trying to check untargetable against non action';

		// Self cast always allowed
		if( action.parent === this )
			return true;

		let effects = this.getActiveEffectsByType( Effect.Types.untargetable );
		// No effects
		if( !effects.length )
			return true;

		let disallowFriendly = effects.filter(el => !el?.data?.beneficial).length;
		// Allow friendly actions through if all effects have allow friendly
		if( !disallowFriendly && !action.detrimental )
			return true;
		
		// Check if at least one has the action label
		for( let effect of effects ){
			// AoE is allowed, skip this
			if( action.target_type === Action.TargetTypes.aoe && effect?.data?.allow_aoe )
				continue;
			// No exceptions, just return
			let arr = effect?.data?.exceptions;
			if( !arr )
				return false;		// No exceptions!
			// Check if it's in exceptions
			arr = toArray(arr);
			if( !arr.includes(action.label) )
				return false;

		}


		return true;

	}


	/* Wrappers */
	// Force lets you override cache, if unequipped is true, it also uses asset-attached wrappers that aren't equipped
	getWrappers( force = false, unequipped = false ){

		if( !window.game )
			return [];

		if( game._caches && this._cache_wrappers && !force )
			return this._cache_wrappers;

		const evt = new GameEvent({
			target : this,
			sender: this,
			dungeon : game.dungeon,
		});

		let out = this.wrappers
			.filter(el => {
				if( !el.asset || unequipped )
					return true;
				const asset = this.getAssetById(el.asset); 
				return asset && asset.equipped;
			})
			.concat(
				this.passives, 
				game.encounter.passives.filter(el => {

					return Condition.all(el.add_conditions || [], evt);

				})
				.map(el => { 
					/*
					el = el.clone();
					el.caster = '';
					el.victim = this.id;
					*/
					el.caster = this.id;
					el.victim = this.id;
					return el;

				})
			);

		const assets = this.getAssetsEquipped(false);
		for( let asset of assets )
			out = out.concat(asset.wrappers);

		// Note: temp actions can't have passives for recursion reasons
		const actions = this.getActions(true, false, false, false);
		for( let action of actions )
			out = out.concat(action.passives);

		let casting = this.isCasting( actions );
		if( casting ){

			for( let c of casting )
				out = out.concat(c.cpassives);

		}

		const ret = out.concat(this.auto_wrappers);
		if( game._caches )
			this._cache_wrappers = ret;

		return ret;

	}

	getWrapperByLabel( label ){
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){

			if( wrapper.label === label )
				return wrapper;

		}
	}

	getActiveEffectsByType( type ){
		
		return this.getEffects().filter(fx => {
			return (fx.type === type && (!this._ignore_effects || this._ignore_effects.indexOf(fx) === -1));
		});

	}

	removeWrapper( wrapper ){

		for(let i in this.wrappers){

			if( this.wrappers[i] === wrapper ){

				this.wrappers.splice(i, 1);
				this.rebindWrappers();
				return true;

			}

		}
		return false;

	}

	// Wrappers that shouldn't be added. Returns an array.
	getBlockedWrappers(){
		
		let effects = this.getActiveEffectsByType(Effect.Types.preventWrappers);
		let blocked = {};
		for( let effect of effects ){

			if( effect.data.labels ){

				let labels = toArray(effect.data.labels);
				for( let label of labels )
					blocked[label] = true;

			}

		}
		return Object.keys(blocked);

	}


	// Use Wrapper.useAgainst, not this
	// Also see rebindWrappers for ignoreStayCheck
	addWrapper( wrapper, ignoreStayCheck = false ){

		if( typeof wrapper === "string" ){
			console.error("Attempting to use addWrapper with a string. You probably wanted game.utilAddWrapper(target, '"+wrapper+"', sender=target)", );
			return;
		}

		wrapper.parent = this;
		this.wrappers.push(wrapper);
		this.handleWrapperStun(wrapper);
		this.rebindWrappers(ignoreStayCheck);

	}

	handleWrapperStun( wrapper ){

		let isStun = wrapper.getEffects({ type:Effect.Types.stun });
		if( 
			isStun.length && 
			wrapper.duration > 0 && 
			(!isStun[0].data || !isStun[0].data.ignoreDiminishing) 
		)this._stun_diminishing_returns += wrapper._duration*2;
		
		if( isStun.length )
			this.interrupt( wrapper.getCaster(), true );

	}

	getActiveWrappersWithTag(...tags){
		return this.getWrappers().filter(wrapper => {
			return wrapper.hasTag(tags);
		});
	}

	// overWhelmingOrgasm triggered from max arousal
	isOrgasming(){
		const wrappers = this.getWrappers();
		for( let wrapper of wrappers ){
			if( wrapper.label === "overWhelmingOrgasm" ){
				return true;
			}
		}
	}

	// Makes sure passives have the right ID
	updatePassives(){

		for( let passive of this.passives ){

			passive.caster = passive.victim = this.id;
			passive.parent = this;
			passive.bindEvents();

		}

	}

	removePassive( wrapper ){

		wrapper.unbindEvents();
		let pos = this.passives.indexOf(wrapper);
		if( pos > -1 )
			this.passives.splice(pos, 1);

	}

	addPassive( wrapper ){

		if( typeof wrapper === 'string' )
			wrapper = glib.get(wrapper, 'Wrapper');

		if( !(wrapper instanceof Wrapper) ){
			console.error("Invalid passive", wrapper);
			throw 'Trying to add non-wrapper';
		}

		this.passives.push(wrapper.clone());
		this.updatePassives();

	}

	// Gets all library wrappers marked as global and adds all matching conditions
	// If refresh is true, global passives are removed and new ones added
	addGlobalPassives( refresh = false ){

		if( refresh )
			this.passives
				.filter(el => el.global)
				.map(el => this.removePassive(el))
			;

		const all = Wrapper.getGlobalWrappers();
		const evt = new GameEvent({sender:this, target:this});
		for( let wrapper of all ){

			if( wrapper.testAgainst(evt) )
				this.addPassive(wrapper);

		}

	}

	
	/* Effects */
	// Gets all effects (effects on other players may affect you if the target is you or AoE)
	getEffects( force = false ){

		if( !window.game )
			return [];

		if( game._caches && this._cache_effects && !force )
			return this._cache_effects;

		

		let out = new Map();
		for( let player of game.getEnabledPlayers() ){
			
			const wrappers = player.getWrappers();

			for( let wrapper of wrappers ){

				const effects = wrapper.getEffectsForPlayer(this);
				for( let effect of effects )
					out.set(effect, true);

			}

		}

		out = Array.from(out.keys());
		if( game._caches )
			this._cache_effects = out;

		return out;

	}	
	getDisabledLevel(){
		let level = 0;
		const effects = this.getActiveEffectsByType(Effect.Types.disable);
		for( let effect of effects ){
			let lv = effect.level;
			if( isNaN(lv) )
				lv = 1;
			if( lv > level )
				level = lv;
		}
		return level;
	}
	// Returns true if any of the disabled effects triggers it
	getDisabledHidden(){
		const effects = this.getActiveEffectsByType(Effect.Types.disable);
		for( let effect of effects ){
			if( effect.data.hide )
				return true;
		}
	}

	isHealInverted(){
		return this.getActiveEffectsByType(Effect.Types.healInversion).length;
	}

	isInterruptProtected(){
		return this.getActiveEffectsByType(Effect.Types.blockInterrupt).length;
	}



	/* CHATS */
	onChatUsed( id ){

		this._used_chats[id] = true;

		if( !game.battle_active )
			this._last_chat = Date.now();
		else
			this._last_chat = game.totTurns;

	}

	hasUsedChat( id ){
		return this._used_chats[id];
	}
	// Checks if this NPC has chatted too recently
	canOptionalChat(){

		if( !game.battle_active )
			return ( Date.now()-this._last_chat > 3000 );	// Max 3 sec when out of combat

		let turnsSinceLastSpoke = game.totTurns-this._last_chat;
		return Math.random() < turnsSinceLastSpoke*Math.pow(this.talkative, 2);

	}


	// Bot
	async autoPlay( force ){

		if( !this.isNPC() && !force )
			return;
		return await this.bot.play( force );

	}

	usePunishment( players, force ){
		
		if( !this.isNPC() && !force )
			return;
		this.bot.punish(players);

	}
	


	// Static
	static getActionSlotsForLevel( level ){
		return Math.min(this.MAX_ACTION_SLOTS, Math.floor((level-4)/3)+4);
	}
	static getLevelForActionSlot( index ){

		// First 3 slots are unlocked immediately
		if( index < 3 )
			return 1;
		
		return 4+Math.floor((index-3)*3);

	}

	// Returns a value where <= 0 = always miss, and >= 100 = always hit
	static getHitChance( attacker, victim, action ){

		if( attacker.id === victim.id )
			return 100;
		if( !action.detrimental )
			return 100;
		if( action.hit_chance > 100 )
			return 100;

		let out = action.hit_chance;
		let modifier = (1+((attacker.getBon(action.type)-victim.getSV(action.type))*0.05))
			*attacker.getGenericAmountStatMultiplier(Effect.Types.globalHitChanceMod, victim)
		;
		if( modifier < 0.1 )
			modifier = 0.1;

		// Hit chance above 100 is set as "always hit"
		return Math.max(10, Math.round(out*modifier+attacker.getGenericAmountStatPoints(Effect.Types.globalHitChanceMod, victim)));

	};


	static getAdvantage( attacker, victim, stat, detrimental ){

		let tot = attacker.getBon(stat);
		if( detrimental )
			tot -= victim.getSV(stat);
		return tot;

	};

	// Returns a multiplier of 4% if you go over 100% hit chance
	static getBonusDamageMultiplier( attacker, victim, stat, detrimental ){

		let tot = this.getAdvantage(attacker, victim, stat, detrimental);

		if( tot < 0 )
			tot = 0;

		// Add 25% bonus damage per additional player
		let add = 1;
		if( attacker.team !== 0 ){

			const tp = game.getTeamPlayers().filter(pl => !pl.isNPC());
			add = 1+(tp.length-1)*0.2;
			// increase enemy damage by 20% per player

			// Reduce enemy damage at low levels
			// level 1 has -50%, level 2 has -25%
			if( attacker.level < 3 )
				add -= 0.25*(3-attacker.level);

		}

		// Each point of advantage adds 10% damage
		const out = (1+tot*0.1)*add;
		return out;

	};


	// Exchanges copper into the fewest coins possible
	// returns an array of [platinum, gold, silver, copper] after exchange. You can use Player.currencyWeights to map this to assets
	static calculateMoneyExhange( input = 0 ){
		return [
			Math.floor(input/1000),
			Math.floor((input%1000)/100),
			Math.floor((input%100)/10),
			input%10
		];
	};

	// Converts copper into an array of assets
	static copperToAssets( copper = 0 ){

		const out = [];
		const exchanged = this.calculateMoneyExhange( copper );

		for( let i in exchanged ){
			const amt = exchanged[i];
			if( amt ){
				const label = this.currencyWeights[i];
				const a = glib.get(label, 'Asset');
				a._stacks = amt;
				out.push(a);
			}
		}
		return out;

	};

	static copperToReadable( copper = 0 ){
		const coins = this.calculateMoneyExhange(copper);
		let out = [];
		for( let i in coins ){
			if( coins[i] )
				out.push(coins[i]+' '+Player.currencyWeights[i]);
		}
		if( !out.length )
			return '0 copper';
		return out.join(', ');
	};


	async exportFile(){

		const zip = new JSZip();
		zip.file(
			'player.json', 
			JSON.stringify(Player.saveThis(this, true))
		);

		const content = await zip.generateAsync({
			type:"blob",
			compression : "DEFLATE",
			compressionOptions : {
				level: 9
			}
		})
		
		const a = document.createElement('a');
		const url = URL.createObjectURL(content);

		a.setAttribute('href', url);
		a.setAttribute('download', this.name + '.fqchar');

		document.body.appendChild(a);
		a.click();
		a.remove();

		game.ui.modal.addNotice('Player exported!');

	};

	// Takes a file event, imports it, and returns a new player
	static async importFile( event ){

		const file = event.target.files[0];
		if( !file )
			return;

		const zip = await JSZip.loadAsync(file);

		let player;
		for( let path in zip.files ){

			if( path !== 'player.json' )
				continue;

			const entry = zip.files[path];
			try{

				const raw = JSON.parse(await entry.async("text"));
				if( !raw.id || !raw.name )
					throw 'INVALID_ID';
				
				player = new this(raw);
				player.g_resetID();


			}catch(err){

				let reason = "JSON Error";
				if( err === "INVALID_ID" )
					reason = 'Required parameters missing';
				alert("This is not a valid player file ("+reason+")");
				console.error(err);

			}

			break;

		}

		return player;

	};

	// Rechecks if AI art is enabled or not
	static checkEnableAI(){
		this.AI_ENABLED = !+localStorage.disable_ai;
	};

	// returns an int between 0 and 2 if momentum is valid, or -1 if invalid
	static getValidMomentum(type){
		type = Math.trunc(type);
		if( type > -2 && type < 3 )
			return type;
		return -1;
	}

	static getRandomMomentum(){
		return Math.floor(Math.random()*3);
	}

}

Player.AI_ENABLED = true;	// AI art enabled or not

Player.MAX_LEVEL = 14;

Player.TEAM_PLAYER = 0;
Player.TEAM_ENEMY = 1;
Player.MAX_MOMENTUM = 9;	// Hardcoded limit. Technically can go up to 26 without violating Number.MAX_SAFE_INTEGER
							// The reason for this is that the array is packed into a single int made up of 2-bit values when transferred


Player.MAX_ACTION_SLOTS = 6;
Player.MISSING_ART = 'media/characters/missing_art.jpg';

// Momentum types
Player.MOMENTUM = {
	All : -1,
	Off : 0,
	Def : 1,
	Uti : 2
};
// Array that can be used to iterate through the types
Player.MOMENTUM_TYPES = [Player.MOMENTUM.Off,Player.MOMENTUM.Def,Player.MOMENTUM.Uti];
Player.MOMENTUM_COLORS = ['#FDD','#DDF','#FDF'];
Player.MOMENTUM_NAMES = ['Offensive', 'Defensive', 'Utility'];
Player.MOMENTUM_NAMES_SHORT = ['Off', 'Def', 'Uti'];

Player.currencyWeights = [
	'platinum',
	'gold',
	'silver',
	'copper'
];
Player.currencyColors = [
	'#FFF',
	'#FF8',
	'#AAA',
	'#FA8'
];

Player.checkEnableAI();	// Can do this immediately

// Saves the last used action in a grouped action
class PlayerActionGroup extends Generic{
	
	constructor(data){
		super(data);

		this.id = '';		// group name
		this.active = '';	// id of active action

		this.load(data);
	}

	save(){

		const out = {
			id : this.id,
			active : this.active
		};
		return out;

	}


	load( data ){
		this.g_autoload(data);
	}

	rebase(){
		this.g_rebase();	// Super
	}


}


